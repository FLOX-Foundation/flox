{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flox","text":"<p>Flox is a modular C++ framework for building ultra-low-latency execution systems. It provides a strict separation between abstract interfaces and high-performance implementations, designed for:</p> <ul> <li>Real-time and historical trading infrastructure</li> <li>Event-driven architecture with tick-level granularity</li> <li>Unified simulation and live execution environments</li> <li>Deterministic latency and memory control</li> </ul>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Pluggable exchange connectors via <code>ExchangeConnector</code> and <code>ConnectorFactory</code></li> <li>Lock-free <code>EventBus</code> with support for both sync and async fan-out</li> <li>Fast tick-aligned in-memory order books (<code>NLevelOrderBook</code>)</li> <li>Strategy layer with explicit lifecycle and bus integration</li> <li>Unified <code>IMarketDataSubscriber</code> interface for book, trade, and candle events</li> <li>Modular design: each component is testable, swappable, and lifecycle-aware</li> <li>Explicit memory and object reuse via pooled <code>Handle&lt;T&gt;</code> and <code>Pool&lt;T&gt;</code></li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Flox is a modular framework for building low-latency execution systems. Its design emphasizes separation of concerns, predictable performance, and composability.</p>"},{"location":"architecture/#layers-of-the-architecture","title":"Layers of the Architecture","text":""},{"location":"architecture/#1-abstract-layer","title":"1. Abstract Layer","text":"<p>Defines pure interfaces with no internal state. These are the contracts your system is built upon:</p> <ul> <li><code>IStrategy</code>: strategy logic</li> <li><code>IOrderExecutor</code>: order submission</li> <li><code>IOrderExecutionListener</code>: execution events</li> <li><code>IRiskManager</code>, <code>IOrderValidator</code>, <code>IPositionManager</code>: trade controls and state</li> <li><code>IOrderBook</code>, <code>ExchangeConnector</code>: market structure</li> <li><code>ISubsystem</code>: unified lifecycle interface</li> <li><code>IMarketDataSubscriber</code>: receives events via data bus</li> </ul>"},{"location":"architecture/#why-it-matters","title":"Why it matters","text":"<ul> <li>Enables simulation, replay, and mocking</li> <li>Decouples logic from implementation</li> <li>Ensures correctness can be validated independently of performance</li> </ul>"},{"location":"architecture/#2-implementation-layer","title":"2. Implementation Layer","text":"<ul> <li><code>Engine</code>: orchestrates startup and shutdown</li> <li><code>NLevelOrderBook</code>: in-memory order book with tick-aligned price levels</li> <li><code>CandleAggregator</code>: aggregates trades into fixed-interval OHLCV candles</li> <li><code>SymbolRegistry</code>: maps <code>(exchange:symbol)</code> pairs to compact <code>SymbolId</code></li> <li><code>EventBus</code>: event fan-out with push/pull delivery modes and sync/async policy</li> <li><code>BookUpdateEvent</code>, <code>TradeEvent</code>: pooled, reusable market data structures</li> </ul>"},{"location":"architecture/#features","title":"Features","text":"<ul> <li>Speed: tight memory layout, preallocated event structures</li> <li>Control: no heap allocation in event flow, deterministic dispatch</li> <li>Modularity: all components are independently replaceable and testable</li> </ul>"},{"location":"architecture/#strategy-execution-push-and-pull-modes","title":"Strategy Execution: PUSH and PULL Modes","text":"<p>Strategies implement <code>IMarketDataSubscriber</code> and can operate in two modes:</p>"},{"location":"architecture/#push-mode-default","title":"PUSH Mode (default)","text":"<p>The bus actively delivers events to the strategy:</p> <pre><code>class MyPushStrategy : public IStrategy {\npublic:\n  void onBookUpdate(const BookUpdateEvent&amp; ev) override { /* handle event */ }\n};\n</code></pre> <pre><code>marketDataBus-&gt;subscribe(strategy);\n</code></pre>"},{"location":"architecture/#pull-mode","title":"PULL Mode","text":"<p>The strategy explicitly drains its queue:</p> <pre><code>class MyPullStrategy : public IMarketDataSubscriber {\npublic:\n  SubscriberMode mode() const override { return SubscriberMode::PULL; }\n\n  void readLoop(SPSCQueue&lt;EventHandle&lt;BookUpdateEvent&gt;&gt;&amp; queue) {\n    EventHandle&lt;BookUpdateEvent&gt; ev;\n    while (queue.pop(ev)) {\n      EventDispatcher&lt;EventHandle&lt;BookUpdateEvent&gt;&gt;::dispatch(ev, *this);\n    }\n  }\n};\n</code></pre>"},{"location":"architecture/#market-data-fan-out-marketdatabus","title":"Market Data Fan-Out: MarketDataBus","text":"<p>The <code>MarketDataBus</code> delivers <code>EventHandle&lt;T&gt;</code> to each subscriber using dedicated <code>SPSCQueue</code>s.</p>"},{"location":"architecture/#publishing","title":"Publishing:","text":"<pre><code>bus-&gt;publish(std::move(bookUpdate));\n</code></pre>"},{"location":"architecture/#subscribing","title":"Subscribing:","text":"<pre><code>bus-&gt;subscribe(myStrategy);\n</code></pre>"},{"location":"architecture/#behavior","title":"Behavior:","text":"<ul> <li>Each subscriber has an isolated queue</li> <li>Events are delivered via <code>EventDispatcher</code></li> <li>In <code>SyncPolicy</code>, all subscribers are synchronized via <code>TickBarrier</code> and <code>TickGuard</code></li> </ul>"},{"location":"architecture/#lifecycle-and-subsystems","title":"Lifecycle and Subsystems","text":"<p>All major components implement <code>ISubsystem</code>, exposing <code>start()</code> and <code>stop()</code> methods.</p> <p>Benefits:</p> <ul> <li>Deterministic lifecycle control</li> <li>Support for warm-up, teardown, benchmarking</li> <li>Simplified simulation and test orchestration</li> </ul>"},{"location":"architecture/#memory-and-performance","title":"Memory and Performance","text":"<p>Flox is designed for allocation-free execution on the hot path:</p> <ul> <li><code>BookUpdateEvent</code>, <code>TradeEvent</code> come from <code>Pool&lt;T&gt;</code></li> <li><code>Handle&lt;T&gt;</code> ensures safe ref-counted reuse</li> <li><code>SPSCQueue</code> provides lock-free delivery</li> <li><code>std::pmr::vector</code> used in <code>BookUpdate</code> avoids heap churn</li> </ul>"},{"location":"architecture/#symbol-centric-design","title":"Symbol-Centric Design","text":"<p>All routing and lookup is based on <code>SymbolId</code> (<code>uint32_t</code>):</p> <ul> <li>Fast lookup, avoids string comparison</li> <li>Enables per-symbol state machines, queues, books</li> <li>Supports dense fan-out architectures</li> </ul>"},{"location":"architecture/#intended-use","title":"Intended Use","text":"<p>Flox is not a full trading engine \u2014 it\u2019s a toolkit for building:</p> <ul> <li>Real-time trading systems</li> <li>Simulators and replay backtesters</li> <li>Signal fan-out and market data routers</li> <li>Custom HFT infrastructure</li> </ul> <p>Designed for teams that require:</p> <ul> <li>Predictable low-latency performance</li> <li>Explicit memory and thread control</li> <li>Modular, testable architecture</li> </ul>"},{"location":"architecture/#example-integration","title":"Example Integration","text":"<pre><code>auto strategy = std::make_shared&lt;MyStrategy&gt;();\nmarketDataBus-&gt;subscribe(strategy);\n\nmarketDataBus-&gt;publish(std::move(bookUpdate));\n</code></pre> <p>In pull-mode:</p> <pre><code>auto* queue = marketDataBus-&gt;getQueue(strategy-&gt;id());\nEventHandle&lt;BookUpdateEvent&gt; ev;\nwhile (queue-&gt;pop(ev)) {\n  EventDispatcher&lt;EventHandle&lt;BookUpdateEvent&gt;&gt;::dispatch(ev, *strategy);\n}\n</code></pre>"},{"location":"architecture/#summary","title":"Summary","text":"<p>Flox is:</p> <ul> <li>Modular \u2014 use only what you need</li> <li>Deterministic \u2014 fully controlled event timing</li> <li>Safe \u2014 no hidden allocations, pooled memory</li> <li>Flexible \u2014 works in backtests, simulation, and live systems</li> </ul> <p>You define the logic \u2014 Flox moves the data.</p>"},{"location":"components/common/","title":"Common Types","text":"<p>This header defines core types and enums used throughout the Flox engine, including identifiers, numeric types (price, quantity), and domain-specific enums.</p>"},{"location":"components/common/#enums","title":"Enums","text":""},{"location":"components/common/#ordertype","title":"<code>OrderType</code>","text":"<p>Represents the execution style of an order.</p> <pre><code>enum class OrderType {\n  LIMIT,\n  MARKET\n};\n</code></pre>"},{"location":"components/common/#side","title":"<code>Side</code>","text":"<p>Represents the direction of an order.</p> <pre><code>enum class Side {\n  BUY,\n  SELL\n};\n</code></pre>"},{"location":"components/common/#identifiers","title":"Identifiers","text":"Type Description <code>SymbolId</code> Unique identifier for a symbol. <code>OrderId</code> Unique identifier for an order."},{"location":"components/common/#fixed-point-types","title":"Fixed-Point Types","text":"<p>Built on top of the <code>Decimal</code> template for safe, precise arithmetic.</p> Type Scale Description <code>Price</code> 1e-6 Decimal representation of price. <code>Quantity</code> 1e-6 Decimal quantity (e.g. number of contracts). <code>Volume</code> 1e-6 Price \u00d7 Quantity, used in candle bars etc. <p>All three types use <code>Decimal&lt;Tag, 1'000'000, 1&gt;</code> internally, ensuring:</p> <ul> <li>High precision (6 decimal places)</li> <li>Strong typing (tags prevent mixing price and size)</li> <li>Tick-aligned operations and rounding support</li> </ul>"},{"location":"components/common/#notes","title":"Notes","text":"<ul> <li>These types are used pervasively across all order-related and market data structures.</li> <li>Prevents accidental unit mismatches (e.g., adding price and quantity).</li> <li>Tick size granularity is currently fixed to <code>1</code>.</li> </ul>"},{"location":"components/aggregator/candle_aggregator/","title":"CandleAggregator","text":"<p><code>CandleAggregator</code> transforms incoming <code>TradeEvent</code>s into time-aligned OHLCV candles and broadcasts them via <code>CandleBus</code>.</p> <pre><code>class CandleAggregator : public ISubsystem, public IMarketDataSubscriber {\npublic:\n  CandleAggregator(std::chrono::seconds interval, CandleBus* bus);\n  void start() override;\n  void stop() override;\n\n  SubscriberId id() const override;\n  SubscriberMode mode() const override;\n\n  void onTrade(const TradeEvent&amp; trade) override;\n\nprivate:\n  struct PartialCandle {\n    Candle candle;\n    bool initialized = false;\n  };\n\n  std::chrono::seconds _interval;\n  CandleBus* _bus;\n  std::vector&lt;std::optional&lt;PartialCandle&gt;&gt; _candles;\n\n  TimePoint alignToInterval(TimePoint tp);\n};\n</code></pre>"},{"location":"components/aggregator/candle_aggregator/#purpose","title":"Purpose","text":"<ul> <li>Buffer and roll trades into interval-based candles, suitable for downstream analytics or strategy inputs.</li> </ul>"},{"location":"components/aggregator/candle_aggregator/#responsibilities","title":"Responsibilities","text":"Aspect Details Interval Candle size defined by <code>_interval</code>, validated at construction. Event input Consumes only <code>TradeEvent</code>; no handling for books or candles. Event output Emits <code>CandleEvent</code> to all subscribers via <code>CandleBus</code>. Lifecycle Hooks into engine via <code>ISubsystem::start()</code> and <code>stop()</code>. Subscriber ID Uses object pointer as a unique <code>SubscriberId</code>. Mode Operates in <code>PUSH</code> mode for direct event delivery."},{"location":"components/aggregator/candle_aggregator/#internal-behavior","title":"Internal Behavior","text":"<ol> <li> <p>Time Slot Alignment    Trade timestamps are aligned using <code>alignToInterval()</code> to find the start of the containing interval.</p> </li> <li> <p>Per-Symbol Buffering <code>_candles</code> is a <code>std::vector&lt;std::optional&lt;PartialCandle&gt;&gt;</code>, indexed by <code>SymbolId</code>, pre-sized for all known symbols.</p> </li> <li> <p>Candle Rollover    If a trade belongs to a new interval, the previous candle is finalized and sent; a new <code>PartialCandle</code> is started.</p> </li> <li> <p>No Hot Allocations    Once the vector is initialized, the hot path is allocation-free; avoids <code>unordered_map</code> lookup cost.</p> </li> </ol>"},{"location":"components/aggregator/candle_aggregator/#notes","title":"Notes","text":"<ul> <li>Designed for maximum cache-friendliness and fan-out throughput.</li> <li>Ignores out-of-order or backdated trades \u2014 assumes input stream is clean and ordered.</li> <li>Fully decoupled via <code>CandleBus</code>; downstream consumers remain unaware of source logic.</li> </ul>"},{"location":"components/aggregator/bus/candle_bus/","title":"CandleBus","text":"<p><code>CandleBus</code> is a publish-subscribe channel for <code>CandleEvent</code> messages, used to deliver aggregated candles from <code>CandleAggregator</code> to downstream consumers (e.g., strategies, loggers).</p> <pre><code>#ifdef FLOX_USE_SYNC_CANDLE_BUS\nusing CandleBus = EventBus&lt;CandleEvent, SyncPolicy&lt;CandleEvent&gt;&gt;;\n#else\nusing CandleBus = EventBus&lt;CandleEvent, AsyncPolicy&lt;CandleEvent&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/aggregator/bus/candle_bus/#purpose","title":"Purpose","text":"<ul> <li>Fan-out distribution of <code>CandleEvent</code> to all registered subscribers.</li> </ul>"},{"location":"components/aggregator/bus/candle_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Policy Chooses between <code>SyncPolicy</code> and <code>AsyncPolicy</code> via compile-time flag. Binding Type alias for <code>EventBus&lt;CandleEvent, Policy&gt;</code>. Usage Integrated into <code>CandleAggregator</code>; consumed by strategies and metrics."},{"location":"components/aggregator/bus/candle_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> ensures deterministic tick-to-tick sequencing for backtesting.</li> <li><code>AsyncPolicy</code> enables low-latency lock-free fan-out in live trading.</li> <li>Controlled via the <code>FLOX_USE_SYNC_CANDLE_BUS</code> macro, toggled at compile time.</li> </ul>"},{"location":"components/aggregator/events/candle_event/","title":"CandleEvent","text":"<p><code>CandleEvent</code> represents a finalized OHLCV candle for a specific instrument and time interval, emitted by <code>CandleAggregator</code> and delivered via <code>CandleBus</code>.</p> <pre><code>struct CandleEvent {\n    using Listener = IMarketDataSubscriber;\n\n    SymbolId       symbol{};                             // instrument identifier\n    InstrumentType instrument = InstrumentType::Spot;    // Spot | Future | Option\n    Candle         candle{};                             // aggregated OHLCV data\n    uint64_t       tickSequence = 0;                     // global sequencing\n};\n</code></pre>"},{"location":"components/aggregator/events/candle_event/#purpose","title":"Purpose","text":"<ul> <li>Encapsulate a single time-aggregated candle with instrument metadata for downstream processing and filtering.</li> </ul>"},{"location":"components/aggregator/events/candle_event/#responsibilities","title":"Responsibilities","text":"Field / Aspect Description symbol Unique <code>SymbolId</code> of the instrument. instrument Instrument class (<code>Spot</code>, <code>Future</code>, or <code>Option</code>) for fast filtering. candle Aggregated OHLCV data (<code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>, timeframe). tickSequence Monotonic sequence number for deterministic ordering (sync mode). Listener Defines <code>IMarketDataSubscriber</code> as the subscriber interface for <code>CandleBus</code>."},{"location":"components/aggregator/events/candle_event/#notes","title":"Notes","text":"<ul> <li><code>instrument</code> removes the need for a registry lookup in hot paths.</li> <li><code>tickSequence</code> guarantees strict ordering when <code>CandleBus</code> runs in synchronous mode.</li> <li>Used identically in live trading and back-testing environments.</li> </ul>"},{"location":"components/book/abstract_order_book/","title":"IOrderBook","text":"<p><code>IOrderBook</code> defines the abstract interface for order book implementations that consume <code>BookUpdateEvent</code>s and provide access to market depth and price levels.</p> <pre><code>class IOrderBook {\npublic:\n  virtual ~IOrderBook() = default;\n\n  virtual void applyBookUpdate(const BookUpdateEvent&amp; update) = 0;\n  virtual std::optional&lt;Price&gt; bestBid() const = 0;\n  virtual std::optional&lt;Price&gt; bestAsk() const = 0;\n\n  virtual Quantity bidAtPrice(Price price) const = 0;\n  virtual Quantity askAtPrice(Price price) const = 0;\n};\n</code></pre>"},{"location":"components/book/abstract_order_book/#purpose","title":"Purpose","text":"<ul> <li>Define a common contract for order book consumers, simulators, and strategy components.</li> </ul>"},{"location":"components/book/abstract_order_book/#responsibilities","title":"Responsibilities","text":"Aspect Details Update <code>applyBookUpdate()</code> ingests raw changes from <code>BookUpdateEvent</code>. Top of book <code>bestBid()</code> / <code>bestAsk()</code> expose inside market prices. Depth query <code>bidAtPrice()</code> / <code>askAtPrice()</code> return size at arbitrary levels."},{"location":"components/book/abstract_order_book/#notes","title":"Notes","text":"<ul> <li>Stateless interface \u2014 actual book implementation (e.g. <code>NLevelOrderBook</code>) manages memory and performance.</li> <li>Compatible with pooled update dispatch via <code>BookUpdateBus</code>.</li> <li>Returns <code>std::optional</code> for top-of-book queries to reflect potential emptiness.</li> </ul>"},{"location":"components/book/book_update/","title":"BookUpdate","text":"<p><code>BookUpdate</code> is a zero-allocation container for transmitting order-book snapshots or deltas. It now supports multiple instrument classes (spot, futures, options) and includes optional option metadata.</p> <pre><code>struct BookUpdate\n{\n    SymbolId              symbol{};                          // instrument identifier\n    InstrumentType        instrument = InstrumentType::Spot; // Spot | Future | Option\n    BookUpdateType        type{};                            // SNAPSHOT | DELTA\n    std::pmr::vector&lt;BookLevel&gt; bids;                        // depth on bid side\n    std::pmr::vector&lt;BookLevel&gt; asks;                        // depth on ask side\n    TimePoint             timestamp{};                       // receive-time\n\n    // \u2014 Option-specific fields \u2014\n    std::optional&lt;Price&gt;       strike;                       // strike price\n    std::optional&lt;TimePoint&gt;   expiry;                       // option expiry\n    std::optional&lt;OptionType&gt;  optionType;                   // Call | Put\n\n    explicit BookUpdate(std::pmr::memory_resource* res)\n        : bids(res), asks(res) {}\n};\n</code></pre>"},{"location":"components/book/book_update/#purpose","title":"Purpose","text":"<ul> <li>Provide a normalized, memory-efficient representation of an order-book update (full snapshot or incremental delta).  </li> <li>Embed the instrument class so downstream components can branch without a registry lookup.</li> </ul>"},{"location":"components/book/book_update/#responsibilities","title":"Responsibilities","text":"Field / Aspect Description symbol Unique <code>SymbolId</code> of the instrument. instrument <code>Spot</code>, <code>Future</code>, or <code>Option</code>. type <code>SNAPSHOT</code> (full overwrite) or <code>DELTA</code> (incremental change). bids / asks Depth updates stored in PMR vectors (<code>BookLevel</code>). timestamp Local receive time, used for sequencing and latency metrics. strike Strike price \u2014 only for option updates. expiry Expiry date/time \u2014 only for option updates. optionType <code>Call</code> or <code>Put</code> \u2014 only for option updates."},{"location":"components/book/book_update/#notes","title":"Notes","text":"<ul> <li>When <code>type == SNAPSHOT</code>, consumers must fully replace their local book for <code>symbol</code>.  </li> <li><code>bids</code> and <code>asks</code> are typically reserved to capacity in an object pool, avoiding runtime allocations.  </li> <li>Downstream filters can quickly ignore instruments by checking <code>instrument</code> without a <code>SymbolRegistry</code> lookup.  </li> <li>Option fields are optional: they are populated only when <code>instrument == InstrumentType::Option</code>.</li> </ul>"},{"location":"components/book/candle/","title":"Candle","text":"<p><code>Candle</code> represents a single OHLCV time-bar aggregated from trades within a fixed interval.</p> <pre><code>struct Candle {\n  Price open;\n  Price high;\n  Price low;\n  Price close;\n  Volume volume;\n  TimePoint startTime;\n  TimePoint endTime;\n\n  Candle() = default;\n  Candle(TimePoint ts, Price price, Volume qty);\n};\n</code></pre>"},{"location":"components/book/candle/#purpose","title":"Purpose","text":"<ul> <li>Store the full market state (OHLCV) over a defined time window for downstream analytics or strategy input.</li> </ul>"},{"location":"components/book/candle/#responsibilities","title":"Responsibilities","text":"Field Description open Price of the first trade in the interval. high/low Highest and lowest traded price during the interval. close Price of the last trade in the interval. volume Total traded volume across all ticks in the window. startTime Timestamp of the first trade in the interval. endTime Timestamp of the last trade in the interval (may evolve)."},{"location":"components/book/candle/#notes","title":"Notes","text":"<ul> <li>Constructed with initial price/volume; high/low/close evolve with subsequent trades.</li> <li>Timestamps are <code>steady_clock</code>-based to support simulation and deterministic replay.</li> <li>Used exclusively by <code>CandleAggregator</code> and delivered via <code>CandleEvent</code>.</li> </ul>"},{"location":"components/book/nlevel_order_book/","title":"NLevelOrderBook","text":"<p><code>NLevelOrderBook</code> is a high-performance, fixed-depth limit order book optimized for HFT and simulation. It uses tick-based indexing for fast access and zero allocations in the hot path.</p> <pre><code>template &lt;size_t MaxLevels = 8192&gt;\nclass NLevelOrderBook : public IOrderBook {\n  // ...\n};\n</code></pre>"},{"location":"components/book/nlevel_order_book/#purpose","title":"Purpose","text":"<ul> <li>Maintain and query an efficient in-memory representation of top-of-book and full depth using indexed price levels.</li> </ul>"},{"location":"components/book/nlevel_order_book/#responsibilities","title":"Responsibilities","text":"Aspect Details Input Consumes <code>BookUpdateEvent</code> messages, supports both <code>SNAPSHOT</code> and <code>DELTA</code>. Resolution Tick-based price quantization via <code>_tickSize</code>. Depth Query Provides <code>bestBid</code>, <code>bestAsk</code>, and <code>Quantity</code> at arbitrary price levels. Storage Preallocated arrays for bids and asks indexed by tick-level offset."},{"location":"components/book/nlevel_order_book/#internal-behavior","title":"Internal Behavior","text":"<ol> <li> <p>Price Indexing    Prices are mapped to array indices using <code>price / tickSize</code>, enabling constant-time access.</p> </li> <li> <p>Snapshot Handling    A <code>SNAPSHOT</code> clears all state and resets index bounds before applying levels.</p> </li> <li> <p>Bounds Tracking    Maintains <code>_minBidIndex</code>, <code>_maxBidIndex</code>, <code>_minAskIndex</code>, <code>_maxAskIndex</code> for efficient best-level scans.</p> </li> <li> <p>Best Bid/Ask Scan    Performs linear scans within index bounds to locate top of book \u2014 fast due to tight range.</p> </li> <li> <p>No Dynamic Allocation    Uses <code>std::array</code> of fixed size; fully cache-friendly and allocation-free after construction.</p> </li> </ol>"},{"location":"components/book/nlevel_order_book/#notes","title":"Notes","text":"<ul> <li>Extremely fast and deterministic \u2014 suitable for backtests and production.</li> <li>Requires external enforcement of tick-aligned prices.</li> <li>Offers predictable latency across workloads, assuming sparse updates.</li> </ul>"},{"location":"components/book/trade/","title":"Trade","text":"<p><code>Trade</code> represents a single executed transaction between a buyer and seller on a specific instrument, including price, quantity, taker side, and instrument class.</p> <pre><code>struct Trade {\n    SymbolId       symbol{};                             // instrument identifier\n    InstrumentType instrument = InstrumentType::Spot;    // Spot | Future | Option\n    Price          price{};                              // execution price\n    Quantity       quantity{};                           // size in base units\n    bool           isBuy{false};                         // taker side (true = buy)\n    TimePoint      timestamp{};                          // execution time\n};\n</code></pre>"},{"location":"components/book/trade/#purpose","title":"Purpose","text":"<ul> <li>Convey executed market activity in a normalized, low-allocation format for downstream components.</li> </ul>"},{"location":"components/book/trade/#responsibilities","title":"Responsibilities","text":"Field Description symbol Unique <code>SymbolId</code> of the traded instrument. instrument Instrument class: <code>Spot</code>, <code>Future</code>, or <code>Option</code>. price Execution price. quantity Executed size (base units). isBuy <code>true</code> if the taker was the buyer; <code>false</code> if the taker was the seller. timestamp Event or wall-clock time of execution (<code>steady_clock</code> basis)."},{"location":"components/book/trade/#notes","title":"Notes","text":"<ul> <li>Emitted via <code>TradeEvent</code> through <code>TradeBus</code>.</li> <li>Serves as input for candle aggregation, PnL tracking, flow analysis, and latency metrics.</li> <li><code>instrument</code> allows immediate filtering without a registry lookup in hot paths.</li> </ul>"},{"location":"components/book/bus/book_update_bus/","title":"BookUpdateBus","text":"<p><code>BookUpdateBus</code> is a fan-out event channel for <code>BookUpdateEvent</code> messages, wrapped in pooled <code>Handle</code>s for zero-allocation delivery across components such as order books, strategies, and analytics.</p> <pre><code>#ifdef FLOX_USE_SYNC_BOOK_UPDATE_BUS\nusing BookUpdateBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;, SyncPolicy&lt;...&gt;&gt;;\n#else\nusing BookUpdateBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;, AsyncPolicy&lt;...&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/book/bus/book_update_bus/#purpose","title":"Purpose","text":"<ul> <li>Efficiently distribute <code>BookUpdateEvent</code>s to multiple subscribers with zero allocations in the hot path.</li> </ul>"},{"location":"components/book/bus/book_update_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload Uses <code>pool::Handle&lt;BookUpdateEvent&gt;</code> for memory reuse and ref-counting. Mode <code>SyncPolicy</code> or <code>AsyncPolicy</code>, toggled by <code>FLOX_USE_SYNC_BOOK_UPDATE_BUS</code>. Target Consumed by order book processors, strategies, and market monitors."},{"location":"components/book/bus/book_update_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> enforces barrier-based delivery (e.g., for simulation or determinism).</li> <li><code>AsyncPolicy</code> supports lock-free fan-out under production latency constraints.</li> <li>Pooling ensures <code>BookUpdateEvent</code>s are reused without dynamic heap allocations.</li> <li>Designed for high-frequency message flow in HFT environments.</li> </ul>"},{"location":"components/book/bus/trade_bus/","title":"TradeBus","text":"<p><code>TradeBus</code> is a high-throughput delivery channel for <code>TradeEvent</code> messages, used to broadcast trade prints across system components such as aggregators, strategies, and analytics modules.</p> <pre><code>#ifdef FLOX_USE_SYNC_TRADE_BUS\nusing TradeBus = EventBus&lt;TradeEvent, SyncPolicy&lt;TradeEvent&gt;&gt;;\n#else\nusing TradeBus = EventBus&lt;TradeEvent, AsyncPolicy&lt;TradeEvent&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/book/bus/trade_bus/#purpose","title":"Purpose","text":"<ul> <li>Propagate real-time <code>TradeEvent</code>s to all registered consumers in the system.</li> </ul>"},{"location":"components/book/bus/trade_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload Direct delivery of <code>TradeEvent</code> instances (no wrapping or pooling). Mode Chooses between <code>SyncPolicy</code> and <code>AsyncPolicy</code> via compile-time macro. Usage Used by connectors, aggregators (e.g., <code>CandleAggregator</code>), and strategies."},{"location":"components/book/bus/trade_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> guarantees deterministic tick-to-tick replay for simulation/backtesting.</li> <li><code>AsyncPolicy</code> offers lock-free fan-out for live environments with minimal latency.</li> <li>Stateless; the bus itself performs no buffering or transformation.</li> </ul>"},{"location":"components/book/events/book_update_event/","title":"BookUpdateEvent","text":"<p><code>BookUpdateEvent</code> represents a snapshot or delta update to the order book, encapsulated in a pooled, memory-resource-aware structure for zero-allocation fan-out.</p> <pre><code>struct BookUpdateEvent : public pool::PoolableBase&lt;BookUpdateEvent&gt; {\n  using Listener = IMarketDataSubscriber;\n\n  BookUpdate update;\n  uint64_t tickSequence = 0;\n\n  BookUpdateEvent(std::pmr::memory_resource* res);\n  void clear();\n};\n</code></pre>"},{"location":"components/book/events/book_update_event/#purpose","title":"Purpose","text":"<ul> <li>Deliver normalized order book changes with minimal latency and no heap allocations.</li> </ul>"},{"location":"components/book/events/book_update_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Memory Constructed with <code>std::pmr::memory_resource</code> for scoped allocation. Pooling Inherits from <code>PoolableBase</code> for reuse via <code>pool::Handle&lt;T&gt;</code>. Payload Holds a <code>BookUpdate</code> with bid/ask vectors allocated from the PMR. Sequencing <code>tickSequence</code> ensures ordered processing across consumers. Subscription Declares <code>IMarketDataSubscriber</code> as the receiver interface."},{"location":"components/book/events/book_update_event/#notes","title":"Notes","text":"<ul> <li><code>clear()</code> resets bid/ask containers in-place without releasing memory.</li> <li>Intended for high-frequency delivery over <code>BookUpdateBus</code>.</li> <li>Construction asserts non-null memory resource to enforce deterministic allocation control.</li> <li>Immutable after dispatch; reused through pooled lifecycle.</li> </ul>"},{"location":"components/book/events/trade_event/","title":"TradeEvent","text":"<p><code>TradeEvent</code> represents a single trade tick \u2014 a filled transaction between counterparties \u2014 and is broadcast across the system for aggregation, analytics, and strategy input.</p> <pre><code>struct TradeEvent {\n  using Listener = IMarketDataSubscriber;\n\n  Trade trade{};\n  uint64_t tickSequence = 0;\n};\n</code></pre>"},{"location":"components/book/events/trade_event/#purpose","title":"Purpose","text":"<ul> <li>Encapsulate trade prints received from exchanges for delivery via <code>TradeBus</code>.</li> </ul>"},{"location":"components/book/events/trade_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload <code>trade</code> holds symbol, price, quantity, timestamp, and taker direction. Sequencing <code>tickSequence</code> guarantees strict event order for replay and backtests. Subscription Targets <code>IMarketDataSubscriber</code> interface for generic event delivery."},{"location":"components/book/events/trade_event/#notes","title":"Notes","text":"<ul> <li>Used by <code>CandleAggregator</code>, PnL trackers, and all signal generation components.</li> <li>Designed for ultra-low-latency delivery; no heap allocation involved.</li> <li>Stateless container \u2014 no logic beyond encapsulation.</li> </ul>"},{"location":"components/connector/connector_factory/","title":"ConnectorFactory","text":"<p><code>ConnectorFactory</code> is a global registry and dynamic constructor for <code>ExchangeConnector</code> instances, used to instantiate exchange adapters based on type and symbol at runtime.</p> <pre><code>class ConnectorFactory {\npublic:\n  using CreatorFunc = std::move_only_function&lt;std::shared_ptr&lt;ExchangeConnector&gt;(const std::string&amp;)&gt;;\n\n  static ConnectorFactory&amp; instance();\n  void registerConnector(const std::string&amp; type, CreatorFunc creator);\n  std::shared_ptr&lt;ExchangeConnector&gt; createConnector(const std::string&amp; type, const std::string&amp; symbol);\n\nprivate:\n  std::unordered_map&lt;std::string, CreatorFunc&gt; _creators;\n};\n</code></pre>"},{"location":"components/connector/connector_factory/#purpose","title":"Purpose","text":"<ul> <li>Enable pluggable, type-based instantiation of exchange connectors without static bindings.</li> </ul>"},{"location":"components/connector/connector_factory/#responsibilities","title":"Responsibilities","text":"Aspect Details Registration Maps string identifiers (e.g. <code>\"bybit\"</code>, <code>\"mock\"</code>) to creator functions. Construction Calls registered factory to produce a connector for a given <code>symbol</code>. Lifetime Singleton pattern via <code>instance()</code>; all connectors share same registry."},{"location":"components/connector/connector_factory/#notes","title":"Notes","text":"<ul> <li>Uses <code>std::move_only_function</code> to avoid overhead of <code>std::function</code> and enable capture of ownership semantics.</li> <li>Supports dynamic module systems or runtime configuration of connector types.</li> <li>Not thread-safe by default \u2014 external synchronization may be required during registration.</li> </ul>"},{"location":"components/connector/connector_manager/","title":"ConnectorManager","text":"<p><code>ConnectorManager</code> coordinates lifecycle and callback wiring for multiple <code>ExchangeConnector</code> instances, managing startup and routing of market data events.</p> <pre><code>class ConnectorManager {\npublic:\n  void registerConnector(std::shared_ptr&lt;ExchangeConnector&gt; connector);\n  void startAll(ExchangeConnector::BookUpdateCallback onBookUpdate,\n                ExchangeConnector::TradeCallback onTrade);\n\nprivate:\n  std::map&lt;std::string, std::shared_ptr&lt;ExchangeConnector&gt;&gt; connectors;\n};\n</code></pre>"},{"location":"components/connector/connector_manager/#purpose","title":"Purpose","text":"<ul> <li>Aggregate multiple exchange connectors and manage their startup and event forwarding.</li> </ul>"},{"location":"components/connector/connector_manager/#responsibilities","title":"Responsibilities","text":"Aspect Details Registration Stores connectors indexed by their <code>exchangeId()</code> value. Startup Calls <code>start()</code> on all registered connectors. Callbacks Wires trade and book update callbacks to each connector during startup. Output Logs startup of each connector to <code>stdout</code>."},{"location":"components/connector/connector_manager/#notes","title":"Notes","text":"<ul> <li>Assumes connectors are ready to start at the time of <code>startAll()</code> \u2014 no deferred registration.</li> <li>Wraps callbacks using lambdas to allow mutation and move-only semantics.</li> <li>Primarily intended for system bootstrap and orchestration; not used in performance-critical paths.</li> <li>Callback dispatch remains connector-local; manager only wires them once.</li> </ul>"},{"location":"components/connector/exchange_connector/","title":"ExchangeConnector","text":"<p><code>ExchangeConnector</code> is the abstract interface for real-time market data adapters. It provides lifecycle control and typed callback delivery for <code>BookUpdateEvent</code> and <code>TradeEvent</code>.</p> <pre><code>class ExchangeConnector {\npublic:\n  using BookUpdateCallback = std::move_only_function&lt;void(const BookUpdateEvent&amp;)&gt;;\n  using TradeCallback      = std::move_only_function&lt;void(const TradeEvent&amp;)&gt;;\n\n  virtual ~ExchangeConnector() = default;\n\n  virtual void start() = 0;\n  virtual void stop() = 0;\n\n  virtual std::string exchangeId() const = 0;\n\n  virtual void setCallbacks(BookUpdateCallback onBookUpdate, TradeCallback onTrade);\n\nprotected:\n  void emitBookUpdate(const BookUpdateEvent&amp; bu);\n  void emitTrade(const TradeEvent&amp; t);\n};\n</code></pre>"},{"location":"components/connector/exchange_connector/#purpose","title":"Purpose","text":"<ul> <li>Abstract base for all exchange-specific connectors (e.g. Bybit, Mock, Replay), handling event emission and lifecycle.</li> </ul>"},{"location":"components/connector/exchange_connector/#responsibilities","title":"Responsibilities","text":"Aspect Details Lifecycle <code>start()</code> and <code>stop()</code> control external connectivity and data flow. Identity <code>exchangeId()</code> provides a stable identifier for the connector instance. Callbacks <code>setCallbacks()</code> binds downstream handlers for book and trade events. Event Routing <code>emitBookUpdate()</code> and <code>emitTrade()</code> dispatch data to subscribers."},{"location":"components/connector/exchange_connector/#notes","title":"Notes","text":"<ul> <li>Callbacks use <code>std::move_only_function</code> to avoid <code>std::function</code> overhead and enable capturing closures with ownership.</li> <li>Implementations must call <code>emit*()</code> manually from internal processing (e.g. websocket handler).</li> <li>The class is intentionally non-copyable and non-thread-safe \u2014 connectors are expected to run in isolated threads.</li> </ul>"},{"location":"components/engine/abstract_market_data_subscriber/","title":"IMarketDataSubscriber","text":"<p><code>IMarketDataSubscriber</code> is a unified interface for components that consume real-time market data events. It supports optional handling of order book updates, trades, and candles.</p> <pre><code>class IMarketDataSubscriber : public ISubscriber {\npublic:\n  virtual ~IMarketDataSubscriber() = default;\n\n  virtual void onBookUpdate(const BookUpdateEvent&amp; ev) {}\n  virtual void onTrade(const TradeEvent&amp; ev) {}\n  virtual void onCandle(const CandleEvent&amp; ev) {}\n};\n</code></pre>"},{"location":"components/engine/abstract_market_data_subscriber/#purpose","title":"Purpose","text":"<ul> <li>Serve as a polymorphic listener for all market-facing event types across the system.</li> </ul>"},{"location":"components/engine/abstract_market_data_subscriber/#responsibilities","title":"Responsibilities","text":"Method Description onBookUpdate Receives <code>BookUpdateEvent</code> from <code>BookUpdateBus</code>. onTrade Receives <code>TradeEvent</code> from <code>TradeBus</code>. onCandle Receives <code>CandleEvent</code> from <code>CandleBus</code>."},{"location":"components/engine/abstract_market_data_subscriber/#notes","title":"Notes","text":"<ul> <li>Default implementations are no-ops \u2014 subscribers override only what they care about.</li> <li>Always used in conjunction with <code>EventBus&lt;T&gt;</code> and its <code>Policy</code> (sync or async).</li> <li>Inherits from <code>ISubscriber</code>, which provides <code>id()</code> and <code>mode()</code> for routing.</li> </ul>"},{"location":"components/engine/abstract_subscriber/","title":"ISubscriber","text":"<p><code>ISubscriber</code> defines the minimal interface for any component that consumes events via <code>EventBus</code>. It provides a stable identity and declares the delivery mode (push or pull).</p> <pre><code>struct ISubscriber {\n  virtual SubscriberId id() const = 0;\n  virtual SubscriberMode mode() const { return SubscriberMode::PUSH; }\n};\n\nusing SubscriberId = uint64_t;\nenum class SubscriberMode {\n  PUSH,\n  PULL\n};\n</code></pre>"},{"location":"components/engine/abstract_subscriber/#purpose","title":"Purpose","text":"<ul> <li>Abstract base for all event consumers, enabling uniform routing and delivery control.</li> </ul>"},{"location":"components/engine/abstract_subscriber/#responsibilities","title":"Responsibilities","text":"Method Description id() Returns a globally unique ID for this subscriber. mode() Declares delivery mode: <code>PUSH</code> (default) or <code>PULL</code> (manual drain)."},{"location":"components/engine/abstract_subscriber/#notes","title":"Notes","text":"<ul> <li><code>PUSH</code> mode: the bus invokes the subscriber immediately on event dispatch.</li> <li><code>PULL</code> mode: the subscriber drains from a queue explicitly (e.g., with batching).</li> <li><code>SubscriberId</code> is typically derived from pointer identity or hash \u2014 no strong ownership implied.</li> <li>Used by <code>EventBus&lt;T&gt;</code> to track subscribers and apply fan-out policy.</li> </ul>"},{"location":"components/engine/abstract_subsystem/","title":"ISubsystem","text":"<p><code>ISubsystem</code> defines a lifecycle interface for engine components that require explicit startup and shutdown phases.</p> <pre><code>class ISubsystem {\npublic:\n  virtual ~ISubsystem() = default;\n\n  virtual void start() = 0;\n  virtual void stop() = 0;\n};\n</code></pre>"},{"location":"components/engine/abstract_subsystem/#purpose","title":"Purpose","text":"<ul> <li>Provide deterministic initialization and teardown hooks for stateful modules in the system.</li> </ul>"},{"location":"components/engine/abstract_subsystem/#responsibilities","title":"Responsibilities","text":"Method Description start Called during engine bootstrapping. stop Called during shutdown or reset."},{"location":"components/engine/abstract_subsystem/#notes","title":"Notes","text":"<ul> <li>Used by core modules like <code>CandleAggregator</code>, <code>Strategy</code>, <code>ExecutionTracker</code>, etc.</li> <li>Lifecycle is typically orchestrated by the engine or test harness.</li> <li>No assumptions about threading \u2014 start/stop are always externally coordinated.</li> </ul>"},{"location":"components/engine/engine/","title":"Engine","text":"<p><code>Engine</code> coordinates the startup and shutdown of the entire trading system. It owns the engine configuration, all exchange connectors, and system subsystems.</p> <pre><code>class Engine : public ISubsystem {\npublic:\n  Engine(const EngineConfig&amp; config,\n         std::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems,\n         std::vector&lt;std::shared_ptr&lt;ExchangeConnector&gt;&gt; connectors);\n\n  void start() override;\n  void stop() override;\n};\n</code></pre>"},{"location":"components/engine/engine/#purpose","title":"Purpose","text":"<ul> <li>Central orchestration unit responsible for lifecycle management of all core components.</li> </ul>"},{"location":"components/engine/engine/#responsibilities","title":"Responsibilities","text":"Aspect Description Configuration Stores full <code>EngineConfig</code> used by subsystems and connectors. Subsystems Owns and manages startup/teardown of all registered <code>ISubsystem</code>s. Connectors Retains exchange adapters to prevent premature destruction."},{"location":"components/engine/engine/#exchangeinstance","title":"ExchangeInstance","text":"<pre><code>struct ExchangeInstance {\n  std::string exchangeType;\n  std::string name;\n  std::string symbol;\n  std::shared_ptr&lt;ExchangeConnector&gt; connector;\n};\n</code></pre> Field Description exchangeType Registered type used in factory resolution. name User-defined alias for logging or mapping. symbol Symbol string for routing or filtering. connector Pointer to live exchange connection."},{"location":"components/engine/engine/#notes","title":"Notes","text":"<ul> <li><code>start()</code>/<code>stop()</code> invoke lifecycle methods on all subsystems in the order defined.</li> <li>All subsystems are owned via <code>unique_ptr</code>; destruction is deterministic and ordered.</li> <li>Designed to decouple bootstrapping logic from component logic \u2014 the <code>Engine</code> is not involved in runtime signal or data flow.</li> </ul>"},{"location":"components/engine/engine_config/","title":"EngineConfig","text":"<p><code>EngineConfig</code> holds top-level runtime configuration for the trading engine, including exchange definitions, kill switch limits, and logging preferences.</p> <pre><code>struct EngineConfig {\n  std::vector&lt;ExchangeConfig&gt; exchanges;\n  KillSwitchConfig killSwitchConfig;\n  std::string logLevel = \"info\";\n  std::string logFile;\n};\n</code></pre>"},{"location":"components/engine/engine_config/#purpose","title":"Purpose","text":"<ul> <li>Aggregate all user-specified engine parameters into a single loadable structure.</li> </ul>"},{"location":"components/engine/engine_config/#responsibilities","title":"Responsibilities","text":"Field Description exchanges List of exchanges and symbols to connect (via <code>ExchangeConfig</code>). killSwitchConfig Limits for order size, frequency, and loss (see <code>KillSwitchConfig</code>). logLevel Runtime log verbosity (<code>info</code>, <code>debug</code>, <code>trace</code>, etc.). logFile Optional path to write logs to disk."},{"location":"components/engine/engine_config/#substructures","title":"Substructures","text":""},{"location":"components/engine/engine_config/#exchangeconfig","title":"<code>ExchangeConfig</code>","text":"Field Description name Display name or label (e.g. <code>\"Bybit\"</code>). type Connector type (used by <code>ConnectorFactory</code>). symbols List of <code>SymbolConfig</code> entries."},{"location":"components/engine/engine_config/#symbolconfig","title":"<code>SymbolConfig</code>","text":"Field Description symbol Symbol name (e.g. <code>\"DOTUSDT\"</code>). tickSize Price resolution used by the order book. expectedDeviation Max allowed distance from center price."},{"location":"components/engine/engine_config/#killswitchconfig","title":"<code>KillSwitchConfig</code>","text":"Field Description maxOrderQty Per-order size limit. maxLoss Hard loss cap per session. maxOrdersPerSecond Throttling limit for message rate (\u2264 0 = disabled)."},{"location":"components/engine/engine_config/#notes","title":"Notes","text":"<ul> <li>Typically loaded from JSON during engine bootstrap.</li> <li>Used by multiple components: symbol registry, kill switch, connector setup, and logging.</li> </ul>"},{"location":"components/engine/event_dispatcher/","title":"EventDispatcher","text":"<p><code>EventDispatcher&lt;T&gt;</code> provides a compile-time dispatch mechanism that routes events to the appropriate subscriber method without relying on virtual functions or dynamic casting.</p> <pre><code>template &lt;typename T&gt;\nstruct EventDispatcher;\n\ntemplate &lt;typename T&gt;\nstruct EventDispatcher&lt;pool::Handle&lt;T&gt;&gt; {\n  static void dispatch(const pool::Handle&lt;T&gt;&amp; ev, typename T::Listener&amp; sub);\n};\n\n// Specializations for each event type...\n</code></pre>"},{"location":"components/engine/event_dispatcher/#purpose","title":"Purpose","text":"<ul> <li>Deliver strongly-typed events (<code>BookUpdateEvent</code>, <code>TradeEvent</code>, etc.) to their matching handler methods on subscribers, using static dispatch.</li> </ul>"},{"location":"components/engine/event_dispatcher/#responsibilities","title":"Responsibilities","text":"Specialization Routed To <code>BookUpdateEvent</code> <code>IMarketDataSubscriber::onBookUpdate()</code> <code>TradeEvent</code> <code>IMarketDataSubscriber::onTrade()</code> <code>CandleEvent</code> <code>IMarketDataSubscriber::onCandle()</code> <code>OrderEvent</code> <code>IOrderExecutionListener::onOrderFilled()</code> via <code>dispatchTo()</code> <code>pool::Handle&lt;T&gt;</code> Unwraps and forwards to <code>EventDispatcher&lt;T&gt;</code>"},{"location":"components/engine/event_dispatcher/#notes","title":"Notes","text":"<ul> <li>Eliminates virtual overhead in <code>EventBus</code> by avoiding <code>event-&gt;dispatchTo()</code> directly.</li> <li>Pooled events (<code>pool::Handle&lt;T&gt;</code>) are transparently unwrapped and dispatched.</li> <li>Extensible \u2014 any new event type must define a matching specialization.</li> <li>Dispatch is strictly type-safe and resolved at compile time.</li> </ul>"},{"location":"components/engine/symbol_registry/","title":"SymbolRegistry","text":"<p><code>SymbolRegistry</code> assigns and resolves stable <code>SymbolId</code> values for instruments and exposes full metadata (<code>SymbolInfo</code>) for fast, type-safe access across the engine.</p> <pre><code>struct SymbolInfo {\n    SymbolId           id{};\n    std::string        exchange;          // e.g. \"bybit\"\n    std::string        symbol;            // e.g. \"BTCUSDT\" or \"BTC-30AUG24-50000-C\"\n    InstrumentType     type = InstrumentType::Spot;\n\n    std::optional&lt;Price&gt;      strike;     // options only\n    std::optional&lt;TimePoint&gt;  expiry;     // options only\n    std::optional&lt;OptionType&gt; optionType; // Call | Put (options only)\n};\n\nclass SymbolRegistry {\npublic:\n    // Register by plain (exchange, symbol) \u2013 defaults to Spot\n    SymbolId registerSymbol(const std::string&amp; exchange,\n                            const std::string&amp; symbol);\n\n    // Register with full metadata\n    SymbolId registerSymbol(const SymbolInfo&amp; info);\n\n    // Forward lookup\n    std::optional&lt;SymbolId&gt; getSymbolId(const std::string&amp; exchange,\n                                        const std::string&amp; symbol) const;\n\n    // Reverse lookup (exchange, symbol)\n    std::pair&lt;std::string, std::string&gt; getSymbolName(SymbolId id) const;\n\n    // Full metadata lookup\n    const SymbolInfo* getSymbolInfo(SymbolId id) const;\n\nprivate:\n    mutable std::mutex                 _mutex;\n    std::vector&lt;SymbolInfo&gt;            _symbols;  // id-indexed (1-based)\n    std::unordered_map&lt;std::string,\n                       SymbolId&gt;       _map;      // \"exchange:symbol\" \u2192 id\n    std::vector&lt;std::pair&lt;std::string,\n                          std::string&gt;&gt; _reverse;  // id \u2192 (exchange,symbol)\n};\n</code></pre>"},{"location":"components/engine/symbol_registry/#purpose","title":"Purpose","text":"<ul> <li>Provide a thread-safe, bidirectional mapping between human-readable instrument keys and compact numeric <code>SymbolId</code>s.</li> <li>Expose complete instrument metadata (<code>SymbolInfo</code>) for latency-critical components without repeated parsing.</li> </ul>"},{"location":"components/engine/symbol_registry/#responsibilities","title":"Responsibilities","text":"Method Description <code>registerSymbol(str)</code> Registers a spot instrument, returns existing <code>id</code> if present. <code>registerSymbol(info)</code> Registers any instrument type with full metadata. <code>getSymbolId</code> Forward lookup from <code>(exchange, symbol)</code> to <code>SymbolId</code>. <code>getSymbolName</code> Reverse lookup from <code>SymbolId</code> to <code>(exchange, symbol)</code> string pair. <code>getSymbolInfo</code> Retrieves immutable pointer to stored <code>SymbolInfo</code> for fast access."},{"location":"components/engine/symbol_registry/#internal-design","title":"Internal Design","text":"<ul> <li>Composite key <code>\"exchange:symbol\"</code> ensures O(1) forward lookups via <code>_map</code>.</li> <li><code>_symbols</code> is a dense 1-based vector for direct <code>id</code> indexing (<code>id = index + 1</code>).</li> <li><code>_reverse</code> provides constant-time reverse mapping without string reconstruction.</li> <li>A single mutex protects all structures; registration is rare, lookups are frequent and lock-free reads dominate.</li> </ul>"},{"location":"components/engine/symbol_registry/#notes","title":"Notes","text":"<ul> <li><code>InstrumentType</code> allows immediate filtering (<code>Spot</code>, <code>Future</code>, <code>Option</code>) without extra registry calls in hot paths.</li> <li><code>SymbolId</code> remains a compact, contiguous 32-bit value suitable for array indices in event buses and order books.</li> <li>Option-specific fields (<code>strike</code>, <code>expiry</code>, <code>optionType</code>) are populated only when <code>type == InstrumentType::Option</code>.</li> </ul>"},{"location":"components/engine/tick_barrier/","title":"TickBarrier","text":"<p><code>TickBarrier</code> is a lightweight synchronization primitive used to coordinate a fixed number of consumers during synchronous tick processing. It enables deterministic progression to the next event only after all subscribers have completed processing.</p> <pre><code>class TickBarrier {\npublic:\n  explicit TickBarrier(size_t total);\n\n  void complete();\n  void wait();\n\nprivate:\n  const size_t _total;\n  std::atomic&lt;size_t&gt; _completed;\n};\n</code></pre>"},{"location":"components/engine/tick_barrier/#purpose","title":"Purpose","text":"<ul> <li>Synchronize fan-out consumers in <code>SyncPolicy</code> to ensure all subscribers complete before the next tick is published.</li> </ul>"},{"location":"components/engine/tick_barrier/#responsibilities","title":"Responsibilities","text":"Method Description complete Called by each subscriber when it finishes processing a tick. wait Blocks until all expected completions have been received."},{"location":"components/engine/tick_barrier/#notes","title":"Notes","text":"<ul> <li>Spin-waiting via <code>std::this_thread::yield()</code> \u2014 no locks, no condition variables.</li> <li>Suitable only for short-lived, low-latency operations (e.g., simulation/batch replay).</li> <li>Initialized with <code>total</code> \u2014 the number of expected <code>complete()</code> calls per tick.</li> <li>Not reusable \u2014 one barrier per tick. Resetting requires re-instantiation.</li> </ul>"},{"location":"components/engine/tick_guard/","title":"TickGuard","text":"<p><code>TickGuard</code> is a RAII helper that automatically signals completion to a <code>TickBarrier</code> when it goes out of scope. It ensures deterministic tick completion even in the presence of early returns or exceptions.</p> <pre><code>class TickGuard {\npublic:\n  explicit TickGuard(TickBarrier&amp; barrier);\n  ~TickGuard();\n\n  TickGuard(const TickGuard&amp;) = delete;\n  TickGuard&amp; operator=(const TickGuard&amp;) = delete;\n\nprivate:\n  TickBarrier* _barrier;\n};\n</code></pre>"},{"location":"components/engine/tick_guard/#purpose","title":"Purpose","text":"<ul> <li>Guarantee that <code>TickBarrier::complete()</code> is called once per subscriber at the end of a tick, regardless of control flow.</li> </ul>"},{"location":"components/engine/tick_guard/#responsibilities","title":"Responsibilities","text":"Behavior Description Construction Stores reference to <code>TickBarrier</code>. Destruction Calls <code>complete()</code> when the guard is destroyed. Copy/Move Explicitly non-copyable and non-movable."},{"location":"components/engine/tick_guard/#notes","title":"Notes","text":"<ul> <li>Should be declared at the top of the subscriber's <code>onEvent()</code> method in <code>SyncPolicy</code>.</li> <li>Ensures that even early returns or exceptions do not break barrier synchronization.</li> <li>No runtime cost beyond pointer storage and destructor call.</li> </ul>"},{"location":"components/execution/abstract_execution_listener/","title":"IOrderExecutionListener","text":"<p><code>IOrderExecutionListener</code> defines the interface for components that react to order lifecycle events. It is used by <code>OrderExecutionBus</code> to notify subscribers of changes in order state.</p> <pre><code>class IOrderExecutionListener : public ISubscriber {\npublic:\n  explicit IOrderExecutionListener(SubscriberId id);\n  virtual ~IOrderExecutionListener() = default;\n\n  SubscriberId id() const override;\n\n  virtual void onOrderSubmitted(const Order&amp; order) = 0;\n  virtual void onOrderAccepted(const Order&amp; order) = 0;\n  virtual void onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty) = 0;\n  virtual void onOrderFilled(const Order&amp; order) = 0;\n  virtual void onOrderCanceled(const Order&amp; order) = 0;\n  virtual void onOrderExpired(const Order&amp; order) = 0;\n  virtual void onOrderRejected(const Order&amp; order, const std::string&amp; reason) = 0;\n  virtual void onOrderReplaced(const Order&amp; oldOrder, const Order&amp; newOrder) = 0;\n};\n</code></pre>"},{"location":"components/execution/abstract_execution_listener/#purpose","title":"Purpose","text":"<ul> <li>Provide a type-safe listener interface for receiving detailed updates on order status transitions.</li> </ul>"},{"location":"components/execution/abstract_execution_listener/#responsibilities","title":"Responsibilities","text":"Method Triggered On <code>onOrderSubmitted</code> Order submitted to venue or simulator. <code>onOrderAccepted</code> Order acknowledged/accepted by the exchange. <code>onOrderPartiallyFilled</code> Partial fill received; includes fill quantity. <code>onOrderFilled</code> Fully filled. <code>onOrderCanceled</code> Canceled by user or system. <code>onOrderExpired</code> Expired due to time-in-force or system conditions. <code>onOrderRejected</code> Rejected by exchange or risk engine (with reason). <code>onOrderReplaced</code> Order was replaced with a new one."},{"location":"components/execution/abstract_execution_listener/#notes","title":"Notes","text":"<ul> <li>Each listener is identified via a stable <code>SubscriberId</code>.</li> <li>Used in tandem with <code>OrderEvent::dispatchTo()</code> to decouple producers from listeners.</li> <li>Implemented by components such as <code>PositionManager</code>, <code>ExecutionTracker</code>, and metrics/reporting modules.</li> </ul>"},{"location":"components/execution/abstract_executor/","title":"IOrderExecutor","text":"<p><code>IOrderExecutor</code> defines the interface for components responsible for submitting, canceling, and replacing orders. It acts as the execution gateway in both simulated and live environments.</p> <pre><code>class IOrderExecutor : public ISubsystem {\npublic:\n  virtual ~IOrderExecutor() = default;\n\n  virtual void submitOrder(const Order&amp; order) {};\n  virtual void cancelOrder(OrderId orderId) {};\n  virtual void replaceOrder(OrderId oldOrderId, const Order&amp; newOrder) {};\n};\n</code></pre>"},{"location":"components/execution/abstract_executor/#purpose","title":"Purpose","text":"<ul> <li>Abstract execution interface used by strategies and internal components to place and manage orders.</li> </ul>"},{"location":"components/execution/abstract_executor/#responsibilities","title":"Responsibilities","text":"Method Description <code>submitOrder</code> Sends a new order to the execution venue or simulator. <code>cancelOrder</code> Cancels a previously submitted order. <code>replaceOrder</code> Replaces an existing order with new parameters."},{"location":"components/execution/abstract_executor/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code>, enabling lifecycle coordination via <code>start()</code> and <code>stop()</code>.</li> <li>Can be backed by mocks, simulators, or real exchange adapters.</li> <li>Actual routing and fill simulation logic resides in concrete subclasses.</li> </ul>"},{"location":"components/execution/execution_tracker_adapter/","title":"ExecutionTrackerAdapter","text":"<p><code>ExecutionTrackerAdapter</code> is a proxy that forwards order execution events to an <code>IExecutionTracker</code>, timestamping each transition with <code>steady_clock::now()</code>.</p> <pre><code>class ExecutionTrackerAdapter : public IOrderExecutionListener {\npublic:\n  ExecutionTrackerAdapter(SubscriberId id, IExecutionTracker* tracker);\n  // All IOrderExecutionListener methods overridden\nprivate:\n  IExecutionTracker* _tracker;\n};\n</code></pre>"},{"location":"components/execution/execution_tracker_adapter/#purpose","title":"Purpose","text":"<ul> <li>Decouple execution tracking logic from the event delivery mechanism by timestamping and delegating events to a metrics recorder.</li> </ul>"},{"location":"components/execution/execution_tracker_adapter/#responsibilities","title":"Responsibilities","text":"Method Delegated To <code>onOrderSubmitted</code> <code>_tracker-&gt;onOrderSubmitted(..., now)</code> <code>onOrderAccepted</code> <code>_tracker-&gt;onOrderAccepted(..., now)</code> <code>onOrderPartiallyFilled</code> <code>_tracker-&gt;onOrderPartiallyFilled(..., now)</code> <code>onOrderFilled</code> <code>_tracker-&gt;onOrderFilled(..., now)</code> <code>onOrderCanceled</code> <code>_tracker-&gt;onOrderCanceled(..., now)</code> <code>onOrderExpired</code> <code>_tracker-&gt;onOrderExpired(..., now)</code> <code>onOrderRejected</code> <code>_tracker-&gt;onOrderRejected(..., now)</code> <code>onOrderReplaced</code> <code>_tracker-&gt;onOrderReplaced(..., now)</code>"},{"location":"components/execution/execution_tracker_adapter/#notes","title":"Notes","text":"<ul> <li>Uses wall-clock <code>std::chrono::steady_clock::now()</code> to consistently timestamp all events.</li> <li>The adapter does not own the <code>IExecutionTracker</code>; it assumes external lifetime management.</li> <li>Enables clean separation of metrics collection from trading logic.</li> </ul>"},{"location":"components/execution/multi_execution_listener/","title":"MultiExecutionListener","text":"<p><code>MultiExecutionListener</code> fans out order lifecycle events to multiple <code>IOrderExecutionListener</code> targets. It acts as a multicast adapter for <code>OrderExecutionBus</code> subscribers.</p> <pre><code>class MultiExecutionListener : public IOrderExecutionListener {\npublic:\n  explicit MultiExecutionListener(SubscriberId id);\n  void addListener(IOrderExecutionListener* listener);\n\n  // All event methods delegate to added listeners\n};\n</code></pre>"},{"location":"components/execution/multi_execution_listener/#purpose","title":"Purpose","text":"<ul> <li>Aggregate multiple execution listeners into a single subscriber to avoid duplicating subscriptions to the <code>OrderExecutionBus</code>.</li> </ul>"},{"location":"components/execution/multi_execution_listener/#responsibilities","title":"Responsibilities","text":"Method Behavior <code>addListener()</code> Registers a new listener (if not already added). Event handlers Forwards all events to each registered listener."},{"location":"components/execution/multi_execution_listener/#notes","title":"Notes","text":"<ul> <li>Listeners are stored as raw pointers; ownership is not transferred.</li> <li>Prevents duplicate listeners using <code>std::ranges::find()</code>.</li> <li>Efficient for use cases like simultaneously tracking PnL, latency, and order audit logs.</li> </ul>"},{"location":"components/execution/order/","title":"Order","text":"<p><code>Order</code> encapsulates all information related to a client-side order, including identifiers, execution parameters, status, and timestamps.</p> <pre><code>struct Order {\n  OrderId id{};\n  Side side{};\n  Price price{};\n  Quantity quantity{};\n  OrderType type{};\n  SymbolId symbol{};\n\n  Quantity filledQuantity{0};\n\n  TimePoint createdAt{};\n  std::optional&lt;TimePoint&gt; exchangeTimestamp;\n  std::optional&lt;TimePoint&gt; lastUpdated;\n  std::optional&lt;TimePoint&gt; expiresAfter;\n};\n</code></pre>"},{"location":"components/execution/order/#purpose","title":"Purpose","text":"<ul> <li>Represent an order's full lifecycle \u2014 from submission to final state \u2014 including fill progress, exchange timestamps, and status.</li> </ul>"},{"location":"components/execution/order/#responsibilities","title":"Responsibilities","text":"Field Description id Globally unique order identifier. side Buy or sell. price Limit price; ignored for market orders. quantity Total order size in base units. type <code>LIMIT</code>, <code>MARKET</code>, or other engine-defined types. symbol Compact numeric symbol reference (<code>SymbolId</code>). filledQuantity Accumulated quantity filled so far. createdAt Local creation timestamp. exchangeTimestamp When the exchange acknowledged the order (if applicable). lastUpdated Timestamp of last known state transition. expiresAfter Optional expiry deadline (e.g. for IOC/GTC enforcement)."},{"location":"components/execution/order/#notes","title":"Notes","text":"<ul> <li>Used as the payload in <code>OrderEvent</code> messages.</li> <li>All timestamps are based on <code>steady_clock</code> for monotonic sequencing.</li> <li>Immutable once submitted; all updates produce new events and/or replacement orders.</li> </ul>"},{"location":"components/execution/bus/order_execution_bus/","title":"OrderExecutionBus","text":"<p><code>OrderExecutionBus</code> is the delivery channel for <code>OrderEvent</code> messages, used to notify downstream components (e.g. PnL trackers, position managers) about order lifecycle events.</p> <pre><code>#ifdef FLOX_USE_SYNC_ORDER_BUS\nusing OrderExecutionBus = EventBus&lt;OrderEvent, SyncPolicy&lt;OrderEvent&gt;&gt;;\n#else\nusing OrderExecutionBus = EventBus&lt;OrderEvent, AsyncPolicy&lt;OrderEvent&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/execution/bus/order_execution_bus/#purpose","title":"Purpose","text":"<ul> <li>Fan-out dispatch of <code>OrderEvent</code>s to registered execution listeners with selectable sync/async policy.</li> </ul>"},{"location":"components/execution/bus/order_execution_bus/#responsibilities","title":"Responsibilities","text":"Aspect Description Payload Transports <code>OrderEvent</code> instances directly (no pooling). Mode Toggled via <code>FLOX_USE_SYNC_ORDER_BUS</code> macro at compile time. Usage Used to notify components like <code>PositionManager</code>, <code>PnLTracker</code>, etc."},{"location":"components/execution/bus/order_execution_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> ensures deterministic propagation \u2014 used in simulation/test environments.</li> <li><code>AsyncPolicy</code> favors latency and throughput \u2014 suitable for production execution.</li> <li>Dispatch is resolved via <code>EventDispatcher&lt;OrderEvent&gt;</code>, which calls <code>dispatchTo(listener)</code>.</li> </ul>"},{"location":"components/execution/events/order_event/","title":"OrderEvent","text":"<p><code>OrderEvent</code> encapsulates a single order lifecycle transition and delivers it to components via <code>OrderExecutionBus</code>.</p> <pre><code>struct OrderEvent {\n  using Listener = IOrderExecutionListener;\n\n  OrderEventStatus type{};\n  Order order{};\n  Order newOrder{};\n  Quantity fillQty{0};\n  uint64_t tickSequence = 0;\n\n  void dispatchTo(IOrderExecutionListener&amp; listener) const;\n};\n</code></pre>"},{"location":"components/execution/events/order_event/#purpose","title":"Purpose","text":"<ul> <li>Represent and route order state changes (submission, fills, cancelation, etc.) to execution listeners.</li> </ul>"},{"location":"components/execution/events/order_event/#responsibilities","title":"Responsibilities","text":"Field Description type Event type \u2014 one of <code>SUBMITTED</code>, <code>FILLED</code>, <code>REPLACED</code>, etc. order The primary order involved in the event. newOrder Used only for <code>REPLACED</code> events. fillQty Quantity filled (used only in <code>PARTIALLY_FILLED</code>). tickSequence Event ordering marker for sequencing and backtesting."},{"location":"components/execution/events/order_event/#dispatch-logic","title":"Dispatch Logic","text":"<pre><code>void dispatchTo(IOrderExecutionListener&amp; listener) const;\n</code></pre> <p>Routes the event to the appropriate method:</p> Type Dispatched Method <code>SUBMITTED</code> <code>onOrderSubmitted(order)</code> <code>ACCEPTED</code> <code>onOrderAccepted(order)</code> <code>PARTIALLY_FILLED</code> <code>onOrderPartiallyFilled(order, fillQty)</code> <code>FILLED</code> <code>onOrderFilled(order)</code> <code>CANCELED</code> <code>onOrderCanceled(order)</code> <code>EXPIRED</code> <code>onOrderExpired(order)</code> <code>REJECTED</code> <code>onOrderRejected(order, /*reason*/ \"\")</code> <code>REPLACED</code> <code>onOrderReplaced(order, newOrder)</code>"},{"location":"components/execution/events/order_event/#notes","title":"Notes","text":"<ul> <li>Dispatch is type-safe and static \u2014 no RTTI or dynamic casts.</li> <li><code>tickSequence</code> ensures global ordering consistency across mixed event streams.</li> <li>Used by <code>EventBus&lt;OrderEvent, *&gt;</code> and delivered to <code>IOrderExecutionListener</code> implementations.</li> </ul>"},{"location":"components/killswitch/abstract_killswitch/","title":"IKillSwitch","text":"<p><code>IKillSwitch</code> defines the interface for components that enforce emergency shutdown conditions in the trading system, typically in response to loss limits, excessive order flow, or abnormal conditions.</p> <pre><code>class IKillSwitch : public ISubsystem {\npublic:\n  virtual ~IKillSwitch() = default;\n\n  virtual void check(const Order&amp; order) = 0;\n  virtual void trigger(const std::string&amp; reason) = 0;\n  virtual bool isTriggered() const = 0;\n  virtual std::string reason() const = 0;\n};\n</code></pre>"},{"location":"components/killswitch/abstract_killswitch/#purpose","title":"Purpose","text":"<ul> <li>Provide runtime protection against runaway strategies, loss accumulation, or systemic failures by halting all trading activity.</li> </ul>"},{"location":"components/killswitch/abstract_killswitch/#responsibilities","title":"Responsibilities","text":"Method Description <code>check(order)</code> Evaluates the incoming order against risk limits. <code>trigger()</code> Manually activates the kill switch with a reason string. <code>isTriggered()</code> Returns whether the kill switch is currently active. <code>reason()</code> Returns the human-readable cause of activation."},{"location":"components/killswitch/abstract_killswitch/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code>, allowing coordinated startup and reset across engine lifecycle.</li> <li>Can be wired into strategy layer, order executor, or global event loop.</li> <li>Once triggered, downstream components are expected to halt order submission and processing.</li> </ul>"},{"location":"components/log/abstract_logger/","title":"Logger","text":"<p>The <code>ILogger</code> interface defines a minimal, abstract logging API for internal and external use.</p> <p>It provides a consistent way to report messages of varying severity and supports multiple logging strategies, including console, file, and shared-memory loggers.</p>"},{"location":"components/log/abstract_logger/#interface","title":"Interface","text":"<pre><code>enum class LogLevel {\n  Info,\n  Warn,\n  Error\n};\n\nenum class OverflowPolicy {\n  Drop,      // Silently drop new messages when buffer is full\n  Overwrite  // Overwrite oldest messages\n};\n\nstruct ILogger {\n  virtual ~ILogger() = default;\n\n  virtual void info(std::string_view msg) = 0;\n  virtual void warn(std::string_view msg) = 0;\n  virtual void error(std::string_view msg) = 0;\n};\n</code></pre>"},{"location":"components/log/abstract_logger/#usage","title":"Usage","text":"<p>You can implement <code>ILogger</code> to customize how logs are handled. For example:</p> <ul> <li>Writing to <code>stdout</code> or <code>stderr</code></li> <li>Writing to rotating log files</li> <li>Logging to <code>/dev/shm</code> for high-speed shared memory logging</li> <li>Filtering messages based on <code>LogLevel</code></li> <li>Batching or compressing logs for network transmission</li> </ul> <p>Example implementation for stdout:</p> <pre><code>struct StdoutLogger : public ILogger {\n  void info(std::string_view msg) override {\n    std::cout &lt;&lt; \"[INFO] \" &lt;&lt; msg &lt;&lt; std::endl;\n  }\n  void warn(std::string_view msg) override {\n    std::cout &lt;&lt; \"[WARN] \" &lt;&lt; msg &lt;&lt; std::endl;\n  }\n  void error(std::string_view msg) override {\n    std::cerr &lt;&lt; \"[ERROR] \" &lt;&lt; msg &lt;&lt; std::endl;\n  }\n};\n</code></pre>"},{"location":"components/log/abstract_logger/#overflow-policy","title":"Overflow Policy","text":"<p>When used in conjunction with buffered or lock-free logging systems, <code>OverflowPolicy</code> governs what happens when the log buffer is full:</p> <ul> <li><code>Drop</code>: new incoming messages are discarded.</li> <li><code>Overwrite</code>: older messages are overwritten to make space.</li> </ul> <p>This allows you to trade off between completeness and real-time guarantees.</p>"},{"location":"components/log/abstract_logger/#best-practices","title":"Best Practices","text":"<ul> <li>Do not use logging in latency-critical paths (e.g. market data callbacks) unless the logger is designed for low-latency (e.g. lock-free).</li> <li>Prefer shared-memory or file-backed logging for persistency.</li> <li>Use <code>LogLevel</code> filtering to avoid excessive log volume in production.</li> </ul>"},{"location":"components/log/abstract_logger/#related","title":"Related","text":"<ul> <li><code>AtomicLogger</code>: ultra-low-latency lock-free logger implementation in Flox</li> <li><code>LogLevel</code>: enumeration for severity control</li> <li><code>OverflowPolicy</code>: controls log buffering behavior</li> </ul>"},{"location":"components/log/atomic_logger/","title":"AtomicLogger","text":"<p><code>AtomicLogger</code> is a low-latency, lock-free logger implementation designed for high-performance environments. It supports log-level filtering, auto-rotation by time or size, and writes to shared memory by default (<code>/dev/shm</code>).</p>"},{"location":"components/log/atomic_logger/#purpose","title":"Purpose","text":"<ul> <li>Avoid allocations and locks on the hot path (<code>info</code>, <code>warn</code>, <code>error</code>)</li> <li>Defer I/O to a background thread</li> <li>Support size/time-based log rotation</li> <li>Enable high-throughput logging in performance-critical systems</li> </ul>"},{"location":"components/log/atomic_logger/#construction","title":"Construction","text":"<pre><code>AtomicLoggerOptions opts;\nopts.levelThreshold = LogLevel::Warn;\nopts.basename = \"flox.log\";\nopts.directory = \"/var/log/flox\";\nopts.maxFileSize = 10 * 1024 * 1024;\nopts.rotateInterval = std::chrono::minutes(30);\n\nauto logger = std::make_unique&lt;AtomicLogger&gt;(opts);\n</code></pre>"},{"location":"components/log/atomic_logger/#options","title":"Options","text":"Field Description <code>overflow</code> <code>Drop</code> or <code>Overwrite</code> when buffer is full <code>levelThreshold</code> Minimum <code>LogLevel</code> to log <code>basename</code> Log file base name (e.g. <code>flox.log</code>) <code>directory</code> Directory for log output (e.g. <code>/dev/shm</code>) <code>maxFileSize</code> Maximum size before rotation <code>rotateInterval</code> Time-based rotation window <code>flushImmediately</code> If <code>true</code>, flush immediately after each message"},{"location":"components/log/atomic_logger/#implementation-details","title":"Implementation Details","text":"<ul> <li>Ring buffer of fixed-size entries (1024)</li> <li>Each entry stores: timestamp, level, message (max 256 bytes)</li> <li>A background thread reads the buffer and writes to file</li> <li>Rotation occurs when file size exceeds <code>maxFileSize</code> or interval passes</li> </ul>"},{"location":"components/log/atomic_logger/#threading-model","title":"Threading Model","text":"<ul> <li>Writers: lock-free, use atomic <code>_writeIndex</code></li> <li>Flusher: single thread consumes entries using <code>_readIndex</code></li> <li>Coordination: via condition variable (new entries or periodic wake-up)</li> </ul>"},{"location":"components/log/atomic_logger/#sample-usage","title":"Sample Usage","text":"<pre><code>AtomicLogger logger;\nlogger.info(\"Engine started\");\nlogger.warn(\"Price feed delayed\");\nlogger.error(\"Order failed: rejected by risk\");\n</code></pre>"},{"location":"components/log/atomic_logger/#format","title":"Format","text":"<p>Log entries are printed with timestamp and level prefix:</p> <pre><code>2025-07-14T08:42:03Z [INFO] Engine started\n2025-07-14T08:42:04Z [WARN] Order queue near capacity\n2025-07-14T08:42:05Z [ERROR] RiskManager::allow rejected order\n</code></pre>"},{"location":"components/log/atomic_logger/#notes","title":"Notes","text":"<ul> <li>Buffer overflow behavior depends on <code>OverflowPolicy</code></li> <li>Log rotation renames the file with a timestamp suffix</li> <li>Avoid writing long messages: max message size is 256 bytes</li> <li>Log flushing is done in a separate thread to reduce latency</li> </ul>"},{"location":"components/log/atomic_logger/#related","title":"Related","text":"<ul> <li><code>ILogger</code>: base interface</li> <li><code>OverflowPolicy</code>: defines handling strategy when buffer is full</li> <li><code>LogLevel</code>: defines filtering threshold</li> </ul>"},{"location":"components/log/console_logger/","title":"ConsoleLogger","text":"<p><code>ConsoleLogger</code> is a simple <code>ILogger</code> implementation that writes log messages directly to standard output.</p>"},{"location":"components/log/console_logger/#purpose","title":"Purpose","text":"<ul> <li>Provide a minimal, zero-setup logger for testing and development</li> <li>Print log messages to console (<code>stdout</code>)</li> <li>Filter messages based on severity level</li> </ul>"},{"location":"components/log/console_logger/#construction","title":"Construction","text":"<pre><code>ConsoleLogger logger(LogLevel::Warn);\nlogger.info(\"This will be filtered out\");\nlogger.warn(\"This will be printed\");\n</code></pre> <p>The constructor accepts a <code>LogLevel</code> threshold. Messages below the threshold are ignored.</p>"},{"location":"components/log/console_logger/#methods","title":"Methods","text":"Method Description <code>info(msg)</code> Logs a message with <code>LogLevel::Info</code> <code>warn(msg)</code> Logs a message with <code>LogLevel::Warn</code> <code>error(msg)</code> Logs a message with <code>LogLevel::Error</code> <code>log(level, msg)</code> Logs a message at specified level (manual use)"},{"location":"components/log/console_logger/#output-format","title":"Output Format","text":"<p>The logger prepends each message with a fixed label, e.g.:</p> <pre><code>[INFO]  Engine started\n[WARN]  Config missing field 'symbol'\n[ERROR] Order rejected by validator\n</code></pre>"},{"location":"components/log/console_logger/#filtering","title":"Filtering","text":"<p>Only messages with a level greater than or equal to the configured <code>LogLevel</code> are printed:</p> <pre><code>ConsoleLogger logger(LogLevel::Warn);\nlogger.info(\"Ignored\");\nlogger.warn(\"Printed\");\n</code></pre>"},{"location":"components/log/console_logger/#notes","title":"Notes","text":"<ul> <li><code>ConsoleLogger</code> is not thread-safe</li> <li>Suitable only for testing, not recommended for production</li> <li>Use <code>AtomicLogger</code> for performance-critical logging</li> </ul>"},{"location":"components/log/console_logger/#related","title":"Related","text":"<ul> <li><code>ILogger</code>: base interface</li> <li><code>LogLevel</code>: severity levels used for filtering</li> </ul>"},{"location":"components/log/log/","title":"Logging Macros","text":"<p>Flox provides a set of lightweight logging macros with compile-time and runtime control. These macros wrap <code>LogStream</code> for structured message building and support selective log-level filtering.</p>"},{"location":"components/log/log/#macros-overview","title":"Macros Overview","text":"Macro Description <code>FLOX_LOG(...)</code> Logs message at <code>Info</code> level <code>FLOX_LOG_INFO(...)</code> Shortcut for <code>Info</code> level <code>FLOX_LOG_WARN(...)</code> Shortcut for <code>Warn</code> level <code>FLOX_LOG_ERROR(...)</code> Shortcut for <code>Error</code> level <code>FLOX_LOG_LEVEL(lvl, ...)</code> Logs at custom level (<code>LogLevel</code>) <code>FLOX_LOG_ON()</code> Enable runtime logging <code>FLOX_LOG_OFF()</code> Disable runtime logging"},{"location":"components/log/log/#logstream-integration","title":"LogStream Integration","text":"<p>All macros internally use <code>LogStream</code>, a RAII-style helper that sends the log message when it goes out of scope.</p> <p>Example:</p> <pre><code>FLOX_LOG(\"Book update: bid=\" &lt;&lt; update.bestBidPrice());\nFLOX_LOG_WARN(\"Rejecting order due to risk check failure\");\n</code></pre> <p>This is equivalent to:</p> <pre><code>if (isLoggingEnabled())\n  LogStream(LogLevel::Warn) &lt;&lt; \"Rejecting order due to risk check failure\";\n</code></pre> <p>The benefit is a clean, familiar <code>operator&lt;&lt;</code> syntax and delayed message formatting, only evaluated if logging is enabled.</p>"},{"location":"components/log/log/#compile-time-disable","title":"Compile-Time Disable","text":"<p>If <code>FLOX_DISABLE_LOGGING</code> is defined at compile time, all logging macros become no-ops:</p> <pre><code>#define FLOX_DISABLE_LOGGING\n</code></pre> <p>This is useful for benchmark builds or environments where logging must be completely stripped out.</p>"},{"location":"components/log/log/#thread-safety","title":"Thread Safety","text":"<ul> <li>Logging macros are thread-safe if the selected logger (e.g. <code>AtomicLogger</code>) is thread-safe.</li> <li>Overhead is minimal: each macro checks a global atomic <code>loggingEnabled</code> flag before constructing a <code>LogStream</code>.</li> </ul>"},{"location":"components/log/log/#notes","title":"Notes","text":"<ul> <li>No log message will be emitted if <code>FLOX_LOG_OFF()</code> was called or logging was disabled at runtime.</li> <li>Message formatting is deferred until <code>LogStream</code> destructor runs.</li> <li>Logs can be redirected by configuring a global logger (<code>ILogger</code> implementation).</li> </ul>"},{"location":"components/metrics/abstract_execution_tracker/","title":"IExecutionTracker","text":"<p><code>IExecutionTracker</code> defines an interface for tracking order lifecycle events with precise timestamps. It is typically used for latency analysis, logging, and performance metrics.</p> <pre><code>class IExecutionTracker : public ISubsystem {\npublic:\n  virtual ~IExecutionTracker() = default;\n\n  virtual void onOrderSubmitted(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderAccepted(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty, TimePoint ts) = 0;\n  virtual void onOrderFilled(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderCanceled(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderExpired(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderRejected(const Order&amp; order, const std::string&amp; reason, TimePoint ts) = 0;\n  virtual void onOrderReplaced(const Order&amp; oldOrder, const Order&amp; newOrder, TimePoint ts) = 0;\n};\n</code></pre>"},{"location":"components/metrics/abstract_execution_tracker/#purpose","title":"Purpose","text":"<ul> <li>Capture precise timing of each order state transition for performance diagnostics and post-trade analysis.</li> </ul>"},{"location":"components/metrics/abstract_execution_tracker/#responsibilities","title":"Responsibilities","text":"Method Captures <code>onOrderSubmitted</code> Time of initial submission. <code>onOrderAccepted</code> Time acknowledged by exchange or venue. <code>onOrderPartiallyFilled</code> Time of partial fill, including filled quantity. <code>onOrderFilled</code> Time of full fill. <code>onOrderCanceled</code> Time of cancel confirmation. <code>onOrderExpired</code> Time the order was marked as expired. <code>onOrderRejected</code> Time of rejection, including optional reason. <code>onOrderReplaced</code> Time of order replacement, with reference to both old and new."},{"location":"components/metrics/abstract_execution_tracker/#notes","title":"Notes","text":"<ul> <li>All timestamps are provided externally (usually by <code>ExecutionTrackerAdapter</code>) to ensure consistency.</li> <li>Used in simulations and live systems for detailed latency tracking and event sequencing.</li> <li>Inherits from <code>ISubsystem</code> for lifecycle integration with the engine.</li> </ul>"},{"location":"components/metrics/abstract_pnl_tracker/","title":"IPnLTracker","text":"<p><code>IPnLTracker</code> defines a minimal interface for tracking realized and unrealized profit and loss (PnL) based on filled orders.</p> <pre><code>class IPnLTracker : public ISubsystem {\npublic:\n  virtual ~IPnLTracker() = default;\n  virtual void onOrderFilled(const Order&amp; order) = 0;\n};\n</code></pre>"},{"location":"components/metrics/abstract_pnl_tracker/#purpose","title":"Purpose","text":"<ul> <li>Record and update PnL metrics in response to order fill events.</li> </ul>"},{"location":"components/metrics/abstract_pnl_tracker/#responsibilities","title":"Responsibilities","text":"Method Description <code>onOrderFilled</code> Called when an order is fully filled; updates PnL."},{"location":"components/metrics/abstract_pnl_tracker/#notes","title":"Notes","text":"<ul> <li>Invoked only on complete fills \u2014 partial fills should be handled at a higher level if needed.</li> <li>Used in both real-time and simulation modes to compute performance metrics.</li> <li>Inherits from <code>ISubsystem</code> for coordinated lifecycle management.</li> </ul>"},{"location":"components/net/abstract_transport/","title":"ITransport","text":"<p><code>ITransport</code> defines an abstract interface for sending asynchronous HTTP POST requests, allowing components to perform remote communication with external services.</p> <pre><code>class ITransport {\npublic:\n  virtual ~ITransport() = default;\n\n  virtual void post(\n    std::string_view url,\n    std::string_view body,\n    const std::vector&lt;std::pair&lt;std::string_view, std::string_view&gt;&gt;&amp; headers,\n    std::move_only_function&lt;void(std::string_view)&gt; onSuccess,\n    std::move_only_function&lt;void(std::string_view)&gt; onError) = 0;\n};\n</code></pre>"},{"location":"components/net/abstract_transport/#purpose","title":"Purpose","text":"<ul> <li>Provide a generic mechanism to send HTTP POST requests without coupling to a specific transport library or implementation.</li> <li>Enable integration with APIs, webhooks, or external risk/configuration services.</li> </ul>"},{"location":"components/net/abstract_transport/#responsibilities","title":"Responsibilities","text":"Method Description <code>post()</code> Sends a POST request to the specified URL with custom headers and body. Invokes success or error callback based on result."},{"location":"components/net/abstract_websocket_client/","title":"IWebSocketClient","text":"<p><code>IWebSocketClient</code> defines a minimal interface for managing WebSocket connections, including lifecycle control and message handling via callbacks.</p> <pre><code>class IWebSocketClient : public ISubsystem {\npublic:\n  virtual ~IWebSocketClient() = default;\n\n  virtual void onOpen(std::move_only_function&lt;void()&gt; cb) = 0;\n  virtual void onMessage(std::move_only_function&lt;void(std::string_view)&gt; cb) = 0;\n  virtual void onClose(std::move_only_function&lt;void(int, std::string_view)&gt; cb) = 0;\n\n  virtual void send(const std::string&amp; data) = 0;\n};\n</code></pre>"},{"location":"components/net/abstract_websocket_client/#purpose","title":"Purpose","text":"<ul> <li>Provide an abstraction for WebSocket communication used by exchange connectors and other components.</li> <li>Enable pluggable transport implementations with consistent interface.</li> </ul>"},{"location":"components/net/abstract_websocket_client/#responsibilities","title":"Responsibilities","text":"Method Description <code>onOpen()</code> Registers a callback to be invoked when the connection is successfully opened. <code>onMessage()</code> Registers a callback for receiving incoming text messages. <code>onClose()</code> Registers a callback to handle disconnection events with code and reason. <code>send()</code> Sends a text message over the active WebSocket connection. <code>start()</code> Initiates the WebSocket connection and starts event processing (inherited from ISubsystem) <code>stop()</code> Gracefully closes the connection and stops background processing (inherited from ISubsystem)"},{"location":"components/position/abstract_position_manager/","title":"IPositionManager","text":"<p><code>IPositionManager</code> maintains real-time position tracking per symbol and reacts to all order execution events. It is a core component for portfolio state management in both live trading and simulation.</p> <pre><code>class IPositionManager : public ISubsystem, public IOrderExecutionListener {\npublic:\n  explicit IPositionManager(SubscriberId id);\n  virtual ~IPositionManager() = default;\n\n  virtual Quantity getPosition(SymbolId symbol) const = 0;\n};\n</code></pre>"},{"location":"components/position/abstract_position_manager/#purpose","title":"Purpose","text":"<ul> <li>Track and expose current position sizes for all traded instruments in response to order events.</li> </ul>"},{"location":"components/position/abstract_position_manager/#responsibilities","title":"Responsibilities","text":"Method Description <code>getPosition()</code> Returns net position (long/short/flat) for a given <code>SymbolId</code>. Execution events Inherited from <code>IOrderExecutionListener</code> \u2014 updates position on <code>FILLED</code>, <code>REPLACED</code>, etc."},{"location":"components/position/abstract_position_manager/#notes","title":"Notes","text":"<ul> <li>Acts as a persistent state store for strategies, risk systems, and reporting.</li> <li>Must be registered with <code>OrderExecutionBus</code> to receive fill and cancel notifications.</li> <li>Can optionally implement position limits or exposure constraints internally.</li> </ul>"},{"location":"components/risk/abstract_risk_manager/","title":"IRiskManager","text":"<p><code>IRiskManager</code> defines an interface for validating whether a given order complies with system-defined risk constraints before it is submitted.</p> <pre><code>class IRiskManager : public ISubsystem {\npublic:\n  virtual ~IRiskManager() = default;\n  virtual bool allow(const Order&amp; order) const = 0;\n};\n</code></pre>"},{"location":"components/risk/abstract_risk_manager/#purpose","title":"Purpose","text":"<ul> <li>Enforce pre-trade risk checks such as size limits, leverage rules, or order throttling.</li> </ul>"},{"location":"components/risk/abstract_risk_manager/#responsibilities","title":"Responsibilities","text":"Method Description <code>allow()</code> Returns <code>true</code> if the order is permitted to proceed."},{"location":"components/risk/abstract_risk_manager/#notes","title":"Notes","text":"<ul> <li>Called by strategy or execution layer before submitting an order.</li> <li>Stateless implementations may rely solely on order parameters; stateful variants may track recent flow.</li> <li>Integrated into the engine via <code>ISubsystem</code> for unified startup and reset behavior.</li> </ul>"},{"location":"components/sink/abstract_storage_sink/","title":"IStorageSink","text":"<p><code>IStorageSink</code> defines the interface for persisting executed orders and related trading data. It abstracts away the underlying storage mechanism (e.g. MongoDB, binary log, cloud).</p> <pre><code>class IStorageSink : public ISubsystem {\npublic:\n  virtual ~IStorageSink() = default;\n  virtual void store(const Order&amp; order) = 0;\n};\n</code></pre>"},{"location":"components/sink/abstract_storage_sink/#purpose","title":"Purpose","text":"<ul> <li>Persist orders for post-trade audit, reconciliation, analytics, or compliance.</li> </ul>"},{"location":"components/sink/abstract_storage_sink/#responsibilities","title":"Responsibilities","text":"Method Description <code>store</code> Persists the provided <code>Order</code> object."},{"location":"components/sink/abstract_storage_sink/#notes","title":"Notes","text":"<ul> <li>Called when orders are filled, canceled, or otherwise finalized.</li> <li>Backends may include MongoDB, file-based logs, or in-memory mirrors.</li> <li>Integrated via <code>ISubsystem</code> for lifecycle control and flush handling.</li> </ul>"},{"location":"components/strategy/abstract_strategy/","title":"IStrategy","text":"<p><code>IStrategy</code> defines the interface for all trading strategies. It combines market data subscription and subsystem lifecycle control, serving as the main driver of signal generation and order placement.</p> <pre><code>class IStrategy : public ISubsystem, public IMarketDataSubscriber {\npublic:\n  virtual ~IStrategy() = default;\n};\n</code></pre>"},{"location":"components/strategy/abstract_strategy/#purpose","title":"Purpose","text":"<ul> <li>Represent a trading strategy that reacts to market data and drives execution decisions.</li> </ul>"},{"location":"components/strategy/abstract_strategy/#composition","title":"Composition","text":"Inherits From Responsibilities <code>IMarketDataSubscriber</code> Receives <code>TradeEvent</code>, <code>BookUpdateEvent</code>, <code>CandleEvent</code>. <code>ISubsystem</code> Enables coordinated <code>start()</code> / <code>stop()</code> during engine run."},{"location":"components/strategy/abstract_strategy/#notes","title":"Notes","text":"<ul> <li>Strategies are typically registered as subscribers to market data buses.</li> <li>Lifecycle hooks (<code>start</code>, <code>stop</code>) are used for setup, parameter resets, or cleanup.</li> <li>Strategies are expected to emit orders via <code>IOrderExecutor</code>, respecting <code>IRiskManager</code> and <code>IKillSwitch</code> constraints.</li> </ul>"},{"location":"components/util/base/decimal/","title":"Decimal","text":"<p><code>Decimal</code> is a fixed-point arithmetic wrapper designed for performance-critical environments such as HFT. It provides type-safe arithmetic on scaled integers with configurable tick precision and compile-time guarantees.</p> <pre><code>template &lt;typename Tag, int Scale, int64_t TickSize = 1&gt;\nclass Decimal {\n  // ...\n};\n</code></pre>"},{"location":"components/util/base/decimal/#purpose","title":"Purpose","text":"<ul> <li>Avoid floating-point rounding errors by using integer math with fixed scaling.</li> <li>Provide clean, zero-cost abstractions for price/quantity units with compile-time type safety.</li> </ul>"},{"location":"components/util/base/decimal/#parameters","title":"Parameters","text":"Template Param Description <code>Tag</code> Phantom type used to disambiguate unit domains (e.g. <code>Price</code>, <code>Qty</code>). <code>Scale</code> Number of sub-units per whole unit (e.g. 1000 = 3 decimal places). <code>TickSize</code> Granularity for tick-based rounding."},{"location":"components/util/base/decimal/#key-features","title":"Key Features","text":"Function Description <code>fromDouble(double)</code> Converts a floating-point value to scaled integer with rounding. <code>toDouble()</code> Converts internal <code>_raw</code> value to <code>double</code> for logging/debugging. <code>raw()</code> Returns raw internal <code>int64_t</code> value. <code>roundToTick()</code> Rounds to the nearest multiple of <code>TickSize</code>. <code>isZero()</code> True if <code>_raw == 0</code>. Arithmetic / Comparison Ops Full suite of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, etc. on same-type values."},{"location":"components/util/base/decimal/#notes","title":"Notes","text":"<ul> <li>Scale is enforced at compile time \u2014 <code>Decimal&lt;PriceTag, 1000&gt;</code> is a distinct type from <code>Decimal&lt;QuantityTag, 1000&gt;</code>.</li> <li>No virtual overhead, heap allocation, or runtime type checks.</li> <li>Supports tick-based alignment and arithmetic directly without conversions.</li> <li>Used throughout Flox for price, quantity, and other numeric domains.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/","title":"SPSCQueue","text":"<p><code>SPSCQueue</code> is a lock-free, bounded-size single-producer/single-consumer queue optimized for HFT workloads. It supports in-place construction, zero allocations, and cache-line isolation.</p> <pre><code>template &lt;typename T, size_t Capacity&gt;\nclass SPSCQueue;\n</code></pre>"},{"location":"components/util/concurrency/spsc_queue/#purpose","title":"Purpose","text":"<ul> <li>Provide low-latency, zero-contention messaging between one writer and one reader.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/#requirements","title":"Requirements","text":"<ul> <li><code>Capacity</code> must be a power of two.</li> <li><code>T</code> must be nothrow-destructible.</li> <li>Only one producer and one consumer may operate concurrently.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/#key-features","title":"Key Features","text":"Method Description <code>push(const T&amp;)</code> Enqueues a copy of an object. <code>emplace(T&amp;&amp;)</code> Enqueues an rvalue object (move). <code>try_emplace(...)</code> Constructs object in-place with arguments. <code>pop(T&amp;)</code> Pops and moves the front element into <code>out</code>. <code>try_pop()</code> Returns a pointer to the front element, or <code>nullptr</code> if empty. <code>try_pop_ref()</code> Returns <code>std::optional&lt;std::reference_wrapper&lt;T&gt;&gt;</code> for inline access. <code>empty()</code> / <code>full()</code> Check queue state. <code>clear()</code> Destroys and drains all pending elements. <code>size()</code> Returns current number of elements."},{"location":"components/util/concurrency/spsc_queue/#internal-design","title":"Internal Design","text":"<ul> <li>Ring buffer implementation with <code>Capacity</code> entries, using modulo <code>MASK = Capacity - 1</code>.</li> <li><code>_head</code> and <code>_tail</code> are <code>std::atomic&lt;size_t&gt;</code> and are false-shared-safe via <code>alignas(64)</code>.</li> <li>Uses placement <code>new</code> for in-place construction, avoids heap entirely.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/#notes","title":"Notes","text":"<ul> <li>Optimized for predictable, sub-microsecond latency in tight loops.</li> <li>No memory reclamation or ABA protection \u2014 not suitable for multi-producer/multi-consumer setups.</li> <li>All methods use <code>memory_order_acquire/release</code> to ensure visibility across cores.</li> <li>Destruction ensures safe draining of remaining elements via <code>~T()</code> call.</li> </ul>"},{"location":"components/util/eventing/event_bus/","title":"EventBus","text":"<p><code>EventBus</code> is a lock-free fan-out messaging system for publishing typed events to multiple subscribers. It supports both push (threaded delivery) and pull (manual draining) modes, and is configurable for sync or async semantics via policy injection.</p> <pre><code>template &lt;typename Event, typename Policy, size_t QueueSize = config::DEFAULT_EVENTBUS_QUEUE_SIZE&gt;\nclass EventBus;\n</code></pre>"},{"location":"components/util/eventing/event_bus/#purpose","title":"Purpose","text":"<ul> <li>Deliver high-frequency events (market data, orders, etc.) to multiple subscribers with minimal latency and zero allocations.</li> </ul>"},{"location":"components/util/eventing/event_bus/#supported-policies","title":"Supported Policies","text":"Policy Description <code>AsyncPolicy</code> Lock-free delivery in per-subscriber threads with no tick synchronization. <code>SyncPolicy</code> Uses <code>TickBarrier</code> to coordinate delivery across all subscribers per tick."},{"location":"components/util/eventing/event_bus/#key-responsibilities","title":"Key Responsibilities","text":"Method Description <code>subscribe()</code> Registers a new subscriber with individual queue and mode. <code>publish()</code> Broadcasts an event to all subscribers; sync-mode waits for completion. <code>start()</code> / <code>stop()</code> Starts or stops all push-mode subscriber threads. <code>getQueue(id)</code> Provides direct access to a subscriber\u2019s queue (for pull-mode). <code>enableDrainOnStop()</code> Ensures any remaining events are dispatched before shutdown."},{"location":"components/util/eventing/event_bus/#design-highlights","title":"Design Highlights","text":"<ul> <li>Queue per subscriber: Each listener has a dedicated <code>SPSCQueue</code> to avoid contention.</li> <li>Thread-per-subscriber: Only for <code>PUSH</code> mode; <code>PULL</code> consumers must drain manually.</li> <li>RAII-controlled sync: <code>TickGuard</code> ensures deterministic behavior in <code>SyncPolicy</code>.</li> <li>Zero dynamic allocations in hot path (<code>emplace()</code> used directly).</li> <li>Tick-sequenced events: <code>tickSequence</code> field is automatically set if present.</li> </ul>"},{"location":"components/util/eventing/event_bus/#internal-types","title":"Internal Types","text":"Name Description <code>QueueItem</code> Depends on <code>Policy</code>: either raw <code>Event</code> or <code>(Event, TickBarrier*)</code>. <code>Listener</code> Inferred from <code>Event::Listener</code>. <code>Queue</code> Lock-free ring buffer (single producer/consumer). <code>Entry</code> Subscription record: listener, queue, thread, and mode."},{"location":"components/util/eventing/event_bus/#notes","title":"Notes","text":"<ul> <li>Sync-mode (<code>SyncPolicy</code>) is ideal for deterministic backtesting or simulation.</li> <li>Async-mode (<code>AsyncPolicy</code>) is best suited for ultra-low-latency live systems.</li> <li><code>EventBus</code> is fully generic \u2014 works with any event type that defines a <code>Listener</code>.</li> </ul>"},{"location":"components/util/eventing/event_bus/#example-usage","title":"Example Usage","text":"<pre><code>using BookBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;, AsyncPolicy&lt;pool::Handle&lt;BookUpdateEvent&gt;&gt;&gt;;\nBookBus bus;\nbus.subscribe(bookHandler);\nbus.publish(bookUpdateHandle);\n</code></pre>"},{"location":"components/util/memory/pool/","title":"Pool &amp; Handle","text":"<p>This module implements a lock-free, reference-counted object pool for zero-allocation reuse of high-frequency data structures. It is optimized for HFT workloads with strict latency and memory control requirements.</p>"},{"location":"components/util/memory/pool/#poolpoolt-capacity","title":"<code>pool::Pool&lt;T, Capacity&gt;</code>","text":"<p>A statically sized memory pool for pre-allocating <code>T</code> objects that conform to the <code>Poolable</code> concept.</p> <pre><code>Pool&lt;BookUpdateEvent, 8192&gt; bookPool;\nauto handle = bookPool.acquire(); // returns optional&lt;Handle&lt;T&gt;&gt;\n</code></pre>"},{"location":"components/util/memory/pool/#purpose","title":"Purpose","text":"<ul> <li>Eliminate runtime allocations in performance-critical paths.</li> <li>Efficiently recycle reusable objects like events or buffers.</li> </ul>"},{"location":"components/util/memory/pool/#responsibilities","title":"Responsibilities","text":"Feature Description Allocation Constructs objects in-place using <code>std::pmr</code> memory resource. Recycling Returns objects to the pool via <code>releaseToPool()</code>. Ref-counting Uses intrusive reference counting (<code>retain</code>, <code>release</code>). Lifecycle Calls <code>clear()</code> and <code>resetRefCount()</code> on reuse."},{"location":"components/util/memory/pool/#poolhandlet","title":"<code>pool::Handle&lt;T&gt;</code>","text":"<p>A move-only, reference-counted smart pointer for objects allocated from the pool.</p> <pre><code>Handle&lt;BookUpdateEvent&gt; h = pool.acquire().value();\nh-&gt;tickSequence = 123;\n</code></pre>"},{"location":"components/util/memory/pool/#purpose_1","title":"Purpose","text":"<ul> <li>Safely manage lifetime of pooled objects without heap allocations.</li> </ul>"},{"location":"components/util/memory/pool/#features","title":"Features","text":"Feature Description Move-only Copy retains reference; assignment is deleted. Auto-release Returns to pool when last reference is destroyed. Type-safe cast <code>upcast&lt;U&gt;()</code> supports safe widening conversions."},{"location":"components/util/memory/pool/#type-requirements","title":"Type Requirements","text":"<p><code>T</code> must:</p> <ul> <li>Inherit from <code>RefCountable</code> and <code>PoolableBase&lt;T&gt;</code></li> <li> <p>Implement:</p> </li> <li> <p><code>clear()</code></p> </li> <li><code>setPool(void*)</code></li> <li><code>releaseToPool()</code></li> </ul>"},{"location":"components/util/memory/pool/#internal-design","title":"Internal Design","text":"<ul> <li><code>Pool&lt;T&gt;</code> uses <code>std::aligned_storage</code> for static placement.</li> <li>Objects are returned to the pool via an <code>SPSCQueue&lt;T*&gt;</code>.</li> <li>Backed by a <code>monotonic_buffer_resource</code> and <code>unsynchronized_pool_resource</code> for internal vector-like allocations.</li> </ul>"},{"location":"components/util/memory/pool/#notes","title":"Notes","text":"<ul> <li>Zero allocations in steady-state operation.</li> <li>Thread-safe for single-producer, single-consumer usage.</li> <li>All objects are destructed in-place on shutdown.</li> <li>Used extensively for <code>BookUpdateEvent</code>, <code>TradeEvent</code>, and other high-volume types.</li> </ul>"},{"location":"components/util/memory/ref_countable/","title":"RefCountable","text":"<p><code>RefCountable</code> is a low-overhead, intrusive reference counting base class. It enables manual control of object lifetime without dynamic memory management and is used as the foundation for pooled, shared objects in Flox.</p> <pre><code>class RefCountable {\npublic:\n  void retain() noexcept;\n  bool release() noexcept;\n  void resetRefCount(uint32_t value = 0) noexcept;\n  uint32_t refCount() const noexcept;\n};\n</code></pre>"},{"location":"components/util/memory/ref_countable/#purpose","title":"Purpose","text":"<ul> <li>Provide deterministic, allocation-free lifetime tracking for objects managed in pools or event buses.</li> </ul>"},{"location":"components/util/memory/ref_countable/#responsibilities","title":"Responsibilities","text":"Method Description <code>retain()</code> Increments reference count (non-atomic relaxed). <code>release()</code> Decrements reference count; returns <code>true</code> if last ref. <code>resetRefCount()</code> Resets ref count to 0 or specified value. <code>refCount()</code> Returns current ref count for debug/inspection."},{"location":"components/util/memory/ref_countable/#behavior","title":"Behavior","text":"<ul> <li>When <code>release()</code> returns <code>true</code>, the object is no longer in use and may be recycled.</li> <li>Incorrect calls (e.g. <code>release()</code> on <code>0</code>) are fatal in debug builds and abort in release.</li> </ul>"},{"location":"components/util/memory/ref_countable/#design-notes","title":"Design Notes","text":"<ul> <li>Uses <code>std::atomic&lt;uint32_t&gt;</code> with relaxed memory ordering for performance.</li> <li>Thread-safe under the assumption that retain/release are called from valid ownership contexts.</li> <li>Not designed for multi-owner concurrent access \u2014 intended for single-threaded or externally synchronized lifecycles.</li> </ul>"},{"location":"components/util/memory/ref_countable/#concept","title":"Concept","text":"<pre><code>template &lt;typename T&gt;\nconcept RefCountable = requires(T obj) {\n  { obj.retain() } -&gt; std::same_as&lt;void&gt;;\n  { obj.release() } -&gt; std::same_as&lt;bool&gt;;\n  { obj.resetRefCount() } -&gt; std::same_as&lt;void&gt;;\n};\n</code></pre> <p>This concept ensures compile-time validation for use in pooled or handle-managed objects.</p>"},{"location":"components/util/performance/core_assignment/","title":"CoreAssignmentManager","text":"<p><code>CoreAssignmentManager</code> is responsible for assigning CPU cores to critical components in the Flox Engine to optimize performance, minimize contention, and leverage CPU topology such as isolated cores and NUMA awareness.</p>"},{"location":"components/util/performance/core_assignment/#overview","title":"Overview","text":"<p>Flox supports assigning cores to the following critical components:</p> <ul> <li><code>marketData</code> \u2014 Market data collection and processing</li> <li><code>execution</code> \u2014 Order routing and order execution</li> <li><code>strategy</code> \u2014 Strategy computation and signal generation</li> <li><code>risk</code> \u2014 Risk validation and rejection filtering</li> </ul> <p>These components can be pinned to isolated or shared cores based on a configurable policy.</p>"},{"location":"components/util/performance/core_assignment/#configuration-criticalcomponentconfig","title":"Configuration: CriticalComponentConfig","text":"<p>This config defines how isolated and shared cores are assigned:</p> <pre><code>struct CriticalComponentConfig\n{\n  bool preferIsolatedCores;       // Prefer isolated cores if available\n  bool exclusiveIsolatedCores;    // Use isolated cores exclusively (no sharing)\n  bool allowSharedCriticalCores;  // Allow components to share cores\n  int minIsolatedForCritical;     // Minimum isolated cores required\n  std::map&lt;std::string, int&gt; componentPriority; // Lower value = higher priority\n};\n</code></pre> <p>Default priority:</p> Component Priority <code>marketData</code> 0 <code>execution</code> 1 <code>strategy</code> 2 <code>risk</code> 3"},{"location":"components/util/performance/core_assignment/#coreassignment-result","title":"CoreAssignment Result","text":"<p>After assignment, <code>CoreAssignment</code> structure contains:</p> <ul> <li><code>.marketDataCores</code>, <code>.executionCores</code>, <code>.strategyCores</code>, <code>.riskCores</code></li> <li><code>.generalCores</code> \u2014 fallback cores for non-critical components</li> <li><code>.hasIsolatedCores</code> \u2014 whether isolated cores were used</li> <li><code>.criticalCores</code> \u2014 union of all critical components' cores</li> </ul>"},{"location":"components/util/performance/core_assignment/#assignment-strategies","title":"Assignment Strategies","text":"Method Description <code>getRecommendedCoreAssignment()</code> Chooses optimal strategy based on config <code>getNumaAwareCoreAssignment()</code> Prefer NUMA-balanced layout if isolated cores <code>getBasicCoreAssignment(num, isolated)</code> Fallback round-robin assignment"},{"location":"components/util/performance/core_assignment/#affinity-pinning","title":"Affinity Pinning","text":"<p>You can pin the current thread to the assigned cores for a given component:</p> <pre><code>bool success = pinCriticalComponent(\"marketData\", assignment);\n</code></pre> <p>To pin all components at once:</p> <pre><code>setupAndPinCriticalComponents(config);\n</code></pre>"},{"location":"components/util/performance/core_assignment/#validation-and-debugging","title":"Validation and Debugging","text":"Method Purpose <code>verifyCriticalCoreIsolation()</code> Ensures all critical cores are truly isolated <code>checkIsolatedCoreRequirements()</code> Checks availability of minimum isolated cores <code>demonstrateIsolatedCoreUsage()</code> Logs current assignment and core layout <p>Example log output:</p> <pre><code>=== CPU Affinity and Isolated Core Usage Demonstration ===\nTotal CPU cores: 12\nIsolated cores: 2 3 4\nRecommended core assignment:\nMarket Data cores: 2\nExecution cores: 3\nStrategy cores: 4\nRisk cores: 5\nGeneral cores: 6 7 8 9 10 11\n</code></pre>"},{"location":"components/util/performance/core_assignment/#internals","title":"Internals","text":"<p>Under the hood, <code>CoreAssignmentManager</code> uses:</p> <ul> <li><code>CpuTopology</code> \u2014 queried for isolated and non-isolated cores</li> <li><code>ThreadAffinity</code> \u2014 pins threads to specified cores using <code>sched_setaffinity()</code></li> <li><code>NumaTopology</code> \u2014 optionally used to balance across NUMA nodes</li> </ul> <pre><code>ThreadAffinity affinity(createSystemInterface());\naffinity.pinCurrentThreadToCores({3});\n</code></pre>"},{"location":"components/util/performance/core_assignment/#notes","title":"Notes","text":"<ul> <li>Default policy uses one core per critical component.</li> <li>Isolated cores are preferred and assigned to higher priority components.</li> <li>General tasks are assigned remaining cores.</li> <li>This module is optional: core pinning will only occur if explicitly enabled.</li> </ul>"},{"location":"components/util/performance/cpu_affinity/","title":"CpuAffinity","text":"<p>The <code>CpuAffinity</code> class provides a unified interface for managing thread affinity, real-time scheduling, NUMA policies, and performance-oriented CPU assignment. It serves as a high-level facade over several specialized components.</p>"},{"location":"components/util/performance/cpu_affinity/#purpose","title":"Purpose","text":"<ul> <li>Pin threads and components to specific CPU cores</li> <li>Optimize for latency via isolated cores and NUMA locality</li> <li>Abstract platform details through injected interfaces</li> </ul>"},{"location":"components/util/performance/cpu_affinity/#composition","title":"Composition","text":"<p><code>CpuAffinity</code> internally coordinates the following subsystems:</p> Component Responsibility <code>ISystemInterface</code> Platform-specific system operations <code>CpuTopology</code> Logical/physical CPU and NUMA layout <code>ThreadAffinity</code> Pinning and scheduling logic <code>CoreAssignmentManager</code> Allocation of roles to CPU cores"},{"location":"components/util/performance/cpu_affinity/#key-features","title":"Key Features","text":""},{"location":"components/util/performance/cpu_affinity/#thread-affinity","title":"Thread Affinity","text":"<ul> <li><code>pinToCore(int coreId)</code></li> <li><code>pinToCore(std::thread&amp;, int coreId)</code></li> <li><code>getCurrentAffinity()</code></li> </ul>"},{"location":"components/util/performance/cpu_affinity/#scheduling","title":"Scheduling","text":"<ul> <li><code>setRealTimePriority(int priority = 80)</code></li> <li><code>setRealTimePriority(std::thread&amp;, int priority = 80)</code></li> </ul>"},{"location":"components/util/performance/cpu_affinity/#core-management","title":"Core Management","text":"<ul> <li><code>getNumCores()</code></li> <li><code>getIsolatedCores()</code></li> <li><code>disableCpuFrequencyScaling()</code></li> <li><code>enableCpuFrequencyScaling()</code></li> </ul>"},{"location":"components/util/performance/cpu_affinity/#assignment-strategies","title":"Assignment Strategies","text":"<ul> <li><code>getRecommendedCoreAssignment(...)</code></li> <li><code>getBasicCoreAssignment(...)</code></li> <li><code>getNumaAwareCoreAssignment(...)</code></li> <li><code>pinCriticalComponent(...)</code></li> <li><code>verifyCriticalCoreIsolation(...)</code></li> </ul>"},{"location":"components/util/performance/cpu_affinity/#numa-awareness","title":"NUMA Awareness","text":"<ul> <li><code>getNumaTopology()</code></li> <li><code>getNumaNodeForCore(int coreId)</code></li> <li><code>pinToNumaNode(int nodeId)</code></li> <li><code>setMemoryPolicy(int nodeId)</code></li> </ul>"},{"location":"components/util/performance/cpu_affinity/#lifecycle","title":"Lifecycle","text":"<p><code>CpuAffinity</code> can be created via its constructor or with the helper:</p> <pre><code>auto cpuAffinity = createCpuAffinity();\n````\n\nAll subsystems will be lazily instantiated with default implementations unless provided explicitly for testing.\n\n## RAII: `NumaAffinityGuard`\n\nWraps the calling thread with a temporary NUMA and affinity setting:\n\n```cpp\n{\n  NumaAffinityGuard guard(cpuAffinity, coreId, numaNodeId);\n  // thread is pinned and memory policy applied\n}\n// automatically restored on destruction\n</code></pre>"},{"location":"components/util/performance/cpu_affinity/#example","title":"Example","text":"<pre><code>auto affinity = createCpuAffinity();\n\nif (affinity-&gt;checkIsolatedCoreRequirements()) {\n  auto layout = affinity-&gt;getRecommendedCoreAssignment();\n  affinity-&gt;pinCriticalComponent(\"execution\", layout);\n  affinity-&gt;setRealTimePriority();\n}\n</code></pre>"},{"location":"components/util/performance/cpu_affinity/#integration","title":"Integration","text":"<p>Used by performance-critical modules such as:</p> <ul> <li>Strategy engine threads</li> <li>Market data collectors</li> <li>Execution pipelines</li> </ul> <p>It ensures low-latency execution and determinism by aligning component-to-core layout with hardware topology.</p>"},{"location":"components/util/performance/cpu_topology/","title":"CpuTopology","text":"<p>The <code>CpuTopology</code> class provides system-level introspection for CPU layout and NUMA topology. It is used to understand the physical and logical arrangement of cores and to optimize thread and memory placement.</p>"},{"location":"components/util/performance/cpu_topology/#purpose","title":"Purpose","text":"<ul> <li>Determine number of physical CPU cores</li> <li>Identify isolated and non-isolated cores</li> <li>Access detailed NUMA topology (if available)</li> <li>Map CPU cores to their NUMA nodes</li> </ul>"},{"location":"components/util/performance/cpu_topology/#key-structures","title":"Key Structures","text":""},{"location":"components/util/performance/cpu_topology/#numanode","title":"<code>NumaNode</code>","text":"<pre><code>struct NumaNode {\n  int nodeId;\n  std::vector&lt;int&gt; cpuCores;\n  size_t totalMemoryMB;\n  size_t freeMemoryMB;\n};\n````\n\n### `NumaTopology`\n\n```cpp\nstruct NumaTopology {\n  std::vector&lt;NumaNode&gt; nodes;\n  int numNodes;\n  bool numaAvailable;\n};\n</code></pre>"},{"location":"components/util/performance/cpu_topology/#responsibilities","title":"Responsibilities","text":"Method Description <code>getNumCores()</code> Returns total number of logical cores <code>getAllCores()</code> Returns list of core indices from 0 to N-1 <code>getIsolatedCores()</code> Returns list of isolated CPUs (from cmdline) <code>getNonIsolatedCores()</code> All cores minus isolated ones <code>isNumaAvailable()</code> Whether NUMA support is available on the system <code>getNumaTopology()</code> Returns detailed info about all NUMA nodes <code>getNumaNodeForCore(coreId)</code> Returns the NUMA node to which a specific core belongs <code>getCoresForNumaNode(nodeId)</code> Lists cores that belong to a given NUMA node"},{"location":"components/util/performance/cpu_topology/#lazy-caching","title":"Lazy Caching","text":"<p><code>CpuTopology</code> caches:</p> <ul> <li>Core count</li> <li>Isolated cores</li> <li>NUMA layout</li> </ul> <p>This minimizes redundant syscalls and file reads.</p>"},{"location":"components/util/performance/cpu_topology/#usage-example","title":"Usage Example","text":"<pre><code>CpuTopology topology(createSystemInterface());\n\nif (topology.isNumaAvailable()) {\n  auto nodes = topology.getNumaTopology().nodes;\n  for (const auto&amp; node : nodes) {\n    std::cout &lt;&lt; \"NUMA Node \" &lt;&lt; node.nodeId &lt;&lt; \": \";\n    for (int core : node.cpuCores)\n      std::cout &lt;&lt; core &lt;&lt; \" \";\n    std::cout &lt;&lt; \"\\n\";\n  }\n}\n</code></pre>"},{"location":"components/util/performance/cpu_topology/#integration","title":"Integration","text":"<p><code>CpuTopology</code> is used by:</p> <ul> <li><code>CpuAffinity</code> for pinning and scheduling</li> <li><code>CoreAssignmentManager</code> for optimized component placement</li> <li><code>NumaAffinityGuard</code> for temporary core+memory locality enforcement</li> </ul> <p>It provides the necessary insights into hardware layout to guide all thread and memory affinity operations.</p>"},{"location":"components/util/performance/system_interface/","title":"SystemInterface","text":"<p>The <code>SystemInterface</code> module provides an abstraction over platform-specific system operations related to CPU affinity, thread priority, NUMA configuration, and file I/O. It serves as the foundation for CPU-level performance tuning and is primarily used by <code>CpuAffinity</code> and related components.</p>"},{"location":"components/util/performance/system_interface/#purpose","title":"Purpose","text":"<ul> <li>Isolate system calls from platform-independent logic</li> <li>Enable mocking and testing via <code>NullSystemInterface</code></li> <li>Provide unified access to thread and CPU-level control</li> </ul>"},{"location":"components/util/performance/system_interface/#interface-isysteminterface","title":"Interface: <code>ISystemInterface</code>","text":""},{"location":"components/util/performance/system_interface/#affinity","title":"Affinity","text":"Method Description <code>setThreadAffinity(pthread_t thread, const std::vector&lt;int&gt;&amp; cores)</code> Pins a specific thread to the specified cores <code>setCurrentThreadAffinity(const std::vector&lt;int&gt;&amp; cores)</code> Pins the current thread to the specified cores <code>getCurrentThreadAffinity()</code> Returns the current thread\u2019s CPU affinity"},{"location":"components/util/performance/system_interface/#thread-priority","title":"Thread Priority","text":"Method Description <code>setThreadPriority(pthread_t thread, int priority)</code> Sets real-time priority (SCHED_FIFO) for a specific thread <code>setCurrentThreadPriority(int priority)</code> Sets real-time priority for the current thread"},{"location":"components/util/performance/system_interface/#topology-numa","title":"Topology &amp; NUMA","text":"Method Description <code>getNumCores()</code> Returns the total number of logical CPU cores <code>getIsolatedCores()</code> Returns list of isolated cores from <code>isolcpus=</code> kernel argument <code>getNumaNodes()</code> Returns list of NUMA nodes and associated core IDs <code>getNumaNodeForCore(int coreId)</code> Returns NUMA node ID for the given core <code>setMemoryPolicy(int nodeId)</code> Sets preferred memory allocation policy for the current thread <code>isNumaAvailable()</code> Returns true if NUMA is supported and available"},{"location":"components/util/performance/system_interface/#file-io","title":"File I/O","text":"Method Description <code>readFile(const std::string&amp; path)</code> Reads the content of a file <code>writeFile(const std::string&amp; path, const std::string&amp; content)</code> Writes content to a file"},{"location":"components/util/performance/system_interface/#implementations","title":"Implementations","text":""},{"location":"components/util/performance/system_interface/#linuxsysteminterface","title":"<code>LinuxSystemInterface</code>","text":"<p>Linux-specific implementation based on:</p> <ul> <li><code>sched_setaffinity</code>, <code>pthread_setschedparam</code>, <code>sched_setscheduler</code></li> <li>NUMA support via <code>&lt;numa.h&gt;</code> and <code>/sys/devices/system/node/</code></li> <li>Parses <code>/proc/cmdline</code> for <code>isolcpus=</code></li> <li>Reads and writes files through <code>std::ifstream</code> / <code>std::ofstream</code></li> </ul>"},{"location":"components/util/performance/system_interface/#nullsysteminterface","title":"<code>NullSystemInterface</code>","text":"<p>Dummy fallback used on unsupported platforms or in tests:</p> <ul> <li>All methods return <code>false</code> or empty/default values</li> <li>Safe no-op implementation</li> </ul>"},{"location":"components/util/performance/system_interface/#numa-support","title":"NUMA Support","text":"<p>NUMA is considered available if either:</p> <ol> <li>The system links with <code>libnuma</code> and headers are present (<code>FLOX_NUMA_LIBRARY_LINKED</code>)</li> <li><code>/sys/devices/system/node/</code> contains valid <code>node*</code> directories and <code>cpulist</code> files</li> </ol>"},{"location":"components/util/performance/system_interface/#factory-function","title":"Factory Function","text":"<pre><code>std::unique_ptr&lt;ISystemInterface&gt; createSystemInterface();\n````\n\nCreates a platform-appropriate implementation:\n\n* `LinuxSystemInterface` on Linux\n* `NullSystemInterface` otherwise\n\n## Example\n\n```cpp\nauto system = createSystemInterface();\n\nif (system-&gt;isNumaAvailable()) {\n  auto nodes = system-&gt;getNumaNodes();\n  if (!nodes.empty()) {\n    system-&gt;setCurrentThreadAffinity({nodes[0].second.front()});\n    system-&gt;setMemoryPolicy(nodes[0].first);\n  }\n}\n</code></pre>"},{"location":"components/util/performance/system_interface/#integration","title":"Integration","text":"<p>This interface is consumed by:</p> <ul> <li><code>ThreadAffinity</code></li> <li><code>CpuTopology</code></li> <li><code>CoreAssignmentManager</code></li> <li><code>CpuAffinity</code></li> </ul> <p>It decouples platform-specific logic and enables system-aware optimization in a portable way.</p>"},{"location":"components/util/performance/thread_affinity/","title":"ThreadAffinity","text":"<p>The <code>ThreadAffinity</code> class provides a unified interface for managing thread affinity, real-time priority, and CPU frequency policies in latency-critical systems. It is used to enforce deterministic scheduling behavior and optimal placement on isolated cores.</p>"},{"location":"components/util/performance/thread_affinity/#responsibilities","title":"Responsibilities","text":"Capability Description Pinning Assign threads (or current thread) to specific core(s) Priority Set real-time thread priorities (SCHED_FIFO) NUMA Set memory allocation policy for NUMA locality Governors Switch CPU frequency governors for performance consistency Validation Verify whether selected cores are isolated"},{"location":"components/util/performance/thread_affinity/#public-interface","title":"Public Interface","text":""},{"location":"components/util/performance/thread_affinity/#pinning","title":"Pinning","text":"<pre><code>bool pinCurrentThreadToCore(int coreId);\nbool pinCurrentThreadToCores(const std::vector&lt;int&gt;&amp; coreIds);\nbool pinThreadToCore(std::thread&amp;, int coreId);\nbool pinThreadToCores(std::thread&amp;, const std::vector&lt;int&gt;&amp; coreIds);\n````\n\n### Priority\n\n```cpp\nbool setCurrentThreadPriority(int priority = 80);\nbool setThreadPriority(std::thread&amp;, int priority = 80);\n</code></pre>"},{"location":"components/util/performance/thread_affinity/#affinity-numa","title":"Affinity &amp; NUMA","text":"<pre><code>std::vector&lt;int&gt; getCurrentThreadAffinity();\nbool setCurrentThreadNumaPolicy(int nodeId);\n</code></pre>"},{"location":"components/util/performance/thread_affinity/#cpu-frequency-policy","title":"CPU Frequency Policy","text":"<pre><code>bool disableCpuFrequencyScaling();  // \"performance\"\nbool enableCpuFrequencyScaling();   // \"powersave\"\n</code></pre>"},{"location":"components/util/performance/thread_affinity/#validation","title":"Validation","text":"<pre><code>bool verifyCriticalCoreIsolation(const std::vector&lt;int&gt;&amp; cores);\n</code></pre>"},{"location":"components/util/performance/thread_affinity/#usage-example","title":"Usage Example","text":"<pre><code>ThreadAffinity affinity(createSystemInterface());\n\naffinity.pinCurrentThreadToCore(2);\naffinity.setCurrentThreadPriority(90);\naffinity.disableCpuFrequencyScaling();\n</code></pre>"},{"location":"components/util/performance/thread_affinity/#threadaffinityguard","title":"ThreadAffinityGuard","text":"<p>RAII wrapper that ensures temporary pinning to a specific core or cores.</p> <pre><code>{\n  ThreadAffinityGuard guard(3);  // Pins thread to core 3 temporarily\n  // Do latency-sensitive work here\n}  // Original affinity is restored automatically\n</code></pre>"},{"location":"components/util/performance/thread_affinity/#design-notes","title":"Design Notes","text":"<ul> <li>Uses <code>ISystemInterface</code> for portability and mocking</li> <li>Avoids OS-specific code in high-level components</li> <li>Defaults to <code>performance</code> governor to eliminate CPU frequency variance</li> <li>Isolated cores are detected via <code>/proc/cmdline</code> (<code>isolcpus=...</code>)</li> </ul>"},{"location":"components/util/performance/thread_affinity/#integration","title":"Integration","text":"<p>Used directly or via:</p> <ul> <li><code>CpuAffinity</code> as part of performance toolkit</li> <li><code>NumaAffinityGuard</code> for NUMA-aware scoped locality</li> <li>Benchmark tools and real-time strategy components in FLOX</li> </ul>"},{"location":"components/validation/abstract_order_validator/","title":"IOrderValidator","text":"<p><code>IOrderValidator</code> defines the interface for validating outbound orders before submission. It ensures correctness and compliance with predefined constraints (e.g. price ranges, order size).</p> <pre><code>class IOrderValidator : public ISubsystem {\npublic:\n  virtual ~IOrderValidator() = default;\n  virtual bool validate(const Order&amp; order, std::string&amp; reason) const = 0;\n};\n</code></pre>"},{"location":"components/validation/abstract_order_validator/#purpose","title":"Purpose","text":"<ul> <li>Prevent invalid or unsafe orders from reaching the execution layer by performing sanity checks.</li> </ul>"},{"location":"components/validation/abstract_order_validator/#responsibilities","title":"Responsibilities","text":"Method Description <code>validate</code> Checks if the order is valid. Returns <code>true</code> if valid; else sets <code>reason</code>."},{"location":"components/validation/abstract_order_validator/#notes","title":"Notes","text":"<ul> <li>Must be called prior to invoking <code>IOrderExecutor::submitOrder()</code>.</li> <li>Provides human-readable error messages via the <code>reason</code> output parameter.</li> <li> <p>Implementations can enforce checks such as:</p> </li> <li> <p>Non-zero quantity</p> </li> <li>Price within expected deviation</li> <li>Tick-size alignment</li> <li>Symbol validity</li> <li>Integrated into the engine as an <code>ISubsystem</code> for lifecycle coordination.</li> </ul>"},{"location":"usage/config/","title":"Configuration","text":"<p>Flox is configured via the <code>EngineConfig</code> structure, typically loaded from a JSON file or embedded configuration source.</p>"},{"location":"usage/config/#example","title":"Example","text":"<pre><code>{\n  \"logLevel\": \"debug\",\n  \"exchanges\": [\n    {\n      \"name\": \"bybit\",\n      \"type\": \"mock\",\n      \"symbols\": [\n        { \"symbol\": \"DOTUSDT\", \"tickSize\": 0.001, \"expectedDeviation\": 0.5 }\n      ]\n    }\n  ],\n  \"killSwitchConfig\": {\n    \"maxOrderQty\": 10000,\n    \"maxLoss\": -5000,\n    \"maxOrdersPerSecond\": 100\n  }\n}\n</code></pre>"},{"location":"usage/config/#fields","title":"Fields","text":""},{"location":"usage/config/#loglevel","title":"<code>logLevel</code>","text":"<p>Controls runtime logging verbosity (<code>debug</code>, <code>info</code>, <code>warn</code>, etc.)</p>"},{"location":"usage/config/#exchanges","title":"<code>exchanges[]</code>","text":"<p>Defines which exchange connectors to start and which symbols to subscribe to.</p> <ul> <li><code>name</code>: display label or unique ID for internal routing</li> <li><code>type</code>: used by <code>ConnectorFactory</code> to instantiate the appropriate connector</li> <li><code>symbols[]</code>: list of symbol configs with tick size and allowed deviation</li> </ul>"},{"location":"usage/config/#killswitchconfig","title":"<code>killSwitchConfig</code>","text":"<p>Defines runtime shutdown thresholds:</p> <ul> <li><code>maxOrderQty</code>: maximum order size allowed per submission</li> <li><code>maxLoss</code>: hard limit on realized/unrealized loss</li> <li><code>maxOrdersPerSecond</code>: rate limit for outbound orders (<code>-1</code> disables)</li> </ul>"},{"location":"usage/config/#notes","title":"Notes","text":"<ul> <li><code>SymbolId</code> is derived automatically from <code>(exchange, symbol)</code> during engine startup</li> <li>Tick size and deviation are used by validators and order book alignment</li> <li>All configuration is immutable after startup for safety and determinism</li> </ul>"},{"location":"usage/connectors/","title":"Connectors","text":""},{"location":"usage/connectors/#connectors","title":"Connectors","text":"<p>Flox provides a modular architecture that allows connectors to centralized and decentralized exchanges to be developed independently and plugged into the engine.</p> <p>The open-source community implementations of connectors built on top of Flox are maintained in the following repository:</p> <p>https://github.com/FLOX-Foundation/flox-connectors</p> <p>This repository includes exchange connectors that:</p> <ul> <li>Connect to public and private WebSocket endpoints</li> <li>Publish market data into Flox event buses</li> <li>Route order requests via authenticated REST APIs</li> <li>Integrate with the core engine using low-latency infrastructure</li> </ul> <p>Contributions are welcome. See the repository for implementation guidelines and examples.</p>"},{"location":"usage/demo/","title":"Demo Application","text":"<p>The <code>demo</code> folder provides a minimal working example that wires Flox components into a functioning system. It demonstrates the architecture, event flow, and subsystem lifecycle in a controlled, simulated environment.</p>"},{"location":"usage/demo/#features","title":"Features","text":"<ul> <li><code>DemoConnector</code>: emits synthetic trades and book updates for testing</li> <li><code>DemoStrategy</code>: receives market data and generates mock orders</li> <li><code>SimpleOrderExecutor</code>: processes orders and triggers fills via <code>OrderExecutionBus</code></li> <li><code>SimplePnLTracker</code>, <code>SimpleKillSwitch</code>, <code>SimpleRiskManager</code>: lightweight control modules</li> <li><code>DemoBuilder</code>: constructs and wires all required subsystems and buses</li> </ul>"},{"location":"usage/demo/#running-the-demo","title":"Running the Demo","text":"<p>After building the project with CMake:</p> <pre><code>./demo/flox_demo\n</code></pre> <p>The demo will:</p> <ul> <li>Start two synthetic connectors</li> <li>Publish market data via <code>MarketDataBus</code></li> <li>Run the strategy and supporting systems for approximately five seconds</li> <li>Stop all components and exit cleanly</li> </ul>"},{"location":"usage/demo/#notes","title":"Notes","text":"<ul> <li>This demo is intended for integration testing and illustration only</li> <li>Production deployments should define their own builder and execution harness</li> <li>All demo components are isolated and can be replaced with real implementations</li> </ul>"},{"location":"usage/getting_started/","title":"Getting Started","text":"<p>This guide will help you build, test, and install Flox on your machine.</p>"},{"location":"usage/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 or later (e.g. GCC 13 or Clang 16+)</li> <li>CMake 3.22+</li> <li>Git</li> <li>Linux (recommended)</li> <li>GoogleTest and Google Benchmark</li> <li><code>clang-format</code> 18.1.8 (for development)</li> </ul>"},{"location":"usage/getting_started/#clone-and-build","title":"Clone and Build","text":"<pre><code>git clone https://github.com/eeiaao/flox.git\ncd flox\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n</code></pre>"},{"location":"usage/getting_started/#install-dependencies","title":"Install Dependencies","text":"<p>If GoogleTest and Google Benchmark are not installed system-wide:</p> <pre><code># GoogleTest\ngit clone --depth=1 https://github.com/google/googletest.git\ncmake -B gtest-build -S googletest\ncmake --build gtest-build --target gtest gtest_main gmock gmock_main\nsudo cmake --install gtest-build\n\n# Google Benchmark\ngit clone --depth=1 https://github.com/google/benchmark.git\ncmake -B benchmark-build -S benchmark -DCMAKE_BUILD_TYPE=Release -DBENCHMARK_DOWNLOAD_DEPENDENCIES=ON\ncmake --build benchmark-build -j$(nproc)\nsudo cmake --install benchmark-build\n</code></pre>"},{"location":"usage/getting_started/#clang-format-setup","title":"clang-format Setup","text":"<p>We use <code>clang-format</code> 18.x to enforce consistent style. Install it with:</p> <pre><code>sudo apt install -y wget gnupg lsb-release software-properties-common\nwget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt install -y clang-format-18\nsudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-18 100\n</code></pre>"},{"location":"usage/getting_started/#build-options","title":"Build Options","text":"<p>Flox supports optional components controlled via CMake flags:</p> Option Default Description <code>FLOX_ENABLE_TESTS</code> <code>OFF</code> Build unit tests <code>FLOX_ENABLE_BENCHMARKS</code> <code>OFF</code> Build benchmark binaries <code>FLOX_ENABLE_DEMO</code> <code>OFF</code> Build the demo application <p>To enable them:</p> <pre><code>cmake .. -DFLOX_ENABLE_TESTS=ON -DFLOX_ENABLE_BENCHMARKS=ON -DFLOX_ENABLE_DEMO=ON\n</code></pre>"},{"location":"usage/getting_started/#run-tests","title":"Run Tests","text":"<p>From the <code>build</code> directory:</p> <pre><code>ctest --output-on-failure\n</code></pre>"},{"location":"usage/getting_started/#run-benchmarks","title":"Run Benchmarks","text":"<pre><code>./benchmarks/nlevel_order_book_benchmark\n</code></pre> <p>Or any other binary in <code>benchmarks/</code>.</p>"},{"location":"usage/getting_started/#install-system-wide","title":"Install System-Wide","text":"<pre><code>sudo make install\n</code></pre>"},{"location":"usage/getting_started/#code-style-and-contribution","title":"Code Style and Contribution","text":"<ul> <li>All contributions go through pull requests</li> <li>Use existing naming and directory conventions</li> <li>Add tests, benchmarks, and documentation where appropriate</li> </ul> <p>A <code>.clang-format</code> file is provided. A <code>pre-commit</code> hook is installed automatically during CMake configuration. It formats all changed <code>.cpp</code> and <code>.h</code> files.</p> <p>To install it manually:</p> <pre><code>cp scripts/pre-commit .git/hooks/pre-commit\nchmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"usage/getting_started/#using-flox-in-your-project","title":"Using Flox in Your Project","text":"<p>Flox is a low-latency infrastructure library. It is suitable for building:</p> <ul> <li>HFT engines</li> <li>Backtesters and simulators</li> <li>Custom execution pipelines</li> <li>Signal routers and adapters</li> </ul> <p>All components are modular, testable, and can be used independently.</p>"},{"location":"usage/integration_flow/","title":"Integration Flow","text":""},{"location":"usage/integration_flow/#flox-system-integration-flow-overview","title":"Flox System Integration Flow (Overview)","text":""},{"location":"usage/integration_flow/#1-register-symbols","title":"1. Register Symbols","text":"<p>Before anything else, the system must define which trading instruments it will operate on. Each symbol is registered with an internal registry, which assigns it a unique identifier and stores metadata (such as exchange name, symbol string, and instrument type).</p>"},{"location":"usage/integration_flow/#2-instantiate-core-components","title":"2. Instantiate Core Components","text":"<p>Several core components must be created and wired together:</p> <ul> <li>A symbol registry to resolve and map symbols across the system.</li> <li>An order tracker to monitor local orders and maintain their current state.</li> <li>Event buses for market data and order events (e.g., for book updates, trades, and execution events).</li> </ul> <p>These components typically live for the entire lifetime of the system.</p>"},{"location":"usage/integration_flow/#3-create-executors-and-connectors","title":"3. Create Executors and Connectors","text":"<ul> <li>An order executor is responsible for sending orders to the exchange and reporting their status.</li> <li>An exchange connector connects to the market (e.g., via WebSocket or REST), receives real-time data, and publishes it to the system.</li> </ul> <p>Both components should be provided with access to the registry, tracker, and transport layer.</p>"},{"location":"usage/integration_flow/#4-set-up-event-delivery","title":"4. Set Up Event Delivery","text":"<p>Event buses are configured to distribute market data (book updates, trades) and internal events (such as order execution updates) to multiple subscribers.</p> <p>Subscribers may include:</p> <ul> <li>Trading strategies</li> <li>Data aggregators</li> <li>Metric collectors</li> <li>Risk modules</li> </ul> <p>Each subscriber declares its interest and is registered with the corresponding bus.</p>"},{"location":"usage/integration_flow/#5-launch-components","title":"5. Launch Components","text":"<p>Once everything is wired:</p> <ul> <li>Event buses are started to begin handling data.</li> <li>Exchange connectors establish connections and begin streaming data.</li> <li>Strategies are started and begin processing events and generating signals.</li> <li>Executors handle outgoing order flow and interact with the tracker and listener components.</li> </ul>"},{"location":"usage/integration_flow/#6-handle-execution-feedback","title":"6. Handle Execution Feedback","text":"<p>When orders are submitted, filled, rejected, or canceled, the system updates the order tracker and may notify listeners or emit events on an execution bus.</p> <p>This ensures consistency of order state and provides visibility into execution outcomes.</p>"},{"location":"usage/integration_flow/#7-shutdown-procedure","title":"7. Shutdown Procedure","text":"<p>When shutting down:</p> <ul> <li>Event buses are stopped to cease fan-out.</li> <li>Strategies and connectors are stopped gracefully.</li> <li>Executors complete any in-flight work and clean up.</li> </ul>"},{"location":"usage/integration_flow/#notes-for-implementers","title":"Notes for Implementers","text":"<ul> <li>The registry and tracker must be passed to any component that deals with symbols or order state.</li> <li>Thread safety and latency guarantees are core to the design \u2014 use lock-free or atomic constructs where applicable.</li> <li>No dynamic allocation in critical paths (e.g., during fan-out or order submission).</li> <li>Buses can operate in sync or async mode depending on requirements (e.g., determinism vs performance).</li> <li>The architecture is modular and decoupled \u2014 new strategies, connectors, or execution backends can be plugged in easily.</li> </ul>"},{"location":"usage/running_engine/","title":"Running the Flox Engine","text":"<p>This guide explains how to initialize and run the Flox engine by wiring together subsystems, strategies, and connectors.</p>"},{"location":"usage/running_engine/#structure","title":"Structure","text":"<p>To launch the engine:</p> <ol> <li>Construct the required core subsystems (<code>MarketDataBus</code>, <code>OrderExecutionBus</code>, etc.)</li> <li>Register symbols using <code>SymbolRegistry</code></li> <li>Instantiate and configure exchange connectors</li> <li>Subscribe strategies and wire their dependencies</li> <li>Pass everything into the <code>Engine</code> constructor and call <code>start()</code></li> </ol>"},{"location":"usage/running_engine/#example","title":"Example","text":"<pre><code>EngineConfig config = loadConfig();  // Load from JSON or other source\n\nauto registry = std::make_unique&lt;SymbolRegistry&gt;();\nauto mdb = std::make_unique&lt;MarketDataBus&gt;();\nauto orderBus = std::make_unique&lt;OrderExecutionBus&gt;();\n\nConnectorFactory::instance().registerConnector(\"bybit\",\n  [mdb = mdb.get(), registry = registry.get()](const std::string&amp; symbolStr) {\n    auto symbolId = registry-&gt;getSymbolId(\"bybit\", symbolStr);\n    auto conn = std::make_shared&lt;BybitExchangeConnector&gt;(symbolStr, *symbolId);\n    conn-&gt;setCallbacks(\n      [mdb](EventHandle&lt;BookUpdateEvent&gt; b) { mdb-&gt;publish(std::move(b)); },\n      [mdb](const TradeEvent&amp; t) { mdb-&gt;publish(t); });\n    return conn;\n  });\n\nstd::vector&lt;std::shared_ptr&lt;ExchangeConnector&gt;&gt; connectors;\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\n\n// Register symbols and create connectors\nfor (const auto&amp; ex : config.exchanges) {\n  for (const auto&amp; sym : ex.symbols) {\n    registry-&gt;registerSymbol(ex.name, sym.symbol);\n    auto conn = ConnectorFactory::instance().createConnector(ex.name, sym.symbol);\n    if (conn) connectors.push_back(conn);\n  }\n}\n\n// Load and wire strategies\nstd::vector&lt;std::shared_ptr&lt;IStrategy&gt;&gt; strategies = loadStrategiesFromConfig(registry.get());\nfor (const auto&amp; strat : strategies) {\n  auto executor = std::make_unique&lt;SimpleOrderExecutor&gt;(*orderBus);\n  strat-&gt;setOrderExecutor(executor.get());\n  subsystems.push_back(std::move(executor));\n  mdb-&gt;subscribe(strat);\n}\n\n// Final wiring\nsubsystems.push_back(std::move(mdb));\nsubsystems.push_back(std::move(orderBus));\nsubsystems.push_back(std::make_unique&lt;Subsystem&lt;SymbolRegistry&gt;&gt;(std::move(registry)));\n\nEngine engine(config, std::move(subsystems), std::move(connectors));\nengine.start();\n</code></pre>"},{"location":"usage/running_engine/#notes","title":"Notes","text":"<ul> <li>Strategies must implement <code>IMarketDataSubscriber</code></li> <li>Subsystems must inherit from <code>ISubsystem</code> or be wrapped in <code>Subsystem&lt;T&gt;</code></li> <li>Connectors are responsible for publishing <code>BookUpdateEvent</code> and <code>TradeEvent</code> into the bus</li> <li>All components must be constructed and wired manually before engine startup</li> </ul>"},{"location":"usage/running_engine/#lifecycle","title":"Lifecycle","text":"<p>The engine will:</p> <ol> <li>Start all subsystems</li> <li>Start all exchange connectors</li> <li>Begin dispatching events to strategies via <code>MarketDataBus</code></li> <li>Continue running until stopped or externally terminated</li> </ol> <p>Use this pattern to construct simulation environments, test harnesses, or live trading nodes.</p>"},{"location":"usage/strategies/","title":"Writing Strategies","text":"<p>Strategies in Flox are implemented by subclassing <code>IStrategy</code>, which defines a uniform interface for receiving market data and submitting orders. Strategies are market data subscribers with execution capability and injected dependencies.</p>"},{"location":"usage/strategies/#purpose","title":"Purpose","text":"<p>Encapsulate trading logic that reacts to market data and interacts with execution and control systems.</p>"},{"location":"usage/strategies/#interface-overview","title":"Interface Overview","text":"<pre><code>class IStrategy : public IMarketDataSubscriber {\n public:\n  // Lifecycle\n  virtual void onStart();\n  virtual void onStop();\n\n  // Market data callbacks\n  virtual void onCandle(const CandleEvent&amp; candle) override;\n  virtual void onTrade(const TradeEvent&amp; trade) override;\n  virtual void onBookUpdate(const BookUpdateEvent&amp; bookUpdate) override;\n\n  // Identification and mode\n  SubscriberId id() const override;\n  SubscriberMode mode() const override;\n};\n</code></pre>"},{"location":"usage/strategies/#strategy-lifecycle","title":"Strategy Lifecycle","text":"<ul> <li><code>onStart()</code> \u2014 called by the engine at startup before any events</li> <li><code>onStop()</code> \u2014 called before engine shutdown</li> </ul>"},{"location":"usage/strategies/#market-data","title":"Market Data","text":"<p>Strategies receive <code>BookUpdateEvent</code>, <code>TradeEvent</code>, and <code>CandleEvent</code> through their respective callbacks, depending on subscription mode.</p>"},{"location":"usage/strategies/#execution-and-control","title":"Execution and Control","text":"<p>All dependencies (e.g., order executor, validator, risk manager) must be owned or held directly by the strategy implementation. There are no getters or internal indirection in the base class. Example:</p> <pre><code>class MyStrategy : public IStrategy {\npublic:\n  MyStrategy(IOrderExecutor* executor,\n             IRiskManager* risk,\n             IOrderValidator* validator)\n    : _executor(executor), _risk(risk), _validator(validator) {}\n\n  void onBookUpdate(const BookUpdateEvent&amp; update) override {\n    if (!shouldEnter(update)) return;\n\n    Order order = buildOrder(update);\n\n    std::string reason;\n    if (_validator &amp;&amp; !_validator-&gt;validate(order, reason)) return;\n    if (_risk &amp;&amp; !_risk-&gt;allow(order)) return;\n\n    _executor-&gt;submitOrder(order);\n  }\n\nprivate:\n  IOrderExecutor* _executor;\n  IRiskManager* _risk;\n  IOrderValidator* _validator;\n\n  bool shouldEnter(const BookUpdateEvent&amp; update) const {\n    return (update.bestAskPrice() - update.bestBidPrice()) &gt;= MinSpread;\n  }\n\n  Order buildOrder(const BookUpdateEvent&amp; update) const {\n    return Order{\n      .symbol = update.symbol(),\n      .side = Side::BUY,\n      .price = update.bestBidPrice() + TickImprovement,\n      .quantity = DefaultQuantity,\n      .type = OrderType::LIMIT\n    };\n  }\n\n  static constexpr Price TickImprovement = 0.01;\n  static constexpr Price MinSpread = 0.03;\n  static constexpr Quantity DefaultQuantity = 100;\n};\n</code></pre>"},{"location":"usage/strategies/#best-practices","title":"Best Practices","text":"<ul> <li>Keep callbacks non-blocking</li> <li>Never retain raw event pointers</li> <li>Avoid unnecessary dependencies</li> <li>Own or store all dependencies explicitly in the strategy</li> </ul>"},{"location":"usage/strategies/#integration","title":"Integration","text":"<p>Strategies are wired with their dependencies in the engine builder or main application, and subscribed to the relevant buses. PULL or PUSH mode is selectable via <code>mode()</code> override.</p>"}]}