{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FLOX","text":"<p>High-performance C++ framework for building trading systems.</p> <p> </p>"},{"location":"#getting-started","title":"Getting Started","text":"Quickstart Build FLOX and run the demo in 5 minutes First Strategy Write and run your first trading strategy Architecture Understand how components work together API Reference Complete technical documentation"},{"location":"#documentation","title":"Documentation","text":"Section Description Tutorials Step-by-step lessons for new users How-To Guides Solutions for specific problems Explanation Architecture and design concepts Reference API specifications"},{"location":"#features","title":"Features","text":"Feature Description Lock-free event delivery Disruptor-style ring buffers for minimal latency Zero-allocation hot path Pre-allocated pools, no heap allocation during trading CPU affinity support Pin threads to isolated cores Multi-exchange trading CEX coordination with aggregation and smart routing Binary replay system Record live data, replay for backtesting Grid search optimization Parallel parameter optimization with mmap-based bar storage Type-safe primitives Strong types for Price, Quantity, SymbolId Modular architecture Use only what you need"},{"location":"#requirements","title":"Requirements","text":"Component Version C++ Standard C++20 Compiler GCC 13+ or Clang 16+ Build System CMake 3.22+ Platform Linux (recommended) <p>Optional: LZ4 for log compression</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>#include \"flox/strategy/istrategy.h\"\n#include \"flox/book/event/trade_event.h\"\n\nclass MyStrategy : public flox::IStrategy {\npublic:\n    void onTrade(const flox::TradeEvent&amp; event) override {\n        if (event.trade.symbol == _targetSymbol) {\n            processSignal(event.trade.price);\n        }\n    }\n\n    void start() override { _running = true; }\n    void stop() override { _running = false; }\n\nprivate:\n    flox::SymbolId _targetSymbol;\n    bool _running = false;\n};\n</code></pre> <p>Full tutorial \u2192</p>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"architecture/","title":"Architecture","text":"<p>FLOX is a modular framework for building low-latency execution systems. Its design emphasizes separation of concerns, predictable performance, and composability.</p>"},{"location":"architecture/#layers-of-the-architecture","title":"Layers of the Architecture","text":""},{"location":"architecture/#1-abstract-layer","title":"1. Abstract Layer","text":"<p>Defines pure interfaces with no internal state. These are the contracts your system is built upon:</p> <ul> <li><code>IStrategy</code>: strategy logic</li> <li><code>IOrderExecutor</code>: order submission</li> <li><code>IOrderExecutionListener</code>: execution events</li> <li><code>IRiskManager</code>, <code>IOrderValidator</code>, <code>IPositionManager</code>: trade controls and state</li> <li><code>IOrderBook</code>, <code>IExchangeConnector</code>: market structure</li> <li><code>ISubsystem</code>: unified lifecycle interface</li> <li><code>IMarketDataSubscriber</code>: receives events via data bus</li> </ul>"},{"location":"architecture/#why-it-matters","title":"Why it matters","text":"<ul> <li>Enables simulation, replay, and mocking</li> <li>Decouples logic from implementation</li> <li>Ensures correctness can be validated independently of performance</li> </ul>"},{"location":"architecture/#2-implementation-layer","title":"2. Implementation Layer","text":"<ul> <li><code>Engine</code>: orchestrates startup and shutdown</li> <li><code>NLevelOrderBook</code>: in-memory order book with tick-aligned price levels</li> <li><code>BarAggregator</code>: aggregates trades into fixed-interval OHLCV bars</li> <li><code>SymbolRegistry</code>: maps <code>(exchange:symbol)</code> pairs to compact <code>SymbolId</code></li> <li><code>EventBus</code>: Disruptor-style ring buffer for high-throughput event delivery</li> <li><code>BookUpdateEvent</code>, <code>TradeEvent</code>: pooled, reusable market data structures</li> </ul>"},{"location":"architecture/#features","title":"Features","text":"<ul> <li>Speed: tight memory layout, preallocated event structures</li> <li>Control: no heap allocation in event flow, deterministic dispatch</li> <li>Modularity: all components are independently replaceable and testable</li> </ul>"},{"location":"architecture/#event-delivery","title":"Event Delivery","text":"<p>Strategies implement <code>IMarketDataSubscriber</code> and receive events via <code>EventBus</code>:</p> <pre><code>class MyStrategy : public IMarketDataSubscriber\n{\npublic:\n  SubscriberId id() const override { return reinterpret_cast&lt;SubscriberId&gt;(this); }\n\n  void onBookUpdate(const BookUpdateEvent&amp; ev) override { /* handle event */ }\n  void onTrade(const TradeEvent&amp; ev) override { /* handle event */ }\n};\n</code></pre> <pre><code>marketDataBus-&gt;subscribe(&amp;strategy);\nmarketDataBus-&gt;start();\n</code></pre>"},{"location":"architecture/#market-data-fan-out-eventbus","title":"Market Data Fan-Out: EventBus","text":"<p>The <code>EventBus</code> uses a Disruptor-pattern ring buffer for high-throughput event delivery:</p>"},{"location":"architecture/#publishing","title":"Publishing:","text":"<pre><code>bus-&gt;publish(std::move(bookUpdate));\n</code></pre>"},{"location":"architecture/#subscribing","title":"Subscribing:","text":"<pre><code>bus-&gt;subscribe(&amp;myStrategy);\n</code></pre>"},{"location":"architecture/#behavior","title":"Behavior:","text":"<ul> <li>Single producer, multiple consumers</li> <li>Lock-free sequencing with busy-spin waiting</li> <li>Gating prevents overwriting unconsumed events</li> <li>Per-consumer threads with optional CPU affinity</li> <li>Events dispatched via <code>EventDispatcher</code></li> </ul>"},{"location":"architecture/#cpu-affinity-optional","title":"CPU Affinity (optional):","text":"<pre><code>#if FLOX_CPU_AFFINITY_ENABLED\nbus-&gt;setupOptimalConfiguration(BookUpdateBus::ComponentType::MARKET_DATA);\n#endif\n</code></pre>"},{"location":"architecture/#lifecycle-and-subsystems","title":"Lifecycle and Subsystems","text":"<p>All major components implement <code>ISubsystem</code>, exposing <code>start()</code> and <code>stop()</code> methods.</p> <p>Benefits:</p> <ul> <li>Deterministic lifecycle control</li> <li>Support for warm-up, teardown, benchmarking</li> <li>Simplified simulation and test orchestration</li> </ul>"},{"location":"architecture/#memory-and-performance","title":"Memory and Performance","text":"<p>FLOX is designed for allocation-free execution on the hot path:</p> <ul> <li><code>BookUpdateEvent</code>, <code>TradeEvent</code> come from <code>Pool&lt;T&gt;</code></li> <li><code>Handle&lt;T&gt;</code> ensures safe ref-counted reuse</li> <li><code>EventBus</code> ring buffer avoids dynamic allocation</li> <li><code>std::pmr::vector</code> used in <code>BookUpdate</code> avoids heap churn</li> </ul>"},{"location":"architecture/#symbol-centric-design","title":"Symbol-Centric Design","text":"<p>All routing and lookup is based on <code>SymbolId</code> (<code>uint32_t</code>):</p> <ul> <li>Fast lookup, avoids string comparison</li> <li>Enables per-symbol state machines, queues, books</li> <li>Supports dense fan-out architectures</li> </ul>"},{"location":"architecture/#intended-use","title":"Intended Use","text":"<p>FLOX is not a full trading engine \u2014 it's a toolkit for building:</p> <ul> <li>Real-time trading systems</li> <li>Simulators and replay backtesters</li> <li>Signal fan-out and market data routers</li> <li>Custom HFT infrastructure</li> </ul> <p>Designed for teams that require:</p> <ul> <li>Predictable low-latency performance</li> <li>Explicit memory and thread control</li> <li>Modular, testable architecture</li> </ul>"},{"location":"architecture/#example-integration","title":"Example Integration","text":"<pre><code>auto strategy = std::make_shared&lt;MyStrategy&gt;();\n\nBookUpdateBus bus;\nbus.subscribe(strategy.get());\nbus.start();\n\n// Publishing events\nbus.publish(std::move(bookUpdate));\n\n// Clean shutdown\nbus.flush();\nbus.stop();\n</code></pre>"},{"location":"architecture/#summary","title":"Summary","text":"<p>FLOX is:</p> <ul> <li>Modular \u2014 use only what you need</li> <li>Deterministic \u2014 fully controlled event timing</li> <li>Safe \u2014 no hidden allocations, pooled memory</li> <li>Flexible \u2014 works in backtests, simulation, and live systems</li> </ul> <p>You define the logic \u2014 FLOX moves the data.</p>"},{"location":"explanation/","title":"Explanation","text":"<p>Understand concepts and design decisions behind FLOX.</p>"},{"location":"explanation/#overview","title":"Overview","text":"Topic What You'll Learn Architecture How components fit together Disruptor Pattern Why we use ring buffers Memory Model Zero-allocation event delivery Integration Flow End-to-end data flow through the system"},{"location":"explanation/#when-to-read-these","title":"When to Read These","text":"<ul> <li>Before diving deep into customization</li> <li>When you want to understand design trade-offs</li> <li>If you're debugging performance issues</li> </ul>"},{"location":"explanation/architecture/","title":"Architecture Overview","text":"<p>How FLOX components fit together.</p>"},{"location":"explanation/architecture/#system-layers","title":"System Layers","text":"<pre><code>flowchart TB\n    subgraph L3[\"Application Layer\"]\n        strategy[Your Strategy]\n    end\n\n    subgraph L2[\"Core Layer\"]\n        eventbus[EventBus]\n        execution[Order Execution]\n        risk[Risk Management]\n    end\n\n    subgraph L1[\"Infrastructure Layer\"]\n        connectors[Connectors]\n        orderbooks[Order Books]\n        registry[Symbol Registry]\n        replay[Replay]\n    end\n\n    L1 --&gt; L2\n    L2 --&gt; L3</code></pre> Layer Components Purpose Infrastructure Connectors, Replay, Symbol Registry, Order Books Low-level I/O and data management Core EventBus, Order Execution, Risk Management Event routing and order flow Application Your Strategy Trading logic"},{"location":"explanation/architecture/#data-flow","title":"Data Flow","text":"<pre><code>flowchart TD\n    subgraph External\n        EX[Exchange API]\n    end\n\n    subgraph Connectors\n        CONN[IExchangeConnector]\n    end\n\n    subgraph EventBuses[Event Buses - Disruptor Ring Buffers]\n        TB[TradeBus]\n        BB[BookUpdateBus]\n        CB[BarBus]\n    end\n\n    subgraph Aggregators\n        CA[BarAggregator]\n    end\n\n    subgraph Strategies\n        ST[IStrategy]\n    end\n\n    subgraph Execution\n        OEB[OrderExecutionBus]\n        EXE[IOrderExecutor]\n        RM[IRiskManager]\n        KS[IKillSwitch]\n    end\n\n    EX --&gt; CONN\n    CONN --&gt; TB\n    CONN --&gt; BB\n    TB --&gt; ST\n    BB --&gt; ST\n    TB --&gt; CA\n    CA --&gt; CB\n    CB --&gt; ST\n    ST --&gt;|Order| RM\n    RM --&gt;|Allowed| KS\n    KS --&gt;|Not Triggered| EXE\n    EXE --&gt; OEB</code></pre>"},{"location":"explanation/architecture/#core-components","title":"Core Components","text":""},{"location":"explanation/architecture/#engine","title":"Engine","text":"<p>The <code>Engine</code> class orchestrates the system lifecycle:</p> <pre><code>class Engine : public ISubsystem\n{\npublic:\n  Engine(const EngineConfig&amp; config,\n         std::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems,\n         std::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors);\n\n  void start() override;\n  void stop() override;\n};\n</code></pre> <ul> <li>Takes ownership of all subsystems</li> <li>Starts subsystems first, then connectors</li> <li>Stops connectors first, then subsystems</li> <li>No configuration file parsing \u2014 you wire components manually</li> </ul>"},{"location":"explanation/architecture/#event-buses","title":"Event Buses","text":"<p>All buses use the Disruptor pattern (see The Disruptor Pattern):</p> Bus Event Type Purpose <code>TradeBus</code> <code>TradeEvent</code> Individual trades <code>BookUpdateBus</code> <code>pool::Handle&lt;BookUpdateEvent&gt;</code> Order book snapshots/deltas <code>BarBus</code> <code>BarEvent</code> OHLCV bars <code>OrderExecutionBus</code> <code>OrderEvent</code> Order state changes <p>Key characteristics:</p> <ul> <li>Lock-free ring buffer</li> <li>Single producer, multiple consumers</li> <li>Consumers run in dedicated threads</li> <li>Backpressure via sequence gating</li> </ul>"},{"location":"explanation/architecture/#connectors","title":"Connectors","text":"<p><code>IExchangeConnector</code> interface:</p> <pre><code>class IExchangeConnector\n{\npublic:\n  virtual ~IExchangeConnector() = default;\n  virtual void start() = 0;\n  virtual void stop() = 0;\n  virtual std::string exchangeId() const = 0;\n};\n</code></pre> <p>Connectors:</p> <ul> <li>Parse exchange-specific wire protocols</li> <li>Convert to FLOX event types</li> <li>Publish to event buses</li> <li>Run their own network threads</li> </ul>"},{"location":"explanation/architecture/#strategies","title":"Strategies","text":"<p><code>IStrategy</code> combines <code>ISubsystem</code> + <code>IMarketDataSubscriber</code>:</p> <pre><code>class IStrategy : public ISubsystem, public IMarketDataSubscriber\n{\npublic:\n  virtual ~IStrategy() = default;\n};\n</code></pre> <p>From <code>IMarketDataSubscriber</code>:</p> <ul> <li><code>onTrade(const TradeEvent&amp;)</code></li> <li><code>onBookUpdate(const BookUpdateEvent&amp;)</code></li> <li><code>onBar(const BarEvent&amp;)</code></li> </ul> <p>From <code>ISubsystem</code>:</p> <ul> <li><code>start()</code></li> <li><code>stop()</code></li> </ul>"},{"location":"explanation/architecture/#subsystem-interface","title":"Subsystem Interface","text":"<p>Everything that participates in engine lifecycle implements:</p> <pre><code>class ISubsystem\n{\npublic:\n  virtual ~ISubsystem() = default;\n  virtual void start() = 0;\n  virtual void stop() = 0;\n};\n</code></pre> <p>Subsystems include:</p> <ul> <li>Event buses</li> <li>Strategies</li> <li>Aggregators (e.g., BarAggregator)</li> <li>Execution trackers</li> <li>Custom components</li> </ul>"},{"location":"explanation/architecture/#symbol-management","title":"Symbol Management","text":"<p>Symbols are identified by <code>SymbolId</code> (<code>uint32_t</code>):</p> <pre><code>SymbolRegistry registry;\nregistry.registerSymbol(\"binance\", \"BTCUSDT\");  // Returns SymbolId\nauto id = registry.getSymbolId(\"binance\", \"BTCUSDT\");\n</code></pre> <p>Benefits:</p> <ul> <li>Fast comparison (integer vs string)</li> <li>Compact event structures</li> <li>Consistent across components</li> </ul>"},{"location":"explanation/architecture/#type-system","title":"Type System","text":"<p>FLOX uses strong types to prevent unit confusion:</p> Type Underlying Purpose <code>Price</code> Fixed-point Prices (avoid floating-point) <code>Quantity</code> Fixed-point Quantities <code>SymbolId</code> <code>uint32_t</code> Symbol identifier <code>OrderId</code> <code>uint64_t</code> Order identifier <code>UnixNanos</code> <code>int64_t</code> Nanosecond timestamp"},{"location":"explanation/architecture/#threading-model","title":"Threading Model","text":"<pre><code>flowchart TB\n    subgraph main[\"Main Thread\"]\n        engine[\"Engine lifecycle&lt;br/&gt;Subsystem start/stop\"]\n    end\n\n    subgraph connectors[\"Connector Threads\"]\n        c1[\"Connector 1&lt;br/&gt;Network I/O, Parsing\"]\n        c2[\"Connector 2&lt;br/&gt;Network I/O, Parsing\"]\n        c3[\"Connector N&lt;br/&gt;Network I/O, Parsing\"]\n    end\n\n    subgraph consumers[\"Bus Consumer Threads\"]\n        s1[\"Strategy A\"]\n        s2[\"Strategy B\"]\n        agg[\"Aggregator\"]\n    end\n\n    engine --&gt; connectors\n    engine --&gt; consumers\n    c1 --&gt; s1\n    c2 --&gt; s2\n    c3 --&gt; agg</code></pre> <ul> <li>Each connector manages its own threads</li> <li>Each bus consumer gets a dedicated thread</li> <li>Consumer threads can be pinned to isolated CPU cores</li> </ul>"},{"location":"explanation/architecture/#cpu-affinity-optional","title":"CPU Affinity (Optional)","text":"<p>With <code>FLOX_ENABLE_CPU_AFFINITY=ON</code>:</p> <pre><code>bus.setupOptimalConfiguration(EventBus::ComponentType::MARKET_DATA);\n</code></pre> <p>This:</p> <ul> <li>Pins consumer threads to isolated cores</li> <li>Sets real-time scheduling priority</li> <li>Enables NUMA-aware core assignment</li> </ul> <p>See Configure CPU Affinity.</p>"},{"location":"explanation/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>The Disruptor Pattern \u2014 Deep dive into event delivery</li> <li>Memory Model \u2014 Zero-allocation design</li> <li>First Strategy \u2014 Write your first strategy</li> </ul>"},{"location":"explanation/bar-types/","title":"Understanding Bar Types","text":"<p>This document explains the different bar types available in Flox and when to use each one.</p>"},{"location":"explanation/bar-types/#the-problem-with-time-bars","title":"The Problem with Time Bars","text":"<p>Traditional time-based bars (1-minute, hourly, daily) have a fundamental issue: information content varies with market activity.</p> <ul> <li>During high activity: bars pack lots of information</li> <li>During low activity: bars contain little information (noise)</li> </ul> <p>This inconsistency creates problems:</p> <ul> <li>Indicators behave differently at different times</li> <li>Backtests may not reflect live performance</li> <li>Overnight gaps distort analysis</li> </ul> <p>Alternative bar types address this by normalizing what closes a bar rather than when.</p>"},{"location":"explanation/bar-types/#bar-types-overview","title":"Bar Types Overview","text":"Type Closes When Best For Time Fixed time interval Traditional analysis, backtesting Tick N trades occur HFT, eliminating time bias Volume Notional volume threshold Volume-weighted analysis Renko Price moves by brick size Trend following, noise elimination Range High-low exceeds threshold Volatility-based analysis Heikin-Ashi Fixed time interval (smoothed) Trend clarity, noise reduction"},{"location":"explanation/bar-types/#time-bars","title":"Time Bars","text":"<pre><code>TimeBarAggregator aggregator(TimeBarPolicy(std::chrono::seconds(60)), &amp;bus);\n</code></pre> <p>How it works: Close after a fixed time interval (e.g., 1 minute).</p> <p>Pros:</p> <ul> <li>Familiar, widely used</li> <li>Easy to compare across instruments</li> <li>Works with most existing tools</li> </ul> <p>Cons:</p> <ul> <li>Information content varies</li> <li>Overnight gaps create distortions</li> <li>Low-activity periods add noise</li> </ul> <p>Use when:</p> <ul> <li>Backtesting strategies designed for time bars</li> <li>Comparing to external data sources</li> <li>Building indicators that expect regular intervals</li> </ul>"},{"location":"explanation/bar-types/#tick-bars","title":"Tick Bars","text":"<pre><code>TickBarAggregator aggregator(TickBarPolicy(100), &amp;bus);  // 100 trades per bar\n</code></pre> <p>How it works: Close after N trades occur, regardless of time.</p> <p>Pros:</p> <ul> <li>Consistent information per bar</li> <li>No time-based distortions</li> <li>Better for statistical analysis</li> </ul> <p>Cons:</p> <ul> <li>Bar duration varies wildly</li> <li>Can't easily compare across instruments</li> <li>May produce many bars during high activity</li> </ul> <p>Use when:</p> <ul> <li>High-frequency strategies</li> <li>Statistical arbitrage</li> <li>Eliminating time-of-day effects</li> </ul> <p>Example insight: A 100-tick bar during high volatility might span 1 second; during quiet periods, 10 minutes. But each bar represents the same amount of \"market activity.\"</p>"},{"location":"explanation/bar-types/#volume-bars","title":"Volume Bars","text":"<pre><code>VolumeBarAggregator aggregator(VolumeBarPolicy::fromDouble(1000000.0), &amp;bus);\n</code></pre> <p>How it works: Close after notional volume (price \u00d7 quantity) reaches threshold.</p> <p>Pros:</p> <ul> <li>Normalizes for trade size variation</li> <li>Better represents institutional activity</li> <li>Consistent economic significance per bar</li> </ul> <p>Cons:</p> <ul> <li>Threshold needs tuning per instrument</li> <li>Price changes affect bar frequency</li> </ul> <p>Use when:</p> <ul> <li>Analyzing institutional flow</li> <li>Volume-weighted strategies</li> <li>Markets with varying trade sizes</li> </ul> <p>Example: $1M volume bars on BTC might close every few seconds during active trading, but take hours overnight.</p>"},{"location":"explanation/bar-types/#renko-bars","title":"Renko Bars","text":"<pre><code>RenkoBarAggregator aggregator(RenkoBarPolicy::fromDouble(10.0), &amp;bus);\n</code></pre> <p>How it works: New bar only when price moves by \"brick size\" from previous close.</p> <p>Pros:</p> <ul> <li>Eliminates noise</li> <li>Clear trend visualization</li> <li>No time or volume dependency</li> </ul> <p>Cons:</p> <ul> <li>Loses timing information</li> <li>Can miss reversals within brick</li> <li>Gaps create multiple bricks</li> </ul> <p>Use when:</p> <ul> <li>Trend following strategies</li> <li>Support/resistance identification</li> <li>Filtering out market noise</li> </ul> <p>Unique property: Renko bars only move one direction until reversal. A series of up-bricks means consistent upward movement without significant pullbacks.</p>"},{"location":"explanation/bar-types/#range-bars","title":"Range Bars","text":"<pre><code>RangeBarAggregator aggregator(RangeBarPolicy::fromDouble(5.0), &amp;bus);\n</code></pre> <p>How it works: Close when high-low range exceeds threshold.</p> <p>Pros:</p> <ul> <li>Consistent volatility per bar</li> <li>Adapts to market conditions</li> <li>Good for breakout detection</li> </ul> <p>Cons:</p> <ul> <li>Can produce many small bars in trending markets</li> <li>Range threshold needs tuning</li> </ul> <p>Use when:</p> <ul> <li>Volatility-based strategies</li> <li>Breakout trading</li> <li>Options-related strategies</li> </ul> <p>Example: $5 range bars will close quickly during volatile periods (many bars) and slowly during consolidation (fewer bars).</p>"},{"location":"explanation/bar-types/#heikin-ashi-bars","title":"Heikin-Ashi Bars","text":"<pre><code>HeikinAshiBarAggregator aggregator(HeikinAshiBarPolicy(std::chrono::seconds(60)), &amp;bus);\n</code></pre> <p>How it works: Uses smoothed OHLC calculations based on previous bar:</p> <ul> <li>HA_Close = (Open + High + Low + Close) / 4</li> <li>HA_Open = (prev_HA_Open + prev_HA_Close) / 2</li> <li>HA_High = max(High, HA_Open, HA_Close)</li> <li>HA_Low = min(Low, HA_Open, HA_Close)</li> </ul> <p>Pros:</p> <ul> <li>Smoother trends, easier to identify</li> <li>Reduces noise from individual bars</li> <li>Bullish bars always have close &gt; open</li> <li>Great for visual trend analysis</li> </ul> <p>Cons:</p> <ul> <li>Loses exact price information</li> <li>Not suitable for precise entries</li> <li>Lags behind actual price</li> <li>Requires previous bar for calculation</li> </ul> <p>Use when:</p> <ul> <li>Trend following strategies</li> <li>Visual trend confirmation</li> <li>Reducing false signals in choppy markets</li> <li>Swing trading with trend filters</li> </ul> <p>Unique property: In a strong uptrend, Heikin-Ashi bars will show no lower wicks (or very small ones). Conversely, strong downtrends show no upper wicks. This makes trend strength immediately visible.</p> <p>Multi-symbol support: The Heikin-Ashi aggregator maintains independent state per symbol, so a single aggregator instance can correctly handle multiple symbols simultaneously.</p>"},{"location":"explanation/bar-types/#choosing-the-right-bar-type","title":"Choosing the Right Bar Type","text":""},{"location":"explanation/bar-types/#decision-framework","title":"Decision Framework","text":"<pre><code>What matters most for your strategy?\n\n\u251c\u2500\u2500 Time consistency?\n\u2502   \u2514\u2500\u2500 Use TIME bars\n\u2502\n\u251c\u2500\u2500 Trade activity?\n\u2502   \u2514\u2500\u2500 Use TICK bars\n\u2502\n\u251c\u2500\u2500 Dollar volume?\n\u2502   \u2514\u2500\u2500 Use VOLUME bars\n\u2502\n\u251c\u2500\u2500 Price movement?\n\u2502   \u251c\u2500\u2500 Trend direction \u2192 Use RENKO bars\n\u2502   \u2514\u2500\u2500 Volatility \u2192 Use RANGE bars\n</code></pre>"},{"location":"explanation/bar-types/#by-strategy-type","title":"By Strategy Type","text":"Strategy Recommended Bar Type Mean reversion Time or Volume Momentum Time, Renko, or Heikin-Ashi Scalping/HFT Tick Trend following Renko, Heikin-Ashi, or Time Volatility trading Range Statistical arb Tick or Volume Swing trading Time (H1, D1) or Heikin-Ashi"},{"location":"explanation/bar-types/#by-market-condition","title":"By Market Condition","text":"Condition Better Choice High volatility Range or Renko Low liquidity Volume 24/7 markets Tick or Volume Session-based Time Trending Renko or Heikin-Ashi Ranging Time or Range Noisy markets Heikin-Ashi"},{"location":"explanation/bar-types/#multi-timeframe-with-mixed-types","title":"Multi-Timeframe with Mixed Types","text":"<p>Combine bar types for better analysis:</p> <pre><code>MultiTimeframeAggregator&lt;4&gt; aggregator(&amp;bus);\naggregator.addTimeInterval(std::chrono::seconds(60));   // M1 for timing\naggregator.addTimeInterval(std::chrono::seconds(3600)); // H1 for trend\naggregator.addTickInterval(100);                         // Tick for activity\naggregator.addVolumeInterval(1000000.0);                 // Volume for flow\n</code></pre> <p>Strategy example:</p> <ul> <li>H1 time bars for trend direction</li> <li>Volume bars for institutional activity</li> <li>Tick bars for precise entry timing</li> </ul>"},{"location":"explanation/bar-types/#performance-comparison","title":"Performance Comparison","text":"<p>All bar types have similar computational cost:</p> Operation Time Tick Volume Renko Range Heikin-Ashi shouldClose() O(1) O(1) O(1) O(1) O(1) O(1) update() O(1) O(1) O(1) O(1) O(1) O(1) <p>The main difference is bar frequency, not computational overhead.</p>"},{"location":"explanation/bar-types/#summary","title":"Summary","text":"<ul> <li>Time bars: Traditional, familiar, but information-inconsistent</li> <li>Tick bars: Consistent activity, good for HFT</li> <li>Volume bars: Consistent economic significance</li> <li>Renko bars: Noise-free trend visualization</li> <li>Range bars: Volatility-normalized</li> <li>Heikin-Ashi bars: Smoothed trends, noise reduction</li> </ul> <p>Choose based on what your strategy needs to hold constant: time, activity, volume, price movement, volatility, or trend clarity.</p>"},{"location":"explanation/bar-types/#see-also","title":"See Also","text":"<ul> <li>Bar Aggregator Reference</li> <li>How to Create Custom Bar Policy</li> <li>Multi-Timeframe Strategy Tutorial</li> </ul>"},{"location":"explanation/disruptor/","title":"The Disruptor Pattern","text":"<p>Why FLOX uses ring buffers for event delivery.</p>"},{"location":"explanation/disruptor/#the-problem","title":"The Problem","text":"<p>Traditional publish-subscribe systems have bottlenecks:</p> <pre><code>flowchart LR\n    P[Producer] --&gt; Q[Queue]\n    Q --&gt; C[Consumer]\n    Q -.-&gt;|Contention| X[Locks&lt;br/&gt;Allocations&lt;br/&gt;Cache misses]</code></pre> <p>For each event:</p> <ol> <li>Lock acquisition \u2014 Wait for mutex</li> <li>Memory allocation \u2014 Create queue node</li> <li>Cache invalidation \u2014 Producer and consumer fight over cache lines</li> </ol> <p>At millions of events per second, these costs add up.</p>"},{"location":"explanation/disruptor/#the-disruptor-solution","title":"The Disruptor Solution","text":"<p>The Disruptor pattern (from LMAX Exchange) eliminates these costs:</p> <pre><code>              Ring Buffer (pre-allocated)\n\n  [0] [1] [2] [3] [4] [5] [6] [7]\n       \u2191               \u2191\n    Consumer       Producer\n    Sequence       Sequence\n</code></pre> <p>Key insights:</p> <ol> <li>Pre-allocated array \u2014 No allocation during publishing</li> <li>Sequence numbers \u2014 Atomic counters replace locks</li> <li>Cache-line padding \u2014 False sharing eliminated</li> <li>Batching \u2014 Consumers can process multiple events</li> </ol>"},{"location":"explanation/disruptor/#flox-implementation","title":"FLOX Implementation","text":"<p>FLOX's <code>EventBus</code> implements a Disruptor-style ring buffer:</p> <pre><code>template &lt;typename Event,\n          size_t CapacityPow2 = config::DEFAULT_EVENTBUS_CAPACITY,\n          size_t MaxConsumers = config::DEFAULT_EVENTBUS_MAX_CONSUMERS&gt;\nclass EventBus : public ISubsystem;\n</code></pre>"},{"location":"explanation/disruptor/#publishing","title":"Publishing","text":"<pre><code>// Producer claims slot via atomic increment\nint64_t seq = _next.fetch_add(1);\n\n// Wait for consumers to free the slot\nwhile (seq - CapacityPow2 &gt; minConsumerSequence()) {\n  backoff.pause();\n}\n\n// Write event directly into ring buffer\n_storage[seq &amp; Mask] = event;\n_published[seq &amp; Mask].store(seq);  // Signal consumers\n</code></pre>"},{"location":"explanation/disruptor/#consuming","title":"Consuming","text":"<p>Each consumer runs in a dedicated thread:</p> <pre><code>while (running) {\n  // Wait for next sequence\n  while (_published[seq &amp; Mask] != seq) {\n    backoff.pause();\n  }\n\n  // Process event\n  listener-&gt;onTrade(_storage[seq &amp; Mask]);\n\n  // Advance sequence\n  _consumers[i].seq.store(seq);\n}\n</code></pre>"},{"location":"explanation/disruptor/#sequence-gating","title":"Sequence Gating","text":"<p>Producers wait for the slowest consumer before overwriting slots:</p> <pre><code>sequenceDiagram\n    participant P as Producer\n    participant RB as Ring Buffer\n    participant CA as Consumer A\n    participant CB as Consumer B\n\n    Note over RB: Capacity = 8\n\n    P-&gt;&gt;RB: publish(seq=107)\n    RB--&gt;&gt;P: Wait! Slot 99 (107-8) not consumed\n\n    Note over CA: seq = 105\n    Note over CB: seq = 102 (slowest)\n\n    CB-&gt;&gt;RB: consume(seq=103)\n    Note over CB: seq = 103\n\n    RB--&gt;&gt;P: Slot 99 free, continue\n    P-&gt;&gt;RB: write event at slot 107</code></pre> <p>Gating Logic: <pre><code>Producer Sequence: 107\nConsumer A Sequence: 105\nConsumer B Sequence: 102  \u2190 Slowest (gating sequence)\nRing Buffer Size: 8\n\nProducer can advance to: 102 + 8 = 110\n</code></pre></p> <p>This provides backpressure \u2014 fast producers can't overwhelm slow consumers.</p>"},{"location":"explanation/disruptor/#cache-line-optimization","title":"Cache-Line Optimization","text":"<p>The Disruptor uses padding to prevent false sharing:</p> <pre><code>// Without padding: False sharing\nstruct Bad {\n  std::atomic&lt;int64_t&gt; producer_seq;\n  std::atomic&lt;int64_t&gt; consumer_seq;  // Same cache line!\n};\n\n// With padding: No false sharing\nalignas(64) std::atomic&lt;int64_t&gt; producer_seq;\nalignas(64) std::atomic&lt;int64_t&gt; consumer_seq;\n</code></pre> <p>FLOX uses <code>alignas(64)</code> throughout <code>EventBus</code>:</p> <pre><code>alignas(64) std::atomic&lt;bool&gt; _running{false};\nalignas(64) std::atomic&lt;int64_t&gt; _next{-1};\nalignas(64) std::atomic&lt;int64_t&gt; _cachedMin{-1};\n// ...\nalignas(64) std::array&lt;ConsumerSlot, MaxConsumers&gt; _consumers{};\nalignas(64) std::array&lt;std::atomic&lt;int64_t&gt;, MaxConsumers&gt; _gating{};\n</code></pre>"},{"location":"explanation/disruptor/#busy-spin-vs-blocking","title":"Busy-Spin vs. Blocking","text":"<p>Consumers use configurable backoff with three modes:</p> <pre><code>enum class BackoffMode {\n  AGGRESSIVE,  // Dedicated colo: busy-spin with CPU pause, minimal yields\n  RELAXED,     // Shared VPS/cloud: early sleep, minimal CPU burn\n  ADAPTIVE     // Auto-adjust: starts aggressive, backs off under contention\n};\n\nBusyBackoff backoff(BackoffMode::ADAPTIVE);  // Default\n</code></pre> <p>AGGRESSIVE \u2014 for dedicated hardware with isolated cores:</p> <ul> <li>2048 spins with CPU pause</li> <li>Then yield, reset at 4096</li> </ul> <p>RELAXED \u2014 for shared VPS/cloud environments:</p> <ul> <li>8 spins, then yield</li> <li>Sleep 100\u03bcs after 16 spins</li> <li>Sleep 500\u03bcs for sustained idle</li> </ul> <p>ADAPTIVE (default) \u2014 auto-adjusts based on contention:</p> <ul> <li>128 spins with CPU pause (low-latency burst handling)</li> <li>512 spins with yield (medium contention)</li> <li>Sleep 10\u03bcs up to 2048 spins</li> <li>Sleep 100\u03bcs and reset to medium level</li> </ul> <p>This balances latency (busy-spin) with CPU usage (sleep) based on deployment environment.</p>"},{"location":"explanation/disruptor/#multiple-consumers","title":"Multiple Consumers","text":"<p>FLOX supports multiple consumers per bus:</p> <pre><code>flowchart LR\n    subgraph Producer\n        P[Connector Thread]\n    end\n\n    subgraph RB[Ring Buffer]\n        direction LR\n        S0[E0] --- S1[E1] --- S2[E2] --- S3[E3]\n    end\n\n    subgraph Consumers[Consumer Threads]\n        C1[Strategy A&lt;br/&gt;seq=5]\n        C2[Strategy B&lt;br/&gt;seq=3]\n        C3[Logger&lt;br/&gt;seq=2]\n    end\n\n    P --&gt;|publish| RB\n    RB --&gt;|deliver| C1\n    RB --&gt;|deliver| C2\n    RB --&gt;|deliver| C3\n\n    style C3 fill:#fdd</code></pre> <pre><code>tradeBus-&gt;subscribe(strategyA.get());\ntradeBus-&gt;subscribe(strategyB.get());\ntradeBus-&gt;subscribe(logger.get());\n</code></pre> <p>Each consumer:</p> <ul> <li>Gets a dedicated thread</li> <li>Maintains its own sequence</li> <li>Processes events independently</li> </ul> <p>The producer waits for the slowest consumer before overwriting.</p>"},{"location":"explanation/disruptor/#required-vs-optional-consumers","title":"Required vs. Optional Consumers","text":"<pre><code>// Required (default): affects backpressure\ntradeBus-&gt;subscribe(strategyA.get(), /*required=*/true);\n\n// Optional: doesn't gate the producer\ntradeBus-&gt;subscribe(logger.get(), /*required=*/false);\n</code></pre> <p>Optional consumers:</p> <ul> <li>Won't slow down the system if they fall behind</li> <li>May miss events if too slow</li> <li>Useful for monitoring, logging, metrics</li> </ul>"},{"location":"explanation/disruptor/#performance-characteristics","title":"Performance Characteristics","text":"Metric Notes Publish latency Lock-free atomic operations only Consume latency Depends on backoff strategy and load Throughput Limited by slowest consumer Memory overhead Fixed: <code>sizeof(Event) \u00d7 Capacity</code> <p>Actual numbers depend heavily on: - CPU architecture and cache hierarchy - Whether cores are isolated - Event size and consumer callback complexity - System load</p> <p>Run benchmarks on your target hardware to establish baseline.</p>"},{"location":"explanation/disruptor/#when-disruptor-shines","title":"When Disruptor Shines","text":"<p>Good fit:</p> <ul> <li>High-throughput, low-latency requirements</li> <li>Predictable memory usage</li> <li>Single producer, multiple consumers</li> <li>Events are processed in order</li> </ul> <p>Not ideal for:</p> <ul> <li>Multiple producers (requires coordination)</li> <li>Unbounded queues</li> <li>Very uneven consumer speeds</li> </ul>"},{"location":"explanation/disruptor/#configuration","title":"Configuration","text":"<pre><code>// Custom capacity and consumer limit\nusing MyBus = EventBus&lt;TradeEvent,\n                       /*CapacityPow2=*/16384,\n                       /*MaxConsumers=*/32&gt;;\n</code></pre> <p>Capacity must be a power of 2 (for fast modulo via bitmask).</p>"},{"location":"explanation/disruptor/#further-reading","title":"Further Reading","text":"<ul> <li>LMAX Disruptor Paper</li> <li>Memory Model \u2014 How FLOX handles event ownership</li> <li>Architecture Overview \u2014 Full system design</li> </ul>"},{"location":"explanation/integration-flow/","title":"Integration Flow","text":"<p>Step-by-step guide to integrating FLOX components into a complete trading system.</p>"},{"location":"explanation/integration-flow/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    subgraph Setup\n        A[1. Register Symbols] --&gt; B[2. Create Core Components]\n        B --&gt; C[3. Create Executors &amp; Connectors]\n        C --&gt; D[4. Wire Event Delivery]\n    end\n\n    subgraph Runtime\n        D --&gt; E[5. Launch Components]\n        E --&gt; F[6. Handle Execution Feedback]\n    end\n\n    subgraph Teardown\n        F --&gt; G[7. Shutdown]\n    end</code></pre>"},{"location":"explanation/integration-flow/#1-register-symbols","title":"1. Register Symbols","text":"<p>Before anything else, define which trading instruments the system will operate on. Each symbol is registered with an internal registry, which assigns a unique identifier and stores metadata.</p> <pre><code>#include \"flox/engine/symbol_registry.h\"\n\nSymbolRegistry registry;\n\n// Register symbols with exchange and instrument info\nauto btcId = registry.registerSymbol(\"binance\", \"BTCUSDT\", InstrumentType::PERPETUAL);\nauto ethId = registry.registerSymbol(\"binance\", \"ETHUSDT\", InstrumentType::PERPETUAL);\n\n// Retrieve later by name\nauto symbolId = registry.getSymbolId(\"binance\", \"BTCUSDT\");\n</code></pre> <p>Key points:</p> <ul> <li><code>SymbolId</code> is a compact integer for fast comparison</li> <li>Registry maps <code>(exchange, symbol)</code> pairs to <code>SymbolId</code></li> <li>Metadata includes instrument type, tick size, lot size</li> </ul>"},{"location":"explanation/integration-flow/#2-create-core-components","title":"2. Create Core Components","text":"<p>Several core components must be created and wired together:</p> <pre><code>#include \"flox/book/bus/trade_bus.h\"\n#include \"flox/book/bus/book_update_bus.h\"\n#include \"flox/execution/bus/order_execution_bus.h\"\n#include \"flox/execution/order_tracker.h\"\n\n// Event buses for market data\nauto tradeBus = std::make_unique&lt;TradeBus&gt;();\nauto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\n\n// Execution infrastructure\nauto execBus = std::make_unique&lt;OrderExecutionBus&gt;();\nauto orderTracker = std::make_unique&lt;OrderTracker&gt;();\n</code></pre> <p>Component responsibilities:</p> Component Purpose <code>SymbolRegistry</code> Resolve and map symbols <code>OrderTracker</code> Monitor orders and maintain state <code>TradeBus</code> Distribute trade events <code>BookUpdateBus</code> Distribute order book updates <code>OrderExecutionBus</code> Distribute execution events"},{"location":"explanation/integration-flow/#3-create-executors-and-connectors","title":"3. Create Executors and Connectors","text":"<pre><code>#include \"flox/execution/abstract_executor.h\"\n#include \"flox/connector/abstract_exchange_connector.h\"\n\n// Order executor sends orders to exchange\nauto executor = std::make_unique&lt;BinanceExecutor&gt;(\n    transport,\n    registry,\n    orderTracker.get()\n);\n\n// Connector receives market data\nauto connector = std::make_shared&lt;BinanceConnector&gt;(\n    registry,\n    *tradeBus,\n    *bookBus\n);\n</code></pre> <p>Executor responsibilities:</p> <ul> <li>Send orders to exchange</li> <li>Report order status updates</li> <li>Update order tracker</li> </ul> <p>Connector responsibilities:</p> <ul> <li>Connect to exchange (WebSocket, REST, FIX)</li> <li>Parse wire protocol</li> <li>Publish events to buses</li> </ul>"},{"location":"explanation/integration-flow/#4-wire-event-delivery","title":"4. Wire Event Delivery","text":"<p>Configure buses to distribute events to subscribers:</p> <pre><code>#include \"flox/strategy/istrategy.h\"\n\n// Create strategy\nauto strategy = std::make_unique&lt;MyStrategy&gt;(executor.get());\n\n// Subscribe to market data\ntradeBus-&gt;subscribe(strategy.get());\nbookBus-&gt;subscribe(strategy.get());\n\n// Subscribe to execution events\nexecBus-&gt;subscribe(strategy.get());\n\n// Add optional subscribers\ntradeBus-&gt;subscribe(logger.get(), /*optional=*/true);\ntradeBus-&gt;subscribe(metrics.get(), /*optional=*/true);\n</code></pre> <p>Subscriber types:</p> Type Behavior Required System waits for slow consumers Optional May miss events if too slow <p>Common subscribers:</p> <ul> <li>Trading strategies</li> <li>Data aggregators (bars, VWAP)</li> <li>Metric collectors</li> <li>Risk modules</li> <li>Loggers</li> </ul>"},{"location":"explanation/integration-flow/#5-launch-components","title":"5. Launch Components","text":"<p>Start components in the correct order:</p> <pre><code>#include \"flox/engine/engine.h\"\n\n// Collect all subsystems\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\nsubsystems.push_back(std::move(tradeBus));\nsubsystems.push_back(std::move(bookBus));\nsubsystems.push_back(std::move(execBus));\nsubsystems.push_back(std::move(strategy));\n\n// Collect connectors\nstd::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors;\nconnectors.push_back(connector);\n\n// Create and start engine\nEngineConfig config = loadConfig(\"config.json\");\nEngine engine(config, std::move(subsystems), std::move(connectors));\n\nengine.start();  // Blocks until shutdown signal\n</code></pre> <p>Startup sequence:</p> <ol> <li>Event buses start threads</li> <li>Connectors establish connections</li> <li>Strategies begin processing</li> <li>Executors ready to handle orders</li> </ol>"},{"location":"explanation/integration-flow/#6-handle-execution-feedback","title":"6. Handle Execution Feedback","text":"<p>When orders are submitted, the system maintains consistency:</p> <pre><code>// In your executor implementation\nvoid MyExecutor::onOrderFill(const FillMessage&amp; msg) {\n    // Update tracker\n    _orderTracker-&gt;updateOrder(msg.orderId, OrderStatus::FILLED);\n\n    // Emit event\n    OrderEvent event;\n    event.order.orderId = msg.orderId;\n    event.order.status = OrderStatus::FILLED;\n    event.order.filledQty = msg.quantity;\n    event.order.avgPrice = msg.price;\n\n    _execBus-&gt;publish(event);\n}\n</code></pre> <p>Order lifecycle:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; NEW\n    NEW --&gt; SUBMITTED: send to exchange\n    SUBMITTED --&gt; ACCEPTED: exchange confirms\n    SUBMITTED --&gt; REJECTED: validation failed\n\n    ACCEPTED --&gt; PARTIALLY_FILLED: partial execution\n    ACCEPTED --&gt; FILLED: full execution\n    ACCEPTED --&gt; PENDING_CANCEL: cancel requested\n    ACCEPTED --&gt; EXPIRED: time-in-force expired\n    ACCEPTED --&gt; REPLACED: modify accepted\n\n    PARTIALLY_FILLED --&gt; PARTIALLY_FILLED: more fills\n    PARTIALLY_FILLED --&gt; FILLED: complete\n    PARTIALLY_FILLED --&gt; PENDING_CANCEL: cancel remaining\n\n    PENDING_CANCEL --&gt; CANCELED: cancel confirmed\n\n    FILLED --&gt; [*]\n    CANCELED --&gt; [*]\n    REJECTED --&gt; [*]\n    EXPIRED --&gt; [*]</code></pre> <p>Conditional order states (stop-loss, take-profit, trailing stop):</p> <pre><code>stateDiagram-v2\n    [*] --&gt; PENDING_TRIGGER: conditional order created\n    PENDING_TRIGGER --&gt; TRIGGERED: price condition met\n    PENDING_TRIGGER --&gt; TRAILING_UPDATED: trailing stop adjusted\n    TRAILING_UPDATED --&gt; PENDING_TRIGGER: continue monitoring\n    TRIGGERED --&gt; SUBMITTED: becomes regular order</code></pre> <p>OrderEventStatus values:</p> Status Description <code>NEW</code> Order created locally <code>SUBMITTED</code> Sent to exchange <code>ACCEPTED</code> Exchange acknowledged <code>PARTIALLY_FILLED</code> Partial execution <code>FILLED</code> Fully executed <code>PENDING_CANCEL</code> Cancel request sent <code>CANCELED</code> Successfully canceled <code>EXPIRED</code> Time-in-force expired <code>REJECTED</code> Exchange rejected <code>REPLACED</code> Order modified (price/qty) <code>PENDING_TRIGGER</code> Conditional order waiting <code>TRIGGERED</code> Condition met, converting to market/limit <code>TRAILING_UPDATED</code> Trailing stop price adjusted"},{"location":"explanation/integration-flow/#7-shutdown-procedure","title":"7. Shutdown Procedure","text":"<p>Graceful shutdown ensures no data loss:</p> <pre><code>// Signal shutdown (e.g., from signal handler)\nengine.stop();\n\n// Or programmatically\nvoid gracefulShutdown() {\n    // Stop accepting new orders\n    executor-&gt;stop();\n\n    // Stop connectors (no new market data)\n    for (auto&amp; conn : connectors) {\n        conn-&gt;stop();\n    }\n\n    // Stop buses (drains queues)\n    tradeBus-&gt;stop();\n    bookBus-&gt;stop();\n    execBus-&gt;stop();\n\n    // Stop strategies\n    strategy-&gt;stop();\n}\n</code></pre> <p>Shutdown order:</p> <ol> <li>Stop connectors (no new data)</li> <li>Drain event buses</li> <li>Stop strategies</li> <li>Complete in-flight orders</li> <li>Clean up resources</li> </ol>"},{"location":"explanation/integration-flow/#complete-example","title":"Complete Example","text":"<pre><code>#include \"flox/flox.h\"\n\nint main() {\n    // 1. Registry\n    SymbolRegistry registry;\n    registry.registerSymbol(\"binance\", \"BTCUSDT\");\n\n    // 2. Core components\n    auto tradeBus = std::make_unique&lt;TradeBus&gt;();\n    auto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\n    auto execBus = std::make_unique&lt;OrderExecutionBus&gt;();\n\n    // 3. Executor and connector\n    auto executor = createExecutor(registry);\n    auto connector = createConnector(registry, *tradeBus, *bookBus);\n\n    // 4. Strategy\n    auto strategy = std::make_unique&lt;MyStrategy&gt;(executor.get());\n    tradeBus-&gt;subscribe(strategy.get());\n    bookBus-&gt;subscribe(strategy.get());\n\n    // 5. Engine\n    std::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\n    subsystems.push_back(std::move(tradeBus));\n    subsystems.push_back(std::move(bookBus));\n    subsystems.push_back(std::move(execBus));\n    subsystems.push_back(std::move(strategy));\n\n    std::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors;\n    connectors.push_back(connector);\n\n    Engine engine(loadConfig(), std::move(subsystems), std::move(connectors));\n    engine.start();\n\n    return 0;\n}\n</code></pre>"},{"location":"explanation/integration-flow/#design-principles","title":"Design Principles","text":"Principle Implementation Modularity Components can be swapped independently Thread safety Lock-free constructs in hot paths Zero allocation Pre-allocated pools and ring buffers Determinism Sync mode available for backtesting"},{"location":"explanation/integration-flow/#see-also","title":"See Also","text":"<ul> <li>Architecture \u2014 Component overview</li> <li>Run the Demo \u2014 See integration in action</li> <li>Configuration \u2014 Configure the system</li> </ul>"},{"location":"explanation/memory-model/","title":"Memory Model","text":"<p>Zero-allocation event delivery in FLOX.</p>"},{"location":"explanation/memory-model/#the-problem","title":"The Problem","text":"<p>Dynamic memory allocation is slow and unpredictable:</p> <pre><code>// This allocates memory \u2014 bad in hot path\nauto event = std::make_shared&lt;TradeEvent&gt;();\ntradeBus.publish(event);\n</code></pre> <p>Each allocation:</p> <ul> <li>May trigger system calls</li> <li>Causes unpredictable latency</li> <li>Fragments the heap</li> <li>Increases cache misses</li> </ul>"},{"location":"explanation/memory-model/#floxs-solution","title":"FLOX's Solution","text":"<p>FLOX eliminates allocations in the hot path through:</p> <ol> <li>Pre-allocated ring buffers \u2014 Events stored directly in <code>EventBus</code></li> <li>Object pools \u2014 Reusable event objects for large events</li> <li>Reference counting \u2014 Automatic lifetime management without smart pointer overhead</li> </ol>"},{"location":"explanation/memory-model/#small-events-direct-storage","title":"Small Events: Direct Storage","text":"<p>For small events like <code>TradeEvent</code>, the Disruptor stores them directly:</p> <pre><code>// EventBus internal storage\nstd::array&lt;Storage, CapacityPow2&gt; _storage{};\n\n// Publishing: placement new directly into ring buffer\n::new (slot_ptr(idx)) Event(std::forward&lt;Ev&gt;(ev));\n</code></pre> <p>No allocation happens \u2014 the event is copied into pre-allocated storage.</p>"},{"location":"explanation/memory-model/#large-events-object-pools","title":"Large Events: Object Pools","text":"<p>For large events like <code>BookUpdateEvent</code> (contains vectors of bid/ask levels), FLOX uses pools:</p> <pre><code>// Pool pre-allocates N objects at startup\npool::Pool&lt;BookUpdateEvent, 128&gt; bookPool;\n\n// Acquire returns a Handle (reference-counted smart pointer)\nauto handle = bookPool.acquire();\nif (handle) {\n  (*handle)-&gt;update.symbol = symbolId;\n  (*handle)-&gt;update.bids = {...};\n\n  // Publish the handle, not the event\n  bookBus.publish(std::move(handle));\n}\n</code></pre>"},{"location":"explanation/memory-model/#pool-design","title":"Pool Design","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         Pool&lt;T, N&gt;                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Pre-allocated slots: [T] [T] [T] [T] [T] [T] ... [T]       \u2502\n\u2502                                                              \u2502\n\u2502  Free queue: \u2192 [ptr] \u2192 [ptr] \u2192 [ptr] \u2192                      \u2502\n\u2502                                                              \u2502\n\u2502  acquire(): pop from free queue, return Handle&lt;T&gt;           \u2502\n\u2502  release(): push back to free queue                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key properties:</p> <ul> <li>All objects allocated at pool construction</li> <li><code>acquire()</code> is O(1) \u2014 pops from lock-free queue</li> <li><code>release()</code> is O(1) \u2014 pushes back</li> <li>No heap allocation during operation</li> </ul>"},{"location":"explanation/memory-model/#the-handle-class","title":"The Handle Class","text":"<p><code>pool::Handle&lt;T&gt;</code> is a reference-counted smart pointer:</p> <pre><code>template &lt;typename T&gt;\nclass Handle {\n  T* _ptr;\n\n  // Copy: increment ref count\n  Handle(const Handle&amp; other) : _ptr(other._ptr) {\n    retain(_ptr);\n  }\n\n  // Move: transfer ownership\n  Handle(Handle&amp;&amp; other) : _ptr(other._ptr) {\n    other._ptr = nullptr;\n  }\n\n  // Destructor: decrement ref count, maybe return to pool\n  ~Handle() {\n    if (_ptr &amp;&amp; _ptr-&gt;release()) {\n      _ptr-&gt;releaseToPool();  // Returns to pool when refcount hits 0\n    }\n  }\n};\n</code></pre> <p>Benefits:</p> <ul> <li>Automatic lifetime management</li> <li>Can be safely copied to multiple consumers</li> <li>Returns to pool when last reference dies</li> <li>No <code>shared_ptr</code> overhead (no control block allocation)</li> </ul>"},{"location":"explanation/memory-model/#poolablebase","title":"PoolableBase","text":"<p>Events that use pools inherit from <code>PoolableBase</code>:</p> <pre><code>struct BookUpdateEvent : public pool::PoolableBase&lt;BookUpdateEvent&gt; {\n  BookUpdate update;\n\n  void clear() {\n    update.bids.clear();\n    update.asks.clear();\n    // ... reset other fields\n  }\n};\n</code></pre> <p>The <code>clear()</code> method resets the object for reuse.</p>"},{"location":"explanation/memory-model/#event-flow-with-pools","title":"Event Flow with Pools","text":"<pre><code>sequenceDiagram\n    participant Pool\n    participant Conn as Connector\n    participant Bus as EventBus\n    participant Cons as Consumer\n\n    Note over Pool: Pre-allocated objects\n\n    Conn-&gt;&gt;Pool: acquire()\n    Pool--&gt;&gt;Conn: Handle (refcount=1)\n\n    Note over Conn: Populate event data\n\n    Conn-&gt;&gt;Bus: publish(move(handle))\n    Note over Bus: refcount=1\n\n    Bus-&gt;&gt;Cons: dispatch(handle)\n    Note over Cons: refcount=2 (copied)\n\n    Cons--&gt;&gt;Bus: callback returns\n    Note over Bus: refcount=1\n\n    Bus-&gt;&gt;Bus: slot reclaimed\n    Note over Bus: refcount=0\n\n    Bus-&gt;&gt;Pool: releaseToPool()\n    Note over Pool: Object ready for reuse</code></pre> <p>Text representation: <pre><code>Pool \u2192 Connector (acquire) \u2192 EventBus (publish) \u2192 Consumer (dispatch) \u2192 Pool (release)\n</code></pre></p>"},{"location":"explanation/memory-model/#pmr-polymorphic-memory-resources","title":"PMR (Polymorphic Memory Resources)","text":"<p>For events with variable-size data (like vectors), FLOX uses PMR:</p> <pre><code>// In Pool constructor\nstd::array&lt;std::byte, 128 * 1024&gt; _buffer;         // Stack buffer\nstd::pmr::monotonic_buffer_resource _arena;        // Fast bump allocator\nstd::pmr::unsynchronized_pool_resource _pool;      // Pool allocator\n</code></pre> <p>When <code>BookUpdateEvent</code> allocates vectors for bids/asks:</p> <ol> <li>Memory comes from the pre-allocated buffer</li> <li><code>monotonic_buffer_resource</code> provides fast bump-pointer allocation</li> <li>No system calls, no heap fragmentation</li> </ol>"},{"location":"explanation/memory-model/#refcountable-interface","title":"RefCountable Interface","text":"<pre><code>class RefCountable {\n  std::atomic&lt;uint32_t&gt; _refCount{1};\n\npublic:\n  void retain() {\n    _refCount.fetch_add(1, std::memory_order_relaxed);\n  }\n\n  bool release() {\n    return _refCount.fetch_sub(1, std::memory_order_acq_rel) == 1;\n  }\n\n  void resetRefCount() {\n    _refCount.store(1, std::memory_order_relaxed);\n  }\n};\n</code></pre> <p>Atomic operations ensure thread safety across bus consumers.</p>"},{"location":"explanation/memory-model/#best-practices","title":"Best Practices","text":""},{"location":"explanation/memory-model/#do","title":"Do","text":"<pre><code>// Acquire from pool, move into bus\nif (auto handle = bookPool.acquire()) {\n  (*handle)-&gt;update = buildUpdate();\n  bookBus.publish(std::move(handle));\n}\n\n// Handle pool exhaustion\nif (!handle) {\n  // Log warning, skip event, or use fallback\n}\n</code></pre>"},{"location":"explanation/memory-model/#dont","title":"Don't","text":"<pre><code>// Don't hold handles longer than necessary\npool::Handle&lt;BookUpdateEvent&gt; cachedHandle;  // Bad: blocks pool slot\n\n// Don't allocate in callbacks\nvoid onTrade(const TradeEvent&amp; ev) {\n  auto data = std::make_unique&lt;BigData&gt;();  // Bad: allocation in hot path\n}\n\n// Don't store event pointers\nvoid onBookUpdate(const BookUpdateEvent&amp; ev) {\n  _cachedEvent = &amp;ev;  // Bad: event will be recycled\n}\n</code></pre>"},{"location":"explanation/memory-model/#sizing-pools","title":"Sizing Pools","text":"<p>Pool size = max concurrent uses + headroom:</p> <pre><code>// If 3 consumers each take ~10ms to process, and events arrive at 1000/sec:\n// In-flight events \u2248 3 consumers \u00d7 10ms \u00d7 1000/sec = 30\n// Add headroom: 64 or 128\n\npool::Pool&lt;BookUpdateEvent, 128&gt; bookPool;\n</code></pre> <p>Signs your pool is too small:</p> <ul> <li><code>acquire()</code> returns <code>nullopt</code></li> <li>High latency spikes</li> <li>Dropped events</li> </ul>"},{"location":"explanation/memory-model/#memory-layout","title":"Memory Layout","text":"<p>FLOX optimizes for cache efficiency:</p> <pre><code>// Cache-line aligned atomics\nalignas(64) std::atomic&lt;int64_t&gt; _next{-1};\n\n// Contiguous event storage\nstd::array&lt;Storage, CapacityPow2&gt; _storage{};\n</code></pre> <p>This ensures:</p> <ul> <li>No false sharing between atomics</li> <li>Sequential access patterns for events</li> <li>Minimal cache misses</li> </ul>"},{"location":"explanation/memory-model/#summary","title":"Summary","text":"Component Strategy Allocation <code>TradeBus</code> Direct storage Zero (ring buffer) <code>BookUpdateBus</code> Pool + Handle Zero (pre-allocated) Small events Copy into bus Zero Large events Pool acquire/release Zero (at runtime) Event vectors PMR Zero (from buffer)"},{"location":"explanation/memory-model/#next-steps","title":"Next Steps","text":"<ul> <li>The Disruptor Pattern \u2014 How the ring buffer works</li> <li>Optimize Performance \u2014 Tune for latency</li> </ul>"},{"location":"how-to/","title":"How-To Guides","text":"<p>Solve specific problems. Assumes you know the basics.</p>"},{"location":"how-to/#available-guides","title":"Available Guides","text":"Guide Problem Bar Aggregation Pre-aggregate bars for fast backtesting Backtesting Run strategy backtests on historical data Grid Search Find optimal strategy parameters CPU Affinity Pin threads to isolated cores for lower latency Custom Connector Connect to a new exchange Custom Bar Policy Create custom bar aggregation policies Advanced Orders Use stop-loss, take-profit, brackets Multi-Exchange Trading Trade across multiple exchanges with aggregation and routing Optimize Performance Tune for minimum latency Configuration Runtime configuration options CI Configuration Understand the CI pipeline Contributing Contribute to FLOX development"},{"location":"how-to/#prerequisites","title":"Prerequisites","text":"<p>These guides assume you've completed the Tutorials and understand basic FLOX concepts.</p>"},{"location":"how-to/advanced-orders/","title":"Advanced Orders","text":"<p>This guide covers the advanced order types available in FLOX, including conditional orders, OCO, and execution flags.</p>"},{"location":"how-to/advanced-orders/#order-types-overview","title":"Order Types Overview","text":"Type Use Case <code>STOP_MARKET</code> Stop loss, breakout entry <code>STOP_LIMIT</code> Stop with price control <code>TAKE_PROFIT_MARKET</code> Lock in profits <code>TAKE_PROFIT_LIMIT</code> Lock in profits with price control <code>TRAILING_STOP</code> Dynamic stop that follows price <code>OCO</code> One-Cancels-Other for breakouts"},{"location":"how-to/advanced-orders/#using-signal-factory-methods","title":"Using Signal Factory Methods","text":""},{"location":"how-to/advanced-orders/#stop-orders","title":"Stop Orders","text":"<pre><code>// Stop market - triggers market order when price crosses trigger\nemitStopMarket(symbol, Side::SELL, Price::fromDouble(95.0), qty);\n\n// Stop limit - triggers limit order when price crosses trigger\nemitStopLimit(symbol, Side::SELL,\n              Price::fromDouble(95.0),   // trigger\n              Price::fromDouble(94.5),   // limit price\n              qty);\n</code></pre> <p>Stop trigger logic:</p> <ul> <li>SELL stop: triggers when price &lt;= triggerPrice (falling)</li> <li>BUY stop: triggers when price &gt;= triggerPrice (rising)</li> </ul>"},{"location":"how-to/advanced-orders/#take-profit-orders","title":"Take Profit Orders","text":"<pre><code>// Take profit market - exits position at profit target\nemitTakeProfitMarket(symbol, Side::SELL, Price::fromDouble(110.0), qty);\n\n// Take profit limit\nemitTakeProfitLimit(symbol, Side::SELL,\n                    Price::fromDouble(110.0),  // trigger\n                    Price::fromDouble(109.5),  // limit price\n                    qty);\n</code></pre> <p>Take profit trigger logic:</p> <ul> <li>SELL TP: triggers when price &gt;= triggerPrice (rising, lock profit on long)</li> <li>BUY TP: triggers when price &lt;= triggerPrice (falling, lock profit on short)</li> </ul>"},{"location":"how-to/advanced-orders/#trailing-stop","title":"Trailing Stop","text":"<pre><code>// Fixed offset trailing stop (follows price by 5.0)\nemitTrailingStop(symbol, Side::SELL, Price::fromDouble(5.0), qty);\n\n// Percentage trailing stop (follows price by 2%)\nemitTrailingStopPercent(symbol, Side::SELL, 200, qty);  // 200 bps = 2%\n</code></pre> <p>Trailing stop behavior:</p> <ul> <li>SELL trailing: trigger follows price UP (never down)</li> <li>When price drops to trigger -&gt; order executes</li> </ul>"},{"location":"how-to/advanced-orders/#time-in-force-options","title":"Time-In-Force Options","text":"<pre><code>// IOC (Immediate-Or-Cancel) - fill immediately or cancel\nemitLimitBuy(symbol, price, qty, TimeInForce::IOC);\n\n// FOK (Fill-Or-Kill) - fill completely or reject\nemitLimitBuy(symbol, price, qty, TimeInForce::FOK);\n\n// POST_ONLY - maker only, reject if would take\nemitLimitBuy(symbol, price, qty, TimeInForce::POST_ONLY);\n</code></pre>"},{"location":"how-to/advanced-orders/#execution-flags","title":"Execution Flags","text":""},{"location":"how-to/advanced-orders/#using-signal-modifiers","title":"Using Signal Modifiers","text":"<pre><code>auto signal = Signal::limitBuy(symbol, price, qty, orderId)\n                  .withTimeInForce(TimeInForce::IOC)\n                  .withReduceOnly()\n                  .withPostOnly();\nemit(signal);\n</code></pre>"},{"location":"how-to/advanced-orders/#close-position","title":"Close Position","text":"<pre><code>// Close entire position with reduce-only market order\nemitClosePosition(symbol);\n</code></pre>"},{"location":"how-to/advanced-orders/#checking-exchange-capabilities","title":"Checking Exchange Capabilities","text":"<p>Before using advanced features, check if they're supported:</p> <pre><code>void MyStrategy::onStart() {\n  auto caps = engine().executor().capabilities();\n\n  _useTrailingStop = caps.supports(OrderType::TRAILING_STOP);\n  _useOCO = caps.supportsOCO;\n\n  if (!_useTrailingStop) {\n    log().warn(\"Trailing stop not supported, using manual logic\");\n  }\n}\n</code></pre>"},{"location":"how-to/advanced-orders/#example-manual-tpsl-management","title":"Example: Manual TP/SL Management","text":"<p>Since strategies have full control over order lifecycle, you can implement custom TP/SL logic:</p> <pre><code>void onOrderFilled(const Order&amp; entryOrder) {\n  if (entryOrder.id == _entryOrderId) {\n    Price entryPrice = entryOrder.price;\n\n    // Place TP\n    _tpOrderId = emitTakeProfitMarket(\n        entryOrder.symbol, Side::SELL,\n        Price::fromDouble(entryPrice.toDouble() * 1.06), // 6% profit\n        entryOrder.quantity);\n\n    // Place SL\n    _slOrderId = emitStopMarket(\n        entryOrder.symbol, Side::SELL,\n        Price::fromDouble(entryPrice.toDouble() * 0.98), // 2% stop\n        entryOrder.quantity);\n  }\n\n  // When TP fills, cancel SL\n  if (entryOrder.id == _tpOrderId) {\n    emitCancel(_slOrderId);\n  }\n\n  // When SL fills, cancel TP\n  if (entryOrder.id == _slOrderId) {\n    emitCancel(_tpOrderId);\n  }\n}\n</code></pre>"},{"location":"how-to/advanced-orders/#example-trailing-stop-for-profit-protection","title":"Example: Trailing Stop for Profit Protection","text":"<pre><code>void onOrderFilled(const Order&amp; order) {\n  if (order.side == Side::BUY) {\n    // Place trailing stop to protect profits\n    emitTrailingStopPercent(order.symbol, Side::SELL, 300, order.quantity);\n  }\n}\n</code></pre>"},{"location":"how-to/advanced-orders/#see-also","title":"See Also","text":"<ul> <li>Order Types</li> <li>Time-In-Force</li> <li>Order Structure</li> <li>Exchange Capabilities</li> </ul>"},{"location":"how-to/backtest/","title":"Running a Backtest","text":"<p>Complete example of backtesting an SMA crossover strategy.</p>"},{"location":"how-to/backtest/#build","title":"Build","text":"<p>Enable the backtest module:</p> <pre><code>cmake .. -DFLOX_ENABLE_BACKTEST=ON\nmake -j$(nproc)\n</code></pre>"},{"location":"how-to/backtest/#strategy","title":"Strategy","text":"<pre><code>#include \"flox/backtest/backtest_runner.h\"\n#include \"flox/book/events/trade_event.h\"\n#include \"flox/engine/symbol_registry.h\"\n#include \"flox/replay/abstract_event_reader.h\"\n#include \"flox/strategy/strategy.h\"\n\n#include &lt;deque&gt;\n\nusing namespace flox;\n\nclass SmaCrossover : public Strategy\n{\npublic:\n  SmaCrossover(SymbolId symbol, size_t fast, size_t slow, Quantity size,\n               const SymbolRegistry&amp; registry)\n      : Strategy(1, symbol, registry), _fast(fast), _slow(slow), _size(size) {}\n\n  void start() override { _running = true; }\n  void stop() override { _running = false; }\n\nprotected:\n  void onSymbolTrade(SymbolContext&amp; ctx, const TradeEvent&amp; ev) override\n  {\n    if (!_running)\n      return;\n\n    _prices.push_back(ev.trade.price.toDouble());\n    if (_prices.size() &gt; _slow)\n      _prices.pop_front();\n\n    if (_prices.size() &lt; _slow)\n      return;\n\n    double fast_sma = sma(_fast);\n    double slow_sma = sma(_slow);\n    bool above = fast_sma &gt; slow_sma;\n\n    if (above &amp;&amp; !_prev_above &amp;&amp; !_long)\n    {\n      if (_short) { emitMarketBuy(symbol(), _size); _short = false; }\n      emitMarketBuy(symbol(), _size);\n      _long = true;\n    }\n    else if (!above &amp;&amp; _prev_above &amp;&amp; !_short)\n    {\n      if (_long) { emitMarketSell(symbol(), _size); _long = false; }\n      emitMarketSell(symbol(), _size);\n      _short = true;\n    }\n\n    _prev_above = above;\n  }\n\nprivate:\n  double sma(size_t n) const\n  {\n    double sum = 0;\n    auto it = _prices.end();\n    for (size_t i = 0; i &lt; n; ++i)\n      sum += *--it;\n    return sum / n;\n  }\n\n  size_t _fast, _slow;\n  Quantity _size;\n  std::deque&lt;double&gt; _prices;\n  bool _running{false}, _prev_above{false}, _long{false}, _short{false};\n};\n</code></pre>"},{"location":"how-to/backtest/#main","title":"Main","text":"<pre><code>int main(int argc, char* argv[])\n{\n  if (argc &lt; 2)\n  {\n    std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;data_dir&gt; [symbol_id]\\n\";\n    return 1;\n  }\n\n  std::filesystem::path data_dir = argv[1];\n  uint32_t symbol_id = (argc &gt; 2) ? std::stoul(argv[2]) : 1;\n\n  // Load data\n  replay::ReaderFilter filter;\n  filter.symbols = {symbol_id};\n  auto reader = replay::createMultiSegmentReader(data_dir, filter);\n\n  // Configure backtest\n  BacktestConfig config;\n  config.initialCapital = 10000.0;\n  config.feeRate = 0.0004;  // 0.04% taker fee\n\n  BacktestRunner runner(config);\n\n  // Create registry and register symbol\n  SymbolRegistry registry;\n  SymbolInfo info;\n  info.exchange = \"EXCHANGE\";\n  info.symbol = \"SYMBOL\";\n  info.tickSize = Price::fromDouble(0.01);\n  registry.registerSymbol(info);\n\n  // Create strategy\n  SmaCrossover strategy(symbol_id, 10, 20, Quantity::fromDouble(1.0), registry);\n  runner.setStrategy(&amp;strategy);\n\n  // Run\n  BacktestResult result = runner.run(*reader);\n  auto stats = result.computeStats();\n\n  // Output\n  std::cout &lt;&lt; \"Initial: \" &lt;&lt; stats.initialCapital &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Final:   \" &lt;&lt; stats.finalCapital &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Return:  \" &lt;&lt; stats.returnPct &lt;&lt; \"%\\n\";\n  std::cout &lt;&lt; \"Trades:  \" &lt;&lt; stats.totalTrades &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Win rate: \" &lt;&lt; stats.winRate * 100 &lt;&lt; \"%\\n\";\n  std::cout &lt;&lt; \"Sharpe:  \" &lt;&lt; stats.sharpeRatio &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Max DD:  \" &lt;&lt; stats.maxDrawdownPct &lt;&lt; \"%\\n\";\n\n  return 0;\n}\n</code></pre>"},{"location":"how-to/backtest/#output-example","title":"Output Example","text":"<pre><code>Initial: 10000\nFinal:   10245.3\nReturn:  2.453%\nTrades:  47\nWin rate: 51.0638%\nSharpe:  1.23\nMax DD:  3.21%\n</code></pre>"},{"location":"how-to/backtest/#mmap-based-backtesting","title":"Mmap-Based Backtesting","text":"<p>For faster backtests with pre-aggregated bars, use <code>MmapBarStorage</code>:</p> <pre><code>#include \"flox/backtest/mmap_bar_storage.h\"\n#include \"flox/backtest/mmap_bar_replay_source.h\"\n\n// Load pre-aggregated bars\nMmapBarStorage storage(\"/data/BTCUSDT/bars\");\n\n// Create replay source\nMmapBarReplaySource source(storage, symbol_id);\n\n// Replay bars through your strategy\nsource.replay([&amp;](const BarEvent&amp; ev) {\n  strategy.onBar(ev);\n});\n</code></pre> <p>Pre-aggregate bars offline using <code>preagg_bars</code>:</p> <pre><code>./preagg_bars /data/raw /data/bars 60 300 900 3600\n</code></pre>"},{"location":"how-to/backtest/#see-also","title":"See Also","text":"<ul> <li>Grid Search Optimization \u2014 parameter optimization</li> <li>Bar Aggregation Pipeline \u2014 pre-aggregating bars</li> <li>Interactive Mode \u2014 step-by-step execution</li> </ul>"},{"location":"how-to/bar-aggregation/","title":"Bar Aggregation Pipeline","text":"<p>This guide covers the complete workflow for working with bars in Flox: from raw market data to pre-aggregated bars for backtesting.</p>"},{"location":"how-to/bar-aggregation/#overview","title":"Overview","text":"<p>The bar pipeline consists of several stages:</p> <pre><code>flowchart TB\n    subgraph Recording\n        RD[Raw Data&lt;br/&gt;trades/books] --&gt; BLW[BinaryLogWriter]\n        BLW --&gt; FLX[.floxlog files&lt;br/&gt;raw data]\n    end\n\n    subgraph Aggregation\n        FLX --&gt; BA[BarAggregator&lt;br/&gt;+ preagg_bars]\n        BA --&gt; MBW[MmapBarWriter&lt;br/&gt;write bars]\n        MBW --&gt; MBS[MmapBarStorage&lt;br/&gt;read bars]\n    end\n\n    subgraph Backtesting\n        MBS --&gt; MBRS[MmapBarReplaySource]\n        MBRS --&gt; STR[Your Strategy]\n    end</code></pre>"},{"location":"how-to/bar-aggregation/#step-1-record-raw-market-data","title":"Step 1: Record Raw Market Data","text":"<p>Use <code>BinaryLogWriter</code> to record trades and order book updates:</p> <pre><code>#include \"flox/replay/writers/binary_log_writer.h\"\n\nreplay::WriterConfig config;\nconfig.output_dir = \"/data/bybit/BTCUSDT\";\nconfig.max_segment_bytes = 256 &lt;&lt; 20;  // 256 MB per segment\n\nreplay::BinaryLogWriter writer(config);\n\n// From your exchange connector:\nwriter.writeTrade(tradeRecord);\nwriter.writeBook(bookHeader, bids, asks);\n\nwriter.close();\n</code></pre>"},{"location":"how-to/bar-aggregation/#step-2-pre-aggregate-bars-offline","title":"Step 2: Pre-aggregate Bars (Offline)","text":"<p>Use the <code>preagg_bars</code> tool to convert raw trades into bar files:</p> <pre><code># Build with tools enabled\ncmake -B build -DFLOX_ENABLE_TOOLS=ON -DFLOX_ENABLE_BACKTEST=ON\ncmake --build build\n\n# Run pre-aggregation\n./build/tools/preagg_bars /data/bybit/BTCUSDT /data/bybit/BTCUSDT/bars 60 300 900 3600\n\n# Output:\n#   bars_60s.bin   (1-minute bars)\n#   bars_300s.bin  (5-minute bars)\n#   bars_900s.bin  (15-minute bars)\n#   bars_3600s.bin (1-hour bars)\n</code></pre>"},{"location":"how-to/bar-aggregation/#command-line-options","title":"Command-Line Options","text":"<pre><code>Usage: preagg_bars &lt;input_dir&gt; &lt;output_dir&gt; [timeframe_seconds...]\n\nArguments:\n  input_dir   Directory containing binary log files (.floxlog)\n  output_dir  Directory to write bar files (will be created)\n  timeframes  List of timeframe intervals in seconds (default: 60 300 900 3600)\n\nExamples:\n  preagg_bars data/BTCUSDT bars/BTCUSDT 60 300 900\n  preagg_bars /path/to/trades /path/to/bars 60 300 900 1800 3600\n</code></pre>"},{"location":"how-to/bar-aggregation/#step-3-load-bars-for-backtesting","title":"Step 3: Load Bars for Backtesting","text":"<p>Use <code>MmapBarStorage</code> to memory-map bar files for fast access:</p> <pre><code>#include \"flox/backtest/mmap_bar_storage.h\"\n#include \"flox/backtest/mmap_bar_replay_source.h\"\n\n// Load bars\nMmapBarStorage storage(\"/data/bybit/BTCUSDT/bars\");\n\n// Check available timeframes\nfor (auto tf : storage.timeframes()) {\n    std::cout &lt;&lt; \"Timeframe: \" &lt;&lt; (tf.param / 1'000'000'000) &lt;&lt; \"s, \"\n              &lt;&lt; storage.barCount(tf) &lt;&lt; \" bars\\n\";\n}\n\n// Get bars directly\nauto tf1m = TimeframeId::time(std::chrono::seconds(60));\nauto bars = storage.getBars(tf1m);  // std::span&lt;const Bar&gt;\n\n// Or use replay source for backtesting\nMmapBarReplaySource replaySource(storage, symbolId);\nreplaySource.replay([&amp;](const BarEvent&amp; ev) {\n    myStrategy.onBar(ev);\n});\n</code></pre>"},{"location":"how-to/bar-aggregation/#alternative-live-bar-aggregation","title":"Alternative: Live Bar Aggregation","text":"<p>For real-time bar generation with persistence:</p> <pre><code>#include \"flox/aggregator/multi_timeframe_aggregator.h\"\n#include \"flox/backtest/mmap_bar_writer.h\"\n\nBarBus bus;\nMultiTimeframeAggregator&lt;4&gt; aggregator(&amp;bus);\n\n// Configure timeframes\naggregator.addTimeInterval(std::chrono::seconds(60));   // 1m\naggregator.addTimeInterval(std::chrono::seconds(300));  // 5m\naggregator.addTimeInterval(std::chrono::seconds(900));  // 15m\naggregator.addTimeInterval(std::chrono::seconds(3600)); // 1h\n\n// Writer saves bars to disk\nMmapBarWriter writer(\"/data/bybit/BTCUSDT/bars\");\nbus.subscribe(&amp;writer);\n\n// Start aggregation\naggregator.start();\n\n// Feed trades from your connector\naggregator.onTrade(tradeEvent);\n// ...\n\n// Flush to disk\nwriter.flush();\n</code></pre>"},{"location":"how-to/bar-aggregation/#bar-file-format","title":"Bar File Format","text":"<p>Bar files use a simple binary format compatible with memory mapping:</p> <pre><code>[uint64_t]  bar_count\n[Bar \u00d7 N]   bar data\n</code></pre> <p>Each <code>Bar</code> struct contains: - <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code> - OHLC prices - <code>volume</code>, <code>buyVolume</code> - Volume data - <code>tradeCount</code> - Number of trades - <code>startTime</code>, <code>endTime</code> - Time range - <code>reason</code> - Close reason (Threshold, Gap, Forced, Warmup)</p> <p>File naming convention: <code>bars_&lt;seconds&gt;s.bin</code> (e.g., <code>bars_60s.bin</code> for 1-minute bars)</p>"},{"location":"how-to/bar-aggregation/#available-bar-types","title":"Available Bar Types","text":"<p>Flox supports multiple bar types through different policies:</p> Type Parameter Description Time interval in seconds Close bar every N seconds Tick count Close bar after N trades Volume threshold Close bar when volume exceeds threshold Renko brick size Fixed price movement bars Range range Close when high-low exceeds range HeikinAshi interval Heikin-Ashi smoothed bars <p>Example with tick bars:</p> <pre><code>aggregator.addTickInterval(100);   // 100-trade bars\naggregator.addVolumeInterval(1000000);  // 1M volume bars\n</code></pre>"},{"location":"how-to/bar-aggregation/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Use mmap for large datasets - <code>MmapBarStorage</code> memory-maps files, allowing the OS to manage memory efficiently.</p> </li> <li> <p>Pre-aggregate offline - Use <code>preagg_bars</code> instead of aggregating during backtest for faster iteration.</p> </li> <li> <p>Choose appropriate timeframes - Smaller timeframes = more bars = more processing.</p> </li> <li> <p>Batch flush writes - <code>MmapBarWriter</code> buffers bars in memory; call <code>flush()</code> periodically for durability.</p> </li> </ol>"},{"location":"how-to/ci/","title":"Continuous Integration","text":"<p>FLOX uses GitHub Actions for continuous integration. The CI pipeline runs on every push and pull request to ensure code quality and cross-platform compatibility.</p>"},{"location":"how-to/ci/#ci-matrix","title":"CI Matrix","text":"Job Platform Compiler Build Type Description <code>format-check</code> Ubuntu - - Validates code formatting with clang-format <code>linux-gcc</code> Ubuntu 24.04 GCC 14 Release Main Linux build <code>linux-clang</code> Ubuntu 24.04 Clang 18 + libc++ Release Clang with libc++ standard library <code>sanitizers</code> Ubuntu 24.04 GCC 14 Debug ASan and UBSan for memory/UB detection <code>macos</code> macOS latest Apple Clang Release macOS compatibility <code>windows-msvc</code> Windows latest MSVC Release Windows with MSVC toolchain <code>windows-clang-cl</code> Windows latest Clang-CL Release Windows with Clang frontend <code>affinity-tests</code> Ubuntu 24.04 GCC 14 Release Weekly CPU affinity tests (scheduled)"},{"location":"how-to/ci/#build-configuration","title":"Build Configuration","text":"<p>All builds use Release mode only. Debug builds are intentionally excluded because:</p> <ol> <li>Sanitizers (ASan, UBSan) catch memory and undefined behavior issues better than Debug assertions</li> <li>Release mode tests the actual production code path</li> <li>Reduces CI time and resource usage</li> </ol>"},{"location":"how-to/ci/#sanitizers","title":"Sanitizers","text":"<p>The <code>sanitizers</code> job runs with both AddressSanitizer and UndefinedBehaviorSanitizer:</p> <pre><code>matrix:\n  sanitizer: [address, undefined]\n</code></pre> Sanitizer Detects AddressSanitizer Buffer overflows, use-after-free, memory leaks UndefinedBehaviorSanitizer Signed overflow, null pointer dereference, alignment issues <p>Sanitizer options:</p> <pre><code>ASAN_OPTIONS: detect_leaks=1:abort_on_error=1\nUBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1\n</code></pre>"},{"location":"how-to/ci/#weekly-affinity-tests","title":"Weekly Affinity Tests","text":"<p>CPU affinity tests run weekly (Sunday 3:00 UTC) because:</p> <ul> <li>Require <code>libnuma-dev</code> which isn't available on all platforms</li> <li>GitHub runners don't have isolated cores for reliable affinity testing</li> <li>Tests verify the affinity API works, not that it improves performance</li> </ul>"},{"location":"how-to/ci/#running-ci-locally","title":"Running CI Locally","text":""},{"location":"how-to/ci/#format-check","title":"Format Check","text":"<pre><code>./scripts/check-format.sh\n</code></pre>"},{"location":"how-to/ci/#build-with-gcc","title":"Build with GCC","text":"<pre><code>cmake -B build -G Ninja \\\n  -DCMAKE_CXX_COMPILER=g++-14 \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  -DFLOX_ENABLE_TESTS=ON \\\n  -DFLOX_ENABLE_BENCHMARKS=ON \\\n  -DFLOX_ENABLE_DEMO=ON \\\n  -DFLOX_ENABLE_LZ4=ON \\\n  -DFLOX_ENABLE_BACKTEST=ON\n\ncmake --build build -j$(nproc)\nctest --output-on-failure --test-dir build\n</code></pre>"},{"location":"how-to/ci/#build-with-sanitizers","title":"Build with Sanitizers","text":"<pre><code>cmake -B build -G Ninja \\\n  -DCMAKE_CXX_COMPILER=g++-14 \\\n  -DCMAKE_CXX_FLAGS=\"-fsanitize=address -fno-omit-frame-pointer -g\" \\\n  -DCMAKE_EXE_LINKER_FLAGS=\"-fsanitize=address\" \\\n  -DCMAKE_BUILD_TYPE=Debug \\\n  -DFLOX_ENABLE_TESTS=ON\n\ncmake --build build\nASAN_OPTIONS=detect_leaks=1:abort_on_error=1 ctest --output-on-failure --test-dir build\n</code></pre>"},{"location":"how-to/ci/#dependencies","title":"Dependencies","text":""},{"location":"how-to/ci/#ubuntu","title":"Ubuntu","text":"<pre><code>sudo apt-get install cmake ninja-build liblz4-dev g++-14\n</code></pre>"},{"location":"how-to/ci/#macos","title":"macOS","text":"<pre><code>brew install cmake ninja lz4\n</code></pre>"},{"location":"how-to/ci/#windows","title":"Windows","text":"<p>Uses vcpkg for dependencies:</p> <pre><code>vcpkg install lz4:x64-windows gtest:x64-windows benchmark:x64-windows\n</code></pre>"},{"location":"how-to/ci/#see-also","title":"See Also","text":"<ul> <li>Configuration - Runtime configuration</li> </ul>"},{"location":"how-to/configuration/","title":"Configuration","text":"<p>FLOX is configured via the <code>EngineConfig</code> structure, typically loaded from a JSON file or embedded configuration source.</p>"},{"location":"how-to/configuration/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"logLevel\": \"debug\",\n  \"exchanges\": [\n    {\n      \"name\": \"bybit\",\n      \"type\": \"mock\",\n      \"symbols\": [\n        { \"symbol\": \"DOTUSDT\", \"tickSize\": 0.001, \"expectedDeviation\": 0.5 }\n      ]\n    }\n  ],\n  \"killSwitchConfig\": {\n    \"maxOrderQty\": 10000,\n    \"maxLoss\": -5000,\n    \"maxOrdersPerSecond\": 100\n  }\n}\n</code></pre>"},{"location":"how-to/configuration/#configuration-fields","title":"Configuration Fields","text":""},{"location":"how-to/configuration/#loglevel","title":"<code>logLevel</code>","text":"<p>Controls runtime logging verbosity.</p> Value Description <code>debug</code> All messages including debug info <code>info</code> Informational messages and above <code>warn</code> Warnings and errors only <code>error</code> Errors only"},{"location":"how-to/configuration/#exchanges","title":"<code>exchanges[]</code>","text":"<p>Defines which exchange connectors to start and which symbols to subscribe to.</p> Field Type Description <code>name</code> string Display label or unique ID for internal routing <code>type</code> string Used by <code>ConnectorFactory</code> to instantiate the appropriate connector <code>symbols[]</code> array List of symbol configs"},{"location":"how-to/configuration/#symbol-configuration","title":"Symbol Configuration","text":"Field Type Description <code>symbol</code> string Trading pair (e.g., \"BTCUSDT\") <code>tickSize</code> number Minimum price increment <code>expectedDeviation</code> number Allowed price deviation for validation"},{"location":"how-to/configuration/#killswitchconfig","title":"<code>killSwitchConfig</code>","text":"<p>Defines runtime shutdown thresholds:</p> Field Type Default Description <code>maxOrderQty</code> number 10000 Maximum order size allowed per submission <code>maxLoss</code> number -1000000 Hard limit on realized/unrealized loss (negative) <code>maxOrdersPerSecond</code> number -1 Rate limit for outbound orders (<code>-1</code> disables)"},{"location":"how-to/configuration/#logfile","title":"<code>logFile</code>","text":"<p>Optional path to log file. If not set, logs go to stdout only.</p> <pre><code>{\n  \"logFile\": \"/var/log/flox/engine.log\"\n}\n</code></pre>"},{"location":"how-to/configuration/#draintimeoutms","title":"<code>drainTimeoutMs</code>","text":"<p>Timeout in milliseconds for draining in-flight orders on shutdown. Default: <code>5000</code>.</p>"},{"location":"how-to/configuration/#loading-configuration","title":"Loading Configuration","text":""},{"location":"how-to/configuration/#from-json-file","title":"From JSON File","text":"<pre><code>#include \"flox/engine/engine_config.h\"\n#include &lt;fstream&gt;\n\nEngineConfig loadConfig(const std::string&amp; path) {\n    std::ifstream file(path);\n    nlohmann::json j;\n    file &gt;&gt; j;\n    return j.get&lt;EngineConfig&gt;();\n}\n\nint main() {\n    auto config = loadConfig(\"config.json\");\n    Engine engine(config, subsystems, connectors);\n    engine.start();\n}\n</code></pre>"},{"location":"how-to/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code>EngineConfig config;\nconfig.logLevel = LogLevel::INFO;\n\nExchangeConfig exchange;\nexchange.name = \"binance\";\nexchange.type = \"binance_futures\";\n\nSymbolConfig symbol;\nsymbol.symbol = \"BTCUSDT\";\nsymbol.tickSize = 0.1;\nconfig.exchanges.push_back(exchange);\n\nconfig.killSwitchConfig.maxOrderQty = 10000;\nconfig.killSwitchConfig.maxLoss = -5000;\nconfig.killSwitchConfig.maxOrdersPerSecond = 100;\n</code></pre>"},{"location":"how-to/configuration/#symbol-registration","title":"Symbol Registration","text":"<p><code>SymbolId</code> is derived automatically from <code>(exchange, symbol)</code> during engine startup:</p> <pre><code>// During startup, the engine registers symbols\nfor (const auto&amp; exchange : config.exchanges) {\n    for (const auto&amp; sym : exchange.symbols) {\n        auto symbolId = registry.registerSymbol(exchange.name, sym.symbol);\n        // symbolId is now available for use throughout the system\n    }\n}\n</code></pre>"},{"location":"how-to/configuration/#environment-variables","title":"Environment Variables","text":"<p>Some settings can be overridden via environment variables:</p> Variable Description <code>FLOX_LOG_LEVEL</code> Override log level <code>FLOX_CONFIG_PATH</code> Default config file path"},{"location":"how-to/configuration/#validation","title":"Validation","text":"<p>Configuration is validated at startup:</p> <pre><code>void validateConfig(const EngineConfig&amp; config) {\n    if (config.exchanges.empty()) {\n        throw std::invalid_argument(\"At least one exchange required\");\n    }\n\n    for (const auto&amp; ex : config.exchanges) {\n        if (ex.symbols.empty()) {\n            throw std::invalid_argument(\"Exchange must have symbols\");\n        }\n        for (const auto&amp; sym : ex.symbols) {\n            if (sym.tickSize &lt;= 0) {\n                throw std::invalid_argument(\"tickSize must be positive\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"how-to/configuration/#notes","title":"Notes","text":"<ul> <li>Tick size and deviation are used by validators and order book alignment</li> <li>All configuration is immutable after startup for safety and determinism</li> <li>Use different config files for development, testing, and production</li> </ul>"},{"location":"how-to/configuration/#see-also","title":"See Also","text":"<ul> <li>Quickstart \u2014 Build and run FLOX</li> <li>Run the Demo \u2014 See configuration in action</li> <li>Architecture \u2014 How config affects components</li> </ul>"},{"location":"how-to/contributing/","title":"Contributing","text":"<p>Guidelines for contributing to FLOX.</p>"},{"location":"how-to/contributing/#code-style","title":"Code Style","text":"<p>A <code>.clang-format</code> file is provided in the repository. All C++ code must be formatted before committing.</p>"},{"location":"how-to/contributing/#clang-format-setup","title":"clang-format Setup","text":"<p>Install clang-format 18.x:</p> <pre><code>sudo apt install -y wget gnupg lsb-release software-properties-common\nwget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt install -y clang-format-18\nsudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-18 100\n</code></pre>"},{"location":"how-to/contributing/#pre-commit-hook","title":"Pre-commit Hook","text":"<p>A <code>pre-commit</code> hook is installed automatically during CMake configuration. It formats all changed <code>.cpp</code> and <code>.h</code> files before each commit.</p> <p>To install manually:</p> <pre><code>cp scripts/pre-commit .git/hooks/pre-commit\nchmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"how-to/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch from <code>main</code></li> <li>Make your changes</li> <li>Ensure code is formatted (<code>clang-format</code>)</li> <li>Add tests for new functionality</li> <li>Run tests: <code>ctest --output-on-failure</code></li> <li>Submit a pull request</li> </ol>"},{"location":"how-to/contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Use existing naming and directory conventions</li> <li>Add tests for new features</li> <li>Add benchmarks for performance-critical code</li> <li>Update documentation where appropriate</li> <li>Keep commits focused and atomic</li> </ul>"},{"location":"how-to/contributing/#what-to-contribute","title":"What to Contribute","text":"<p>FLOX welcomes contributions in these areas:</p> <ul> <li>Features \u2014 New functionality and capabilities</li> <li>Connectors \u2014 New exchange integrations</li> <li>Bug fixes \u2014 Correctness improvements</li> <li>Performance \u2014 Latency and throughput optimizations</li> <li>Documentation \u2014 Examples, tutorials, clarifications</li> <li>Tests \u2014 Improved coverage</li> </ul>"},{"location":"how-to/contributing/#build-options-reference","title":"Build Options Reference","text":"Option Default Description <code>FLOX_ENABLE_TESTS</code> <code>OFF</code> Build unit tests <code>FLOX_ENABLE_BENCHMARKS</code> <code>OFF</code> Build benchmark binaries <code>FLOX_ENABLE_DEMO</code> <code>OFF</code> Build demo application <code>FLOX_ENABLE_TOOLS</code> <code>OFF</code> Build command-line tools (preagg_bars, etc.) <code>FLOX_ENABLE_BACKTEST</code> <code>OFF</code> Build backtest module (simulated execution) <code>FLOX_ENABLE_LZ4</code> <code>OFF</code> Enable LZ4 compression for binary logs <code>FLOX_ENABLE_CPU_AFFINITY</code> <code>OFF</code> Enable CPU affinity and NUMA functionality <code>FLOX_ENABLE_TRACY</code> <code>OFF</code> Enable Tracy profiler integration <code>FLOX_ENABLE_DEV_SETUP</code> <code>OFF</code> Install pre-commit hook automatically <p>Enable with:</p> <pre><code>cmake .. -DFLOX_ENABLE_TESTS=ON -DFLOX_ENABLE_BENCHMARKS=ON\n</code></pre>"},{"location":"how-to/contributing/#see-also","title":"See Also","text":"<ul> <li>Quickstart \u2014 Build and run FLOX</li> <li>Architecture \u2014 Understand the codebase</li> </ul>"},{"location":"how-to/cpu-affinity/","title":"Configure CPU Affinity","text":"<p>Pin threads to isolated CPU cores for lower, more predictable latency.</p>"},{"location":"how-to/cpu-affinity/#when-to-use","title":"When to Use","text":"<p>CPU affinity is useful when: - You have dedicated hardware for trading - You've isolated CPU cores from the OS scheduler - You need sub-microsecond latency consistency</p> <p>Warning: CPU affinity can decrease performance on shared or busy systems. Only use it when you control the entire system workload.</p>"},{"location":"how-to/cpu-affinity/#1-enable-at-build-time","title":"1. Enable at Build Time","text":"<pre><code>cmake .. -DFLOX_ENABLE_CPU_AFFINITY=ON\n</code></pre> <p>This requires the NUMA library on Linux: <pre><code>sudo apt install libnuma-dev  # Debian/Ubuntu\n</code></pre></p>"},{"location":"how-to/cpu-affinity/#2-isolate-cpu-cores-system-setup","title":"2. Isolate CPU Cores (System Setup)","text":"<p>Edit your kernel command line (e.g., <code>/etc/default/grub</code>):</p> <pre><code>GRUB_CMDLINE_LINUX=\"isolcpus=2,3,4,5 nohz_full=2,3,4,5 rcu_nocbs=2,3,4,5\"\n</code></pre> <p>Then: <pre><code>sudo update-grub\nsudo reboot\n</code></pre></p> <p>Verify isolation: <pre><code>cat /sys/devices/system/cpu/isolated\n# Should show: 2-5\n</code></pre></p>"},{"location":"how-to/cpu-affinity/#3-configure-eventbus-affinity","title":"3. Configure EventBus Affinity","text":""},{"location":"how-to/cpu-affinity/#automatic-configuration","title":"Automatic Configuration","text":"<pre><code>#include \"flox/book/bus/trade_bus.h\"\n\nTradeBus tradeBus;\n\n// Auto-configure for market data workload\ntradeBus.setupOptimalConfiguration(\n    TradeBus::ComponentType::MARKET_DATA,\n    /*enablePerformanceOptimizations=*/true\n);\n</code></pre> <p>Component types and their priority:</p> Type Priority Description <code>MARKET_DATA</code> 90 Market data buses (TradeBus, BookUpdateBus) <code>EXECUTION</code> 85 Order execution bus <code>STRATEGY</code> 80 Strategy processing threads <code>RISK</code> 75 Risk management <code>GENERAL</code> 70 Non-critical threads <p>Higher priority components get first choice of isolated cores.</p>"},{"location":"how-to/cpu-affinity/#manual-configuration","title":"Manual Configuration","text":"<pre><code>#include \"flox/util/performance/cpu_affinity.h\"\n\nusing namespace flox::performance;\n\n// Create affinity manager\nauto cpuAffinity = createCpuAffinity();\n\n// Get recommended core assignment\nCriticalComponentConfig config;\nconfig.preferIsolatedCores = true;\nconfig.exclusiveIsolatedCores = true;\n\nauto assignment = cpuAffinity-&gt;getNumaAwareCoreAssignment(config);\n\n// Apply to bus\ntradeBus.setCoreAssignment(assignment);\n\n// Verify configuration\nif (tradeBus.verifyIsolatedCoreConfiguration()) {\n    std::cout &lt;&lt; \"CPU affinity configured correctly\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"how-to/cpu-affinity/#per-bus-configuration","title":"Per-Bus Configuration","text":"<pre><code>// Different buses can use different core types\nTradeBus::AffinityConfig tradeCfg;\ntradeCfg.componentType = TradeBus::ComponentType::MARKET_DATA;\ntradeCfg.enableRealTimePriority = true;\ntradeCfg.realTimePriority = 90;\ntradeCfg.enableNumaAwareness = true;\ntradeCfg.preferIsolatedCores = true;\n\ntradeBus.setAffinityConfig(tradeCfg);\n\nOrderExecutionBus::AffinityConfig execCfg;\nexecCfg.componentType = OrderExecutionBus::ComponentType::EXECUTION;\nexecCfg.enableRealTimePriority = true;\nexecCfg.realTimePriority = 85;\n\nexecBus.setAffinityConfig(execCfg);\n</code></pre>"},{"location":"how-to/cpu-affinity/#4-core-assignment-structure","title":"4. Core Assignment Structure","text":"<pre><code>struct CoreAssignment\n{\n  std::vector&lt;int&gt; marketDataCores;  // For market data processing\n  std::vector&lt;int&gt; executionCores;   // For order execution\n  std::vector&lt;int&gt; strategyCores;    // For strategy threads\n  std::vector&lt;int&gt; riskCores;        // For risk management\n  std::vector&lt;int&gt; generalCores;     // For non-critical threads\n  std::vector&lt;int&gt; allIsolatedCores; // All isolated cores\n  bool hasIsolatedCores{false};      // True if system has isolated cores\n};\n</code></pre>"},{"location":"how-to/cpu-affinity/#5-numa-awareness","title":"5. NUMA Awareness","text":"<p>For multi-socket systems, use NUMA-aware assignment:</p> <pre><code>auto assignment = cpuAffinity-&gt;getNumaAwareCoreAssignment(config);\n</code></pre> <p>This ensures: - Threads run on cores near their memory - Cross-socket memory access is minimized - Cache coherency traffic is reduced</p>"},{"location":"how-to/cpu-affinity/#6-disable-frequency-scaling","title":"6. Disable Frequency Scaling","text":"<p>For consistent performance, disable CPU frequency scaling:</p> <pre><code>cpuAffinity-&gt;disableCpuFrequencyScaling();\n</code></pre> <p>Or via system settings: <pre><code>echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor\n</code></pre></p>"},{"location":"how-to/cpu-affinity/#7-verify-configuration","title":"7. Verify Configuration","text":"<pre><code>// Check if isolated cores are properly configured\nif (tradeBus.verifyIsolatedCoreConfiguration()) {\n    std::cout &lt;&lt; \"Verified: running on isolated cores\" &lt;&lt; std::endl;\n} else {\n    std::cerr &lt;&lt; \"Warning: not running on isolated cores\" &lt;&lt; std::endl;\n}\n\n// Print assignment\nauto assignment = tradeBus.getCoreAssignment();\nif (assignment) {\n    std::cout &lt;&lt; \"Market data cores: \";\n    for (int c : assignment-&gt;marketDataCores) std::cout &lt;&lt; c &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"how-to/cpu-affinity/#8-full-example","title":"8. Full Example","text":"<pre><code>#include \"flox/book/bus/trade_bus.h\"\n#include \"flox/book/bus/book_update_bus.h\"\n#include \"flox/execution/bus/order_execution_bus.h\"\n\nint main()\n{\n    flox::init_timebase_mapping();\n\n#if FLOX_CPU_AFFINITY_ENABLED\n    auto cpuAffinity = flox::performance::createCpuAffinity();\n\n    flox::performance::CriticalComponentConfig config;\n    config.preferIsolatedCores = true;\n    config.exclusiveIsolatedCores = true;\n\n    auto assignment = cpuAffinity-&gt;getNumaAwareCoreAssignment(config);\n\n    if (assignment.hasIsolatedCores) {\n        std::cout &lt;&lt; \"Using isolated cores for critical components\" &lt;&lt; std::endl;\n    }\n#endif\n\n    auto tradeBus = std::make_unique&lt;TradeBus&gt;();\n    auto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\n    auto execBus = std::make_unique&lt;OrderExecutionBus&gt;();\n\n#if FLOX_CPU_AFFINITY_ENABLED\n    tradeBus-&gt;setupOptimalConfiguration(TradeBus::ComponentType::MARKET_DATA);\n    bookBus-&gt;setupOptimalConfiguration(BookUpdateBus::ComponentType::MARKET_DATA);\n    execBus-&gt;setupOptimalConfiguration(OrderExecutionBus::ComponentType::EXECUTION);\n#endif\n\n    // ... rest of setup and run\n}\n</code></pre>"},{"location":"how-to/cpu-affinity/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/cpu-affinity/#numa-library-not-found","title":"\"NUMA library not found\"","text":"<p>Install libnuma: <pre><code>sudo apt install libnuma-dev  # Debian/Ubuntu\nsudo yum install numactl-devel  # RHEL/CentOS\n</code></pre></p>"},{"location":"how-to/cpu-affinity/#performance-is-worse-with-affinity","title":"Performance is worse with affinity","text":"<ul> <li>Ensure cores are properly isolated (<code>cat /sys/devices/system/cpu/isolated</code>)</li> <li>Disable frequency scaling</li> <li>Verify you have enough isolated cores for all critical threads</li> <li>Check for IRQ affinity conflicts (<code>cat /proc/interrupts</code>)</li> </ul>"},{"location":"how-to/cpu-affinity/#permission-denied-setting-real-time-priority","title":"\"Permission denied\" setting real-time priority","text":"<p>Run as root or add capability: <pre><code>sudo setcap cap_sys_nice+ep ./your_binary\n</code></pre></p> <p>Or run with: <pre><code>sudo nice -n -20 ./your_binary\n</code></pre></p>"},{"location":"how-to/cpu-affinity/#see-also","title":"See Also","text":"<ul> <li>Optimize Performance \u2014 More tuning options</li> <li>Architecture Overview \u2014 Threading model</li> </ul>"},{"location":"how-to/custom-bar-policy/","title":"How to Create a Custom Bar Policy","text":"<p>This guide shows how to create your own bar closing policy for the BarAggregator.</p>"},{"location":"how-to/custom-bar-policy/#when-to-use","title":"When to Use","text":"<p>Create a custom policy when built-in types (Time, Tick, Volume, Renko, Range) don't fit your needs:</p> <ul> <li>Dollar bars (close after fixed dollar volume)</li> <li>Volatility bars (close based on ATR)</li> <li>Session bars (close at specific times)</li> <li>Hybrid bars (combine multiple conditions)</li> </ul>"},{"location":"how-to/custom-bar-policy/#the-barpolicy-concept","title":"The BarPolicy Concept","text":"<p>Your policy must satisfy this interface:</p> <pre><code>template &lt;typename T&gt;\nconcept BarPolicy = requires(T&amp; p, const TradeEvent&amp; t, Bar&amp; b) {\n  { p.shouldClose(t, b) } noexcept -&gt; std::same_as&lt;bool&gt;;\n  { p.update(t, b) } noexcept -&gt; std::same_as&lt;void&gt;;\n  { p.initBar(t, b) } noexcept -&gt; std::same_as&lt;void&gt;;\n  { T::kBarType } -&gt; std::convertible_to&lt;BarType&gt;;\n};\n</code></pre>"},{"location":"how-to/custom-bar-policy/#example-dollar-bar-policy","title":"Example: Dollar Bar Policy","text":"<p>Closes when notional volume reaches a threshold:</p> <pre><code>#include \"flox/aggregator/aggregation_policy.h\"\n#include \"flox/aggregator/bar.h\"\n#include \"flox/book/events/trade_event.h\"\n\nnamespace flox\n{\n\nclass DollarBarPolicy\n{\n public:\n  static constexpr BarType kBarType = BarType::Volume;\n\n  explicit DollarBarPolicy(Volume threshold) : _threshold(threshold) {}\n\n  static DollarBarPolicy fromDouble(double dollars)\n  {\n    return DollarBarPolicy(Volume::fromDouble(dollars));\n  }\n\n  bool shouldClose(const TradeEvent&amp; trade, const Bar&amp; bar) noexcept\n  {\n    return bar.volume.raw() &gt;= _threshold.raw();\n  }\n\n  void update(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    updateOHLCV(trade, bar);  // Use built-in helper\n  }\n\n  void initBar(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    initializeBar(trade, bar);  // Use built-in helper\n  }\n\n private:\n  Volume _threshold;\n};\n\n}  // namespace flox\n</code></pre>"},{"location":"how-to/custom-bar-policy/#usage","title":"Usage","text":"<pre><code>BarAggregator&lt;DollarBarPolicy&gt; aggregator(\n  DollarBarPolicy::fromDouble(1000000.0),  // $1M bars\n  &amp;bus\n);\n</code></pre>"},{"location":"how-to/custom-bar-policy/#example-session-bar-policy","title":"Example: Session Bar Policy","text":"<p>Closes at specific session boundaries:</p> <pre><code>class SessionBarPolicy\n{\n public:\n  static constexpr BarType kBarType = BarType::Time;\n\n  explicit SessionBarPolicy(std::vector&lt;uint64_t&gt; closeTimesNs)\n      : _closeTimes(std::move(closeTimesNs))\n  {\n    std::sort(_closeTimes.begin(), _closeTimes.end());\n  }\n\n  bool shouldClose(const TradeEvent&amp; trade, const Bar&amp; bar) noexcept\n  {\n    uint64_t tradeNs = trade.trade.exchangeTsNs;\n    uint64_t barStartNs = bar.startTime.time_since_epoch().count();\n\n    for (uint64_t closeTime : _closeTimes)\n    {\n      if (tradeNs &gt;= closeTime &amp;&amp; barStartNs &lt; closeTime)\n      {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void update(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    updateOHLCV(trade, bar);\n  }\n\n  void initBar(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    initializeBar(trade, bar);\n  }\n\n private:\n  std::vector&lt;uint64_t&gt; _closeTimes;\n};\n</code></pre>"},{"location":"how-to/custom-bar-policy/#example-volatility-bar-policy","title":"Example: Volatility Bar Policy","text":"<p>Closes when price range exceeds N times recent average:</p> <pre><code>class VolatilityBarPolicy\n{\n public:\n  static constexpr BarType kBarType = BarType::Range;\n\n  explicit VolatilityBarPolicy(double multiplier, Price baseRange)\n      : _multiplier(multiplier), _threshold(baseRange)\n  {\n  }\n\n  bool shouldClose(const TradeEvent&amp; trade, const Bar&amp; bar) noexcept\n  {\n    Price range = Price::fromRaw(bar.high.raw() - bar.low.raw());\n    Price dynamicThreshold = Price::fromRaw(\n      static_cast&lt;int64_t&gt;(_threshold.raw() * _multiplier)\n    );\n    return range.raw() &gt;= dynamicThreshold.raw();\n  }\n\n  void update(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    updateOHLCV(trade, bar);\n\n    // Update rolling average for next bar\n    Price range = Price::fromRaw(bar.high.raw() - bar.low.raw());\n    _threshold = Price::fromRaw(\n      (_threshold.raw() * 9 + range.raw()) / 10  // EMA-like\n    );\n  }\n\n  void initBar(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    initializeBar(trade, bar);\n  }\n\n private:\n  double _multiplier;\n  Price _threshold;\n};\n</code></pre>"},{"location":"how-to/custom-bar-policy/#helper-functions","title":"Helper Functions","text":"<p>Use these built-in helpers in your policy:</p>"},{"location":"how-to/custom-bar-policy/#updateohlcv","title":"updateOHLCV","text":"<p>Updates high, low, close, volume, tradeCount, buyVolume, endTime:</p> <pre><code>void update(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n{\n  updateOHLCV(trade, bar);\n  // Add custom logic here\n}\n</code></pre>"},{"location":"how-to/custom-bar-policy/#initializebar","title":"initializeBar","text":"<p>Initializes a new bar from the first trade:</p> <pre><code>void initBar(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n{\n  initializeBar(trade, bar);\n  // Add custom initialization here\n}\n</code></pre>"},{"location":"how-to/custom-bar-policy/#adding-custom-state","title":"Adding Custom State","text":"<p>Store additional state in your policy:</p> <pre><code>class ImbalanceBarPolicy\n{\n public:\n  static constexpr BarType kBarType = BarType::Volume;\n\n  explicit ImbalanceBarPolicy(double imbalanceThreshold)\n      : _threshold(imbalanceThreshold)\n  {\n  }\n\n  bool shouldClose(const TradeEvent&amp; trade, const Bar&amp; bar) noexcept\n  {\n    if (bar.volume.raw() == 0) return false;\n\n    double buyRatio = static_cast&lt;double&gt;(bar.buyVolume.raw()) /\n                      static_cast&lt;double&gt;(bar.volume.raw());\n\n    // Close when buy/sell imbalance exceeds threshold\n    return buyRatio &gt; _threshold || buyRatio &lt; (1.0 - _threshold);\n  }\n\n  void update(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    updateOHLCV(trade, bar);\n  }\n\n  void initBar(const TradeEvent&amp; trade, Bar&amp; bar) noexcept\n  {\n    initializeBar(trade, bar);\n  }\n\n private:\n  double _threshold;  // e.g., 0.7 = 70% imbalance\n};\n</code></pre>"},{"location":"how-to/custom-bar-policy/#using-with-multitimeframeaggregator","title":"Using with MultiTimeframeAggregator","text":"<p>Custom policies work with <code>MultiTimeframeAggregator</code> via the variant-based interface:</p> <pre><code>// Currently supports Time, Tick, Volume via addXxxInterval()\n// For custom policies, use separate BarAggregator instances:\n\nBarAggregator&lt;DollarBarPolicy&gt; dollarAgg(\n  DollarBarPolicy::fromDouble(1000000.0), &amp;bus\n);\n\nBarAggregator&lt;ImbalanceBarPolicy&gt; imbalanceAgg(\n  ImbalanceBarPolicy(0.7), &amp;bus\n);\n\n// Feed trades to both\nvoid onTrade(const TradeEvent&amp; trade) {\n  dollarAgg.onTrade(trade);\n  imbalanceAgg.onTrade(trade);\n}\n</code></pre>"},{"location":"how-to/custom-bar-policy/#testing-your-policy","title":"Testing Your Policy","text":"<pre><code>TEST(MyPolicyTest, ClosesAtThreshold)\n{\n  BarBus bus;\n  bus.enableDrainOnStop();\n\n  std::vector&lt;Bar&gt; bars;\n  // ... set up test subscriber ...\n\n  BarAggregator&lt;MyPolicy&gt; agg(MyPolicy(...), &amp;bus);\n  bus.subscribe(&amp;subscriber);\n  bus.start();\n  agg.start();\n\n  // Feed test trades\n  agg.onTrade(makeTrade(...));\n\n  agg.stop();\n  bus.stop();\n\n  EXPECT_EQ(bars.size(), expectedCount);\n}\n</code></pre>"},{"location":"how-to/custom-bar-policy/#see-also","title":"See Also","text":"<ul> <li>Bar Aggregator Reference</li> <li>Bar Types Explained</li> </ul>"},{"location":"how-to/custom-connector/","title":"Write a Custom Connector","text":"<p>Connect FLOX to a new exchange or data source.</p>"},{"location":"how-to/custom-connector/#overview","title":"Overview","text":"<p>A connector:</p> <ol> <li>Connects to an exchange API (WebSocket, REST, FIX, etc.)</li> <li>Parses incoming messages</li> <li>Converts to FLOX event types</li> <li>Emits events to the engine</li> </ol>"},{"location":"how-to/custom-connector/#1-implement-iexchangeconnector","title":"1. Implement IExchangeConnector","text":"<p>Header: <code>flox/connector/abstract_exchange_connector.h</code></p> <pre><code>#include \"flox/connector/abstract_exchange_connector.h\"\n#include \"flox/book/events/trade_event.h\"\n#include \"flox/book/events/book_update_event.h\"\n\nclass MyExchangeConnector : public flox::IExchangeConnector\n{\npublic:\n  MyExchangeConnector(const std::string&amp; symbol, flox::SymbolId symbolId)\n    : _symbol(symbol), _symbolId(symbolId) {}\n\n  std::string exchangeId() const override {\n    return \"myexchange\";\n  }\n\n  void start() override {\n    _running = true;\n    _thread = std::thread(&amp;MyExchangeConnector::run, this);\n  }\n\n  void stop() override {\n    _running = false;\n    if (_thread.joinable()) {\n      _thread.join();\n    }\n  }\n\nprivate:\n  void run() {\n    // Connect to exchange\n    connect();\n\n    while (_running) {\n      // Receive and parse messages\n      auto msg = receiveMessage();\n      handleMessage(msg);\n    }\n\n    disconnect();\n  }\n\n  void handleMessage(const Message&amp; msg) {\n    if (msg.type == MessageType::Trade) {\n      handleTrade(msg);\n    } else if (msg.type == MessageType::BookUpdate) {\n      handleBookUpdate(msg);\n    }\n  }\n\n  void handleTrade(const Message&amp; msg) {\n    flox::TradeEvent ev;\n    ev.trade.symbol = _symbolId;\n    ev.trade.price = flox::Price::fromDouble(msg.price);\n    ev.trade.quantity = flox::Quantity::fromDouble(msg.qty);\n    ev.trade.isBuy = msg.side == \"buy\";\n    ev.trade.exchangeTsNs = msg.timestamp;\n    ev.recvNs = flox::nowNsMonotonic();\n\n    // Emit via base class method\n    emitTrade(ev);\n  }\n\n  void handleBookUpdate(const Message&amp; msg) {\n    // For book updates, create event directly (simplified)\n    // In practice, you might use a pool for large events\n\n    flox::BookUpdateEvent ev(/* pmr allocator */);\n    ev.update.symbol = _symbolId;\n    ev.update.type = flox::BookUpdateType::SNAPSHOT;\n\n    for (const auto&amp; bid : msg.bids) {\n      ev.update.bids.push_back({\n        flox::Price::fromDouble(bid.price),\n        flox::Quantity::fromDouble(bid.qty)\n      });\n    }\n    for (const auto&amp; ask : msg.asks) {\n      ev.update.asks.push_back({\n        flox::Price::fromDouble(ask.price),\n        flox::Quantity::fromDouble(ask.qty)\n      });\n    }\n\n    ev.recvNs = flox::nowNsMonotonic();\n\n    emitBookUpdate(ev);\n  }\n\n  std::string _symbol;\n  flox::SymbolId _symbolId;\n  std::atomic&lt;bool&gt; _running{false};\n  std::thread _thread;\n};\n</code></pre>"},{"location":"how-to/custom-connector/#2-wire-callbacks","title":"2. Wire Callbacks","text":"<p>Connect the connector to your buses:</p> <pre><code>#include \"flox/book/bus/trade_bus.h\"\n#include \"flox/book/bus/book_update_bus.h\"\n#include \"flox/util/memory/pool.h\"\n\n// Create buses\nauto tradeBus = std::make_unique&lt;TradeBus&gt;();\nauto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\n\n// Create pool for book events\npool::Pool&lt;BookUpdateEvent, 128&gt; bookPool;\n\n// Create connector\nauto connector = std::make_shared&lt;MyExchangeConnector&gt;(\"BTCUSD\", symbolId);\n\n// Wire callbacks\nconnector-&gt;setCallbacks(\n  // Book update callback\n  [&amp;bookBus, &amp;bookPool](const BookUpdateEvent&amp; ev) {\n    // Acquire from pool for variable-size events\n    if (auto handle = bookPool.acquire()) {\n      (*handle)-&gt;update = ev.update;\n      (*handle)-&gt;recvNs = ev.recvNs;\n      bookBus-&gt;publish(std::move(handle));\n    }\n  },\n  // Trade callback\n  [&amp;tradeBus](const TradeEvent&amp; ev) {\n    tradeBus-&gt;publish(ev);\n  }\n);\n</code></pre>"},{"location":"how-to/custom-connector/#3-register-with-engine","title":"3. Register with Engine","text":"<pre><code>std::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors;\nconnectors.push_back(connector);\n\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\nsubsystems.push_back(std::move(tradeBus));\nsubsystems.push_back(std::move(bookBus));\n// ... add strategies, etc.\n\nEngineConfig config{};\nEngine engine(config, std::move(subsystems), std::move(connectors));\nengine.start();\n</code></pre>"},{"location":"how-to/custom-connector/#4-use-connectorfactory-optional","title":"4. Use ConnectorFactory (Optional)","text":"<p>For dynamic connector creation:</p> <pre><code>#include \"flox/connector/connector_factory.h\"\n\n// Register factory\nConnectorFactory::instance().registerConnector(\"myexchange\",\n  [registry](const std::string&amp; symbol) {\n    auto symbolId = registry-&gt;getSymbolId(\"myexchange\", symbol);\n    return std::make_shared&lt;MyExchangeConnector&gt;(symbol, *symbolId);\n  }\n);\n\n// Create connector\nauto conn = ConnectorFactory::instance().createConnector(\"myexchange\", \"BTCUSD\");\n</code></pre>"},{"location":"how-to/custom-connector/#5-best-practices","title":"5. Best Practices","text":""},{"location":"how-to/custom-connector/#thread-safety","title":"Thread Safety","text":"<ul> <li>Connector runs its own thread(s)</li> <li><code>emitTrade()</code> and <code>emitBookUpdate()</code> are thread-safe</li> <li>Callbacks may execute on connector thread</li> </ul>"},{"location":"how-to/custom-connector/#timestamps","title":"Timestamps","text":"<p>Capture timestamps at the right points: <pre><code>void handleMessage(const RawMessage&amp; raw) {\n  MonoNanos recvNs = nowNsMonotonic();  // Capture immediately\n\n  // Parse message...\n  auto parsed = parse(raw);\n\n  TradeEvent ev;\n  ev.trade.exchangeTsNs = parsed.exchangeTimestamp;  // From exchange\n  ev.recvNs = recvNs;                                 // When we received it\n  ev.publishTsNs = nowNsMonotonic();                  // Right before emit\n\n  emitTrade(ev);\n}\n</code></pre></p>"},{"location":"how-to/custom-connector/#error-handling","title":"Error Handling","text":"<pre><code>void run() {\n  while (_running) {\n    try {\n      if (!_connected) {\n        connect();\n      }\n      auto msg = receiveMessage();\n      handleMessage(msg);\n    } catch (const ConnectionError&amp; e) {\n      FLOX_LOG(\"Connection lost: \" &lt;&lt; e.what());\n      _connected = false;\n      reconnect();\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/custom-connector/#sequence-numbers","title":"Sequence Numbers","text":"<p>Track exchange sequence numbers for gap detection:</p> <pre><code>void handleBookUpdate(const Message&amp; msg) {\n  if (_lastSeq &gt; 0 &amp;&amp; msg.seq != _lastSeq + 1) {\n    FLOX_LOG(\"Gap detected: \" &lt;&lt; _lastSeq &lt;&lt; \" -&gt; \" &lt;&lt; msg.seq);\n    requestSnapshot();  // Request full book snapshot\n  }\n  _lastSeq = msg.seq;\n\n  // ... create and emit event\n}\n</code></pre>"},{"location":"how-to/custom-connector/#pooled-book-events","title":"Pooled Book Events","text":"<p>For high-frequency book updates, use pooled events:</p> <pre><code>class MyExchangeConnector : public IExchangeConnector\n{\n  pool::Pool&lt;BookUpdateEvent, 64&gt; _bookPool;\n\n  void handleBookUpdate(const Message&amp; msg) {\n    auto evOpt = _bookPool.acquire();\n    if (!evOpt) {\n      FLOX_LOG(\"Pool exhausted, dropping book update\");\n      return;\n    }\n\n    auto&amp; ev = *evOpt;\n    // ... populate ev\n\n    emitBookUpdate(*ev);\n    // Handle is moved to bus, returns to pool when all consumers done\n  }\n};\n</code></pre>"},{"location":"how-to/custom-connector/#6-complete-example","title":"6. Complete Example","text":"<pre><code>#include \"flox/connector/abstract_exchange_connector.h\"\n#include \"flox/book/events/trade_event.h\"\n#include \"flox/book/events/book_update_event.h\"\n#include \"flox/util/memory/pool.h\"\n#include \"flox/util/base/time.h\"\n#include \"flox/log/log.h\"\n\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n\nnamespace myexchange\n{\n\nusing namespace flox;\n\nclass MyConnector : public IExchangeConnector\n{\npublic:\n  MyConnector(SymbolId symbol, TradeBus&amp; tradeBus, BookUpdateBus&amp; bookBus)\n    : _symbol(symbol)\n    , _tradeBus(tradeBus)\n    , _bookBus(bookBus)\n  {}\n\n  std::string exchangeId() const override { return \"myexchange\"; }\n\n  void start() override {\n    if (_running.exchange(true)) return;\n    _thread = std::thread(&amp;MyConnector::run, this);\n  }\n\n  void stop() override {\n    if (!_running.exchange(false)) return;\n    if (_thread.joinable()) _thread.join();\n  }\n\nprivate:\n  void run() {\n    FLOX_LOG(\"[myexchange] Connecting...\");\n    // ... connect to exchange\n\n    while (_running) {\n      // ... receive and process messages\n    }\n\n    FLOX_LOG(\"[myexchange] Disconnected\");\n  }\n\n  void onTradeMessage(/* ... */) {\n    TradeEvent ev;\n    ev.trade.symbol = _symbol;\n    ev.trade.price = Price::fromDouble(/* ... */);\n    ev.trade.quantity = Quantity::fromDouble(/* ... */);\n    ev.trade.isBuy = /* ... */;\n    ev.trade.exchangeTsNs = /* ... */;\n    ev.recvNs = nowNsMonotonic();\n\n    _tradeBus.publish(ev);\n  }\n\n  void onBookMessage(/* ... */) {\n    auto evOpt = _bookPool.acquire();\n    if (!evOpt) return;\n\n    auto&amp; ev = *evOpt;\n    ev-&gt;update.symbol = _symbol;\n    ev-&gt;update.type = BookUpdateType::SNAPSHOT;\n    // ... populate bids/asks\n\n    ev-&gt;recvNs = nowNsMonotonic();\n    _bookBus.publish(std::move(ev));\n  }\n\n  SymbolId _symbol;\n  TradeBus&amp; _tradeBus;\n  BookUpdateBus&amp; _bookBus;\n\n  pool::Pool&lt;BookUpdateEvent, 64&gt; _bookPool;\n\n  std::atomic&lt;bool&gt; _running{false};\n  std::thread _thread;\n};\n\n}  // namespace myexchange\n</code></pre>"},{"location":"how-to/custom-connector/#see-also","title":"See Also","text":"<ul> <li>Architecture Overview \u2014 How connectors fit</li> <li>First Strategy Tutorial \u2014 Consuming events</li> </ul>"},{"location":"how-to/grid-search/","title":"Parameter Optimization with Grid Search","text":"<p>Optimize strategy parameters using exhaustive grid search.</p>"},{"location":"how-to/grid-search/#quick-start","title":"Quick Start","text":"<pre><code>#include \"flox/backtest/backtest_optimizer.h\"\n#include \"flox/backtest/optimization_stats.h\"\n\nusing namespace flox;\n\n// 1. Define your parameters\nstruct MAParams {\n  int fastPeriod;\n  int slowPeriod;\n  std::string toString() const {\n    return \"fast=\" + std::to_string(fastPeriod) +\n           \",slow=\" + std::to_string(slowPeriod);\n  }\n};\n\n// 2. Define parameter grid\nstruct MAGrid {\n  std::vector&lt;int&gt; fastPeriods = {5, 10, 15, 20};\n  std::vector&lt;int&gt; slowPeriods = {20, 30, 40, 50};\n\n  size_t totalCombinations() const {\n    return fastPeriods.size() * slowPeriods.size();\n  }\n\n  MAParams operator[](size_t index) const {\n    return {\n      fastPeriods[index / slowPeriods.size()],\n      slowPeriods[index % slowPeriods.size()]\n    };\n  }\n};\n\n// 3. Create optimizer\nBacktestOptimizer&lt;MAParams, MAGrid&gt; optimizer;\noptimizer.setParameterGrid(MAGrid{});\n\n// 4. Set backtest factory\noptimizer.setBacktestFactory([&amp;](const MAParams&amp; params) {\n  // Create and run your strategy with these params\n  return runBacktest(params);\n});\n\n// 5. Run optimization\nauto results = optimizer.runLocal();\n\n// 6. Analyze results\nauto ranked = BacktestOptimizer&lt;MAParams, MAGrid&gt;::rankResults(\n    results, RankMetric::SharpeRatio);\n\nstd::cout &lt;&lt; \"Best params: \" &lt;&lt; ranked[0].parameters.toString() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Sharpe: \" &lt;&lt; ranked[0].sharpeRatio() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"how-to/grid-search/#components","title":"Components","text":""},{"location":"how-to/grid-search/#backtestoptimizer","title":"BacktestOptimizer","text":"<pre><code>template &lt;typename ParamsT, typename GridT&gt;\nclass BacktestOptimizer {\n  void setParameterGrid(const GridT&amp; grid);\n  void setBacktestFactory(BacktestFactory factory);\n  void setProgressCallback(ProgressCallback callback);\n\n  size_t totalCombinations() const;\n  std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; runLocal(size_t numThreads = 0);\n  OptimizationResult&lt;ParamsT&gt; runSingle(size_t index);\n\n  static std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; rankResults(\n      std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; results,\n      RankMetric metric,\n      bool ascending = false);\n\n  static std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; filterResults(\n      const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n      Predicate&amp;&amp; predicate);\n\n  static bool exportToCSV(\n      const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n      const std::filesystem::path&amp; path);\n};\n</code></pre>"},{"location":"how-to/grid-search/#optimizationresult","title":"OptimizationResult","text":"<pre><code>template &lt;typename ParamsT&gt;\nstruct OptimizationResult {\n  ParamsT parameters;\n  BacktestStats stats;\n\n  double sharpeRatio() const;\n  double sortinoRatio() const;\n  double calmarRatio() const;\n  double totalReturn() const;\n  double maxDrawdown() const;\n  double winRate() const;\n  double profitFactor() const;\n  size_t totalTrades() const;\n};\n</code></pre>"},{"location":"how-to/grid-search/#rankmetric","title":"RankMetric","text":"<pre><code>enum class RankMetric {\n  SharpeRatio,\n  SortinoRatio,\n  CalmarRatio,\n  TotalReturn,\n  MaxDrawdown,\n  WinRate,\n  ProfitFactor\n};\n</code></pre>"},{"location":"how-to/grid-search/#grid-requirements","title":"Grid Requirements","text":"<p>Your grid type must provide:</p> <pre><code>struct MyGrid {\n  // Return total number of parameter combinations\n  size_t totalCombinations() const;\n\n  // Return parameters at index [0, totalCombinations())\n  MyParams operator[](size_t index) const;\n};\n</code></pre> <p>Your params type must provide:</p> <pre><code>struct MyParams {\n  // For CSV export and reporting\n  std::string toString() const;\n};\n</code></pre>"},{"location":"how-to/grid-search/#progress-tracking","title":"Progress Tracking","text":"<pre><code>optimizer.setProgressCallback(\n    [](size_t completed, size_t total, const OptimizationResult&lt;MAParams&gt;&amp; latest) {\n      std::cout &lt;&lt; \"\\rProgress: \" &lt;&lt; completed &lt;&lt; \"/\" &lt;&lt; total\n                &lt;&lt; \" (Sharpe: \" &lt;&lt; latest.sharpeRatio() &lt;&lt; \")\" &lt;&lt; std::flush;\n    });\n</code></pre>"},{"location":"how-to/grid-search/#filtering-results","title":"Filtering Results","text":"<pre><code>// Only profitable strategies with sharpe &gt; 1.0\nauto filtered = BacktestOptimizer&lt;MAParams, MAGrid&gt;::filterResults(\n    results,\n    [](const auto&amp; r) {\n      return r.totalReturn() &gt; 0 &amp;&amp; r.sharpeRatio() &gt; 1.0;\n    });\n</code></pre>"},{"location":"how-to/grid-search/#statistical-analysis","title":"Statistical Analysis","text":"<pre><code>using Stats = OptimizationStatistics&lt;MAParams, MAGrid&gt;;\n\n// Summary with mean/stddev\nStats::printSummary(results);\n\n// Generate markdown report\nStats::generateReport(results, \"report.md\");\n\n// Extract metric values\nauto sharpes = extractMetric(results, RankMetric::SharpeRatio);\ndouble mean = detail::mean(sharpes);\ndouble stddev = detail::stddev(sharpes);\n\n// Bootstrap confidence interval\nauto ci = Stats::bootstrapCI(sharpes, 0.95, 10000);\n// ci.lower, ci.median, ci.upper\n\n// Correlation between metrics\nauto returns = extractMetric(results, RankMetric::TotalReturn);\ndouble corr = Stats::correlation(sharpes, returns);\n\n// Permutation test for significance\nauto group1 = /* top 10 sharpes */;\nauto group2 = /* bottom 10 sharpes */;\ndouble pValue = Stats::permutationTest(group1, group2, 10000);\n</code></pre>"},{"location":"how-to/grid-search/#export-results","title":"Export Results","text":"<pre><code>// CSV export\nBacktestOptimizer&lt;MAParams, MAGrid&gt;::exportToCSV(ranked, \"results.csv\");\n\n// Markdown report\nStats::generateReport(results, \"optimization_report.md\");\n</code></pre>"},{"location":"how-to/grid-search/#best-practices","title":"Best Practices","text":"<ol> <li>Avoid overfitting - More parameters = higher overfitting risk</li> <li>Use walk-forward analysis - Optimize on train, validate on test</li> <li>Check parameter stability - Best params should have good neighbors</li> <li>Consider transaction costs - Include realistic slippage/fees</li> <li>Statistical significance - Use permutation tests to validate</li> </ol>"},{"location":"how-to/grid-search/#example-full-optimization-pipeline","title":"Example: Full Optimization Pipeline","text":"<pre><code>// 1. Load data\nauto reader = replay::createMultiSegmentReader(dataDir, filter);\n\n// 2. Define grid\nMAGrid grid;\ngrid.fastPeriods = {5, 10, 15, 20, 25};\ngrid.slowPeriods = {20, 30, 40, 50, 60};\n\n// 3. Setup optimizer\nBacktestOptimizer&lt;MAParams, MAGrid&gt; optimizer;\noptimizer.setParameterGrid(grid);\noptimizer.setBacktestFactory([&amp;](const MAParams&amp; p) {\n  return runStrategyBacktest(p, reader);\n});\n\n// 4. Run\nauto results = optimizer.runLocal();\n\n// 5. Rank and filter\nauto ranked = BacktestOptimizer&lt;MAParams, MAGrid&gt;::rankResults(\n    results, RankMetric::SharpeRatio);\n\nauto stable = BacktestOptimizer&lt;MAParams, MAGrid&gt;::filterResults(\n    ranked, [](const auto&amp; r) { return r.totalTrades() &gt; 30; });\n\n// 6. Analyze top performer\nconst auto&amp; best = stable[0];\nstd::cout &lt;&lt; \"Best: \" &lt;&lt; best.parameters.toString() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Sharpe: \" &lt;&lt; best.sharpeRatio() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Return: \" &lt;&lt; best.totalReturn() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Trades: \" &lt;&lt; best.totalTrades() &lt;&lt; \"\\n\";\n\n// 7. Export\nBacktestOptimizer&lt;MAParams, MAGrid&gt;::exportToCSV(stable, \"results.csv\");\n</code></pre>"},{"location":"how-to/grid-search/#see-also","title":"See Also","text":"<ul> <li>Backtesting Guide</li> </ul>"},{"location":"how-to/interactive-backtest/","title":"Interactive Backtest Mode","text":"<p><code>BacktestRunner</code> supports an interactive mode with step-by-step execution, pause, breakpoints, and state inspection. This is useful for debugging strategies and understanding market dynamics at specific points in time.</p>"},{"location":"how-to/interactive-backtest/#quick-start","title":"Quick Start","text":"<pre><code>#include \"flox/backtest/backtest_runner.h\"\n\nBacktestRunner runner;\nrunner.setStrategy(&amp;myStrategy);\n\n// Set callbacks for debugging\nrunner.setEventCallback([](const replay::ReplayEvent&amp; ev, const BacktestState&amp; state) {\n  std::cout &lt;&lt; \"Event \" &lt;&lt; state.eventCount &lt;&lt; \" at \" &lt;&lt; state.currentTimeNs &lt;&lt; \"\\n\";\n});\n\nrunner.setPauseCallback([](const BacktestState&amp; state) {\n  std::cout &lt;&lt; \"Paused at event \" &lt;&lt; state.eventCount &lt;&lt; \"\\n\";\n});\n\n// Start in background thread (starts paused)\nstd::thread t([&amp;]() { runner.start(reader); });\n\n// Step through events one by one\nrunner.step();  // Process 1 event\nrunner.step();  // Process another\n\n// Run until breakpoint or end\nrunner.resume();\n\nt.join();\n</code></pre>"},{"location":"how-to/interactive-backtest/#two-modes","title":"Two Modes","text":"<p><code>BacktestRunner</code> supports two execution modes:</p>"},{"location":"how-to/interactive-backtest/#non-interactive-mode","title":"Non-Interactive Mode","text":"<p>Synchronous execution from start to end:</p> <pre><code>BacktestRunner runner;\nrunner.setStrategy(&amp;myStrategy);\n\n// Blocks until complete\nBacktestResult result = runner.run(reader);\n</code></pre>"},{"location":"how-to/interactive-backtest/#interactive-mode","title":"Interactive Mode","text":"<p>Async execution with pause/step control:</p> <pre><code>BacktestRunner runner;\nrunner.setStrategy(&amp;myStrategy);\n\n// Start in background (begins paused)\nstd::thread t([&amp;]() { runner.start(reader); });\n\n// Control execution\nrunner.step();    // One event\nrunner.resume();  // Run until breakpoint/end\nrunner.pause();   // Pause execution\nrunner.stop();    // Stop completely\n\nt.join();\n</code></pre>"},{"location":"how-to/interactive-backtest/#execution-commands","title":"Execution Commands","text":""},{"location":"how-to/interactive-backtest/#step","title":"step()","text":"<p>Execute exactly one event:</p> <pre><code>runner.step();\n</code></pre>"},{"location":"how-to/interactive-backtest/#stepuntilmode","title":"stepUntil(mode)","text":"<p>Skip events until condition:</p> <pre><code>// Skip book updates, pause on next trade\nrunner.stepUntil(BacktestMode::StepTrade);\n</code></pre>"},{"location":"how-to/interactive-backtest/#resume","title":"resume()","text":"<p>Run continuously until breakpoint or end:</p> <pre><code>runner.resume();\n</code></pre>"},{"location":"how-to/interactive-backtest/#pause","title":"pause()","text":"<p>Pause execution (can resume later):</p> <pre><code>runner.pause();\n</code></pre>"},{"location":"how-to/interactive-backtest/#stop","title":"stop()","text":"<p>Stop execution completely:</p> <pre><code>runner.stop();\n</code></pre>"},{"location":"how-to/interactive-backtest/#breakpoints","title":"Breakpoints","text":""},{"location":"how-to/interactive-backtest/#time-based","title":"Time-based","text":"<p>Pause at specific timestamp:</p> <pre><code>runner.addBreakpoint(Breakpoint::atTime(1609459200000000000));  // Unix ns\n</code></pre>"},{"location":"how-to/interactive-backtest/#event-count","title":"Event Count","text":"<p>Pause after N events:</p> <pre><code>runner.addBreakpoint(Breakpoint::afterEvents(1000));\n</code></pre>"},{"location":"how-to/interactive-backtest/#trade-count","title":"Trade Count","text":"<p>Pause after N trades:</p> <pre><code>runner.addBreakpoint(Breakpoint::afterTrades(100));\n</code></pre>"},{"location":"how-to/interactive-backtest/#signal-breakpoint","title":"Signal Breakpoint","text":"<p>Pause when strategy emits a signal:</p> <pre><code>runner.setBreakOnSignal(true);\n</code></pre>"},{"location":"how-to/interactive-backtest/#custom-breakpoint","title":"Custom Breakpoint","text":"<p>Pause on custom condition:</p> <pre><code>runner.addBreakpoint(Breakpoint::when([](const replay::ReplayEvent&amp; ev) {\n  return ev.type == replay::EventType::Trade &amp;&amp; ev.trade.price_raw &gt; 50000'00000000;\n}));\n</code></pre>"},{"location":"how-to/interactive-backtest/#clear-breakpoints","title":"Clear Breakpoints","text":"<pre><code>runner.clearBreakpoints();\n</code></pre>"},{"location":"how-to/interactive-backtest/#state-inspection","title":"State Inspection","text":"<p>Check current backtest state at any time:</p> <pre><code>BacktestState state = runner.state();\n\nstd::cout &lt;&lt; \"Time: \" &lt;&lt; state.currentTimeNs &lt;&lt; \"\\n\"\n          &lt;&lt; \"Events: \" &lt;&lt; state.eventCount &lt;&lt; \"\\n\"\n          &lt;&lt; \"Trades: \" &lt;&lt; state.tradeCount &lt;&lt; \"\\n\"\n          &lt;&lt; \"Book updates: \" &lt;&lt; state.bookUpdateCount &lt;&lt; \"\\n\"\n          &lt;&lt; \"Signals: \" &lt;&lt; state.signalCount &lt;&lt; \"\\n\"\n          &lt;&lt; \"Running: \" &lt;&lt; state.isRunning &lt;&lt; \"\\n\"\n          &lt;&lt; \"Paused: \" &lt;&lt; state.isPaused &lt;&lt; \"\\n\"\n          &lt;&lt; \"Finished: \" &lt;&lt; state.isFinished &lt;&lt; \"\\n\";\n</code></pre> <p>Convenience methods:</p> <pre><code>bool paused = runner.isPaused();\nbool done = runner.isFinished();\n</code></pre>"},{"location":"how-to/interactive-backtest/#control-flow","title":"Control Flow","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Paused : start()\n    Paused --&gt; Processing : step()\n    Processing --&gt; Paused : event processed\n    Paused --&gt; Running : resume()\n    Running --&gt; Paused : breakpoint hit\n    Running --&gt; Paused : pause()\n    Running --&gt; Finished : end of data\n    Paused --&gt; Finished : stop()\n    Finished --&gt; [*]</code></pre>"},{"location":"how-to/interactive-backtest/#example-debug-strategy","title":"Example: Debug Strategy","text":"<pre><code>class DebugStrategy : public Strategy {\n  void onTrade(const TradeEvent&amp; ev) override {\n    if (shouldBuy(ev)) {\n      emitMarketBuy(ev.trade.symbol, Quantity::fromDouble(1.0));\n    }\n  }\n};\n\nint main() {\n  auto reader = replay::createMultiSegmentReader(\"./data\");\n\n  DebugStrategy strategy;\n  BacktestRunner runner;\n  runner.setStrategy(&amp;strategy);\n\n  // Break when signal is emitted\n  runner.setBreakOnSignal(true);\n\n  std::thread t([&amp;]() { runner.start(*reader); });\n\n  // Run until first signal\n  runner.resume();\n\n  // Inspect state when signal was emitted\n  auto state = runner.state();\n  std::cout &lt;&lt; \"Signal emitted at trade #\" &lt;&lt; state.tradeCount &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Time: \" &lt;&lt; state.currentTimeNs &lt;&lt; \"\\n\";\n\n  // Continue running\n  runner.resume();\n\n  t.join();\n\n  // Get results\n  auto result = runner.result();\n  auto stats = result.computeStats();\n  std::cout &lt;&lt; \"Total trades: \" &lt;&lt; stats.totalTrades &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"how-to/interactive-backtest/#thread-safety","title":"Thread Safety","text":"<ul> <li><code>start()</code> must be called from a separate thread (it blocks until completion)</li> <li><code>step()</code>, <code>resume()</code>, <code>pause()</code>, <code>stop()</code> can be called from any thread</li> <li><code>state()</code> returns a snapshot, safe to call anytime</li> <li>Callbacks are invoked from the runner thread</li> </ul>"},{"location":"how-to/interactive-backtest/#see-also","title":"See Also","text":"<ul> <li>BacktestRunner \u2014 API reference</li> <li>SimulatedExecutor \u2014 Order execution simulation</li> </ul>"},{"location":"how-to/multi-exchange-trading/","title":"Multi-Exchange Trading","text":"<p>Set up trading across multiple exchanges with position aggregation and smart routing.</p>"},{"location":"how-to/multi-exchange-trading/#prerequisites","title":"Prerequisites","text":"<ul> <li>Multiple exchange connectors configured</li> <li>SymbolRegistry with registered exchanges</li> </ul>"},{"location":"how-to/multi-exchange-trading/#1-register-exchanges-and-symbols","title":"1. Register Exchanges and Symbols","text":"<pre><code>#include \"flox/engine/symbol_registry.h\"\n\nSymbolRegistry registry;\n\n// Register exchanges\nExchangeId binance = registry.registerExchange(\"Binance\");\nExchangeId bybit = registry.registerExchange(\"Bybit\");\nExchangeId kraken = registry.registerExchange(\"Kraken\");\n\n// Register symbols per exchange\nSymbolId btcBinance = registry.registerSymbol(binance, \"BTCUSDT\");\nSymbolId btcBybit = registry.registerSymbol(bybit, \"BTCUSDT\");\nSymbolId btcKraken = registry.registerSymbol(kraken, \"XBTUSDT\");\n\n// Map equivalent symbols\nstd::array&lt;SymbolId, 3&gt; btcSymbols = {btcBinance, btcBybit, btcKraken};\nregistry.mapEquivalentSymbols(btcSymbols);\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#2-set-up-clock-synchronization","title":"2. Set Up Clock Synchronization","text":"<pre><code>#include \"flox/util/sync/exchange_clock_sync.h\"\n\nExchangeClockSync&lt;8&gt; clockSync;\n\n// Record timing samples from API calls\nvoid onApiResponse(ExchangeId ex, int64_t localSend, int64_t serverTime, int64_t localRecv)\n{\n  clockSync.recordSample(ex, localSend, serverTime, localRecv);\n}\n\n// Convert exchange timestamp to local time\nint64_t localTs = clockSync.toLocalTimeNs(binance, exchangeTimestamp);\n\n// Check sync quality\nif (clockSync.hasReliableSync(binance)) {\n  auto est = clockSync.estimate(binance);\n  // est.offsetNs, est.latencyNs, est.confidenceNs\n}\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#3-aggregate-order-books","title":"3. Aggregate Order Books","text":"<pre><code>#include \"flox/book/composite_book_matrix.h\"\n\nCompositeBookMatrix&lt;4&gt; books;\n\n// Subscribe to BookUpdateEvents from all exchanges\n// The matrix updates atomically on each event\n\n// Query best prices (thread-safe, lock-free)\nauto bestBid = books.bestBid(btcBinance);  // Best bid across all exchanges\nauto bestAsk = books.bestAsk(btcBinance);  // Best ask across all exchanges\n\nif (bestBid.valid &amp;&amp; bestAsk.valid) {\n  int64_t spread = bestAsk.priceRaw - bestBid.priceRaw;\n  // bestBid.exchange, bestAsk.exchange tell you where\n}\n\n// Check for arbitrage\nif (books.hasArbitrageOpportunity(btcBinance)) {\n  // bestBid.priceRaw &gt; bestAsk.priceRaw across different exchanges\n}\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#4-track-positions","title":"4. Track Positions","text":"<pre><code>#include \"flox/position/aggregated_position_tracker.h\"\n\nAggregatedPositionTracker&lt;8&gt; positions;\n\n// Update on fills (writer thread)\npositions.onFill(binance, btcBinance,\n    Quantity::fromDouble(1.0).raw(),      // Buy 1 BTC\n    Price::fromDouble(50000.0).raw());    // @ $50,000\n\npositions.onFill(bybit, btcBybit,\n    Quantity::fromDouble(-0.3).raw(),     // Sell 0.3 BTC\n    Price::fromDouble(50100.0).raw());    // @ $50,100\n\n// Query positions (reader thread, lock-free)\nauto binancePos = positions.position(binance, btcBinance);\nauto totalPos = positions.totalPosition(btcBinance);  // Aggregated across exchanges\n\nPrice currentPrice = Price::fromDouble(50200.0);\nint64_t pnlRaw = positions.unrealizedPnlRaw(btcBinance, currentPrice.raw());\ndouble pnl = Price::fromRaw(pnlRaw).toDouble();  // Convert to readable value\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#5-configure-order-routing","title":"5. Configure Order Routing","text":"<pre><code>#include \"flox/execution/order_router.h\"\n\nOrderRouter&lt;4&gt; router;\n\n// Register executors\nrouter.registerExecutor(binance, &amp;binanceExecutor);\nrouter.registerExecutor(bybit, &amp;bybitExecutor);\nrouter.registerExecutor(kraken, &amp;krakenExecutor);\n\n// Configure strategy\nrouter.setCompositeBook(&amp;books);\nrouter.setClockSync(&amp;clockSync);\nrouter.setRoutingStrategy(RoutingStrategy::BestPrice);\nrouter.setFailoverPolicy(FailoverPolicy::FailoverToBest);\n\n// Route orders\nExchangeId routed;\nauto err = router.route(btcBinance, Side::BUY, priceRaw, qtyRaw, orderId, &amp;routed);\n\nif (err == RoutingError::Success) {\n  // Order sent to 'routed' exchange\n}\n\n// Or route explicitly\nrouter.routeTo(binance, btcBinance, Side::BUY, priceRaw, qtyRaw, orderId);\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#6-track-split-orders","title":"6. Track Split Orders","text":"<pre><code>#include \"flox/execution/split_order_tracker.h\"\n\nSplitOrderTracker tracker;\n\n// Split parent order across exchanges\nOrderId parentId = 1000;\nstd::array&lt;OrderId, 3&gt; childIds = {1001, 1002, 1003};\nQuantity totalQty = Quantity::fromDouble(10.0);  // 10 BTC total\n\ntracker.registerSplit(parentId, childIds, totalQty.raw(), nowNs);\n\n// Update on child events\ntracker.onChildFill(1001, Quantity::fromDouble(4.0).raw());  // 4 BTC filled\ntracker.onChildComplete(1001, true);\n\n// Check status\nauto* state = tracker.getState(parentId);\ndouble fillRatio = state-&gt;fillRatio();  // 0.4\nbool done = state-&gt;allDone();\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#routing-strategies","title":"Routing Strategies","text":"Strategy Description Use Case <code>BestPrice</code> Route to exchange with best price Default, maximize fill price <code>LowestLatency</code> Route to exchange with lowest RTT Time-sensitive orders <code>LargestSize</code> Route to exchange with most liquidity Large orders <code>RoundRobin</code> Distribute evenly Load balancing <code>Explicit</code> Use order's target exchange Manual control"},{"location":"how-to/multi-exchange-trading/#error-handling","title":"Error Handling","text":"<pre><code>auto err = router.route(symbol, side, price, qty, orderId);\n\nswitch (err) {\n  case RoutingError::Success:\n    break;\n  case RoutingError::NoExecutor:\n    // No executor registered or all disabled\n    break;\n  case RoutingError::ExchangeDisabled:\n    // Target exchange temporarily disabled\n    break;\n  case RoutingError::InvalidSymbol:\n    // Symbol not found\n    break;\n}\n</code></pre>"},{"location":"how-to/multi-exchange-trading/#see-also","title":"See Also","text":"<ul> <li>CEX Components</li> <li>Custom Connector</li> <li>Backtest Guide</li> </ul>"},{"location":"how-to/optimize-performance/","title":"Optimize Performance","text":"<p>Tune FLOX for minimum latency.</p>"},{"location":"how-to/optimize-performance/#build-optimization","title":"Build Optimization","text":""},{"location":"how-to/optimize-performance/#release-build","title":"Release Build","text":"<pre><code>cmake .. \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_CXX_FLAGS=\"-O3 -march=native -flto\"\n</code></pre> <p>Default release flags in FLOX: <pre><code>$&lt;$&lt;CONFIG:Release&gt;:-O3 -march=native -flto -funroll-loops&gt;\n</code></pre></p>"},{"location":"how-to/optimize-performance/#link-time-optimization","title":"Link-Time Optimization","text":"<p>Already enabled by default with <code>-flto</code>. Ensure your compiler supports it: <pre><code>g++ --version  # GCC 13+ recommended\n</code></pre></p>"},{"location":"how-to/optimize-performance/#event-bus-tuning","title":"Event Bus Tuning","text":""},{"location":"how-to/optimize-performance/#capacity","title":"Capacity","text":"<p>Default: 4096 events. For high-frequency feeds, increase:</p> <pre><code>cmake .. -DFLOX_DEFAULT_EVENTBUS_CAPACITY=16384\n</code></pre> <p>Or per-bus: <pre><code>using HighCapacityBus = EventBus&lt;TradeEvent, 16384&gt;;\n</code></pre></p> <p>Capacity must be power of 2.</p>"},{"location":"how-to/optimize-performance/#consumer-limit","title":"Consumer Limit","text":"<p>Default: 128 consumers. Adjust if needed:</p> <pre><code>cmake .. -DFLOX_DEFAULT_EVENTBUS_MAX_CONSUMERS=256\n</code></pre>"},{"location":"how-to/optimize-performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"how-to/optimize-performance/#pre-allocate-pools","title":"Pre-allocate Pools","text":"<p>Size pools to handle peak load without exhaustion:</p> <pre><code>// For 3 consumers at 10ms processing, 1000 events/sec:\n// In-flight \u2248 3 \u00d7 10ms \u00d7 1000/sec = 30 events\n// Add headroom: 64-128\n\npool::Pool&lt;BookUpdateEvent, 128&gt; bookPool;\n</code></pre> <p>Monitor pool usage: <pre><code>size_t inUse = bookPool.inUse();\nif (inUse &gt; threshold) {\n  FLOX_LOG(\"Warning: pool usage high: \" &lt;&lt; inUse);\n}\n</code></pre></p>"},{"location":"how-to/optimize-performance/#avoid-allocations-in-hot-path","title":"Avoid Allocations in Hot Path","text":"<p>Don't: <pre><code>void onTrade(const TradeEvent&amp; ev) {\n  auto data = std::make_unique&lt;Data&gt;();  // BAD: allocation\n  std::string s = std::to_string(ev.trade.price.toDouble());  // BAD\n}\n</code></pre></p> <p>Do: <pre><code>class MyStrategy : public IStrategy {\n  Data _data;  // Pre-allocated member\n  char _buffer[128];  // Pre-allocated buffer\n\n  void onTrade(const TradeEvent&amp; ev) {\n    _data.process(ev);  // Use pre-allocated\n    snprintf(_buffer, sizeof(_buffer), \"%.2f\", ev.trade.price.toDouble());\n  }\n};\n</code></pre></p>"},{"location":"how-to/optimize-performance/#cpu-optimization","title":"CPU Optimization","text":""},{"location":"how-to/optimize-performance/#cpu-affinity","title":"CPU Affinity","text":"<p>See Configure CPU Affinity for details.</p> <p>Quick setup: <pre><code>#if FLOX_CPU_AFFINITY_ENABLED\ntradeBus.setupOptimalConfiguration(TradeBus::ComponentType::MARKET_DATA, true);\n#endif\n</code></pre></p>"},{"location":"how-to/optimize-performance/#disable-frequency-scaling","title":"Disable Frequency Scaling","text":"<pre><code>echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor\n</code></pre>"},{"location":"how-to/optimize-performance/#isolate-cpus","title":"Isolate CPUs","text":"<p>Kernel parameters: <pre><code>isolcpus=2,3,4,5 nohz_full=2,3,4,5 rcu_nocbs=2,3,4,5\n</code></pre></p>"},{"location":"how-to/optimize-performance/#strategy-optimization","title":"Strategy Optimization","text":""},{"location":"how-to/optimize-performance/#filter-early","title":"Filter Early","text":"<pre><code>void onTrade(const TradeEvent&amp; ev) {\n  // Filter first line \u2014 reject early\n  if (ev.trade.symbol != _symbol) return;\n  if (ev.trade.price &lt; _minPrice) return;\n\n  // Expensive processing only for relevant events\n  processSignal(ev);\n}\n</code></pre>"},{"location":"how-to/optimize-performance/#avoid-branches-in-hot-path","title":"Avoid Branches in Hot Path","text":"<pre><code>// BAD: Branch in tight loop\nfor (const auto&amp; level : book.bids) {\n  if (level.price &gt; threshold) {\n    total += level.quantity;\n  }\n}\n\n// BETTER: Branchless or predictable branch\n// (compiler may optimize, but be aware)\n</code></pre>"},{"location":"how-to/optimize-performance/#cache-friendly-access","title":"Cache Friendly Access","text":"<pre><code>// BAD: Random access\nfor (int i : randomIndices) {\n  process(data[i]);\n}\n\n// GOOD: Sequential access\nfor (const auto&amp; item : data) {\n  process(item);\n}\n</code></pre>"},{"location":"how-to/optimize-performance/#logging-optimization","title":"Logging Optimization","text":"<p>Disable logging during performance-critical sections:</p> <pre><code>FLOX_LOG_OFF();\n\n// Hot path - no logging overhead\n\nFLOX_LOG_ON();\n</code></pre> <p>Or disable at build time for production:</p> <pre><code>cmake .. -DFLOX_DISABLE_LOGGING=ON\n</code></pre>"},{"location":"how-to/optimize-performance/#profiling","title":"Profiling","text":""},{"location":"how-to/optimize-performance/#enable-tracy","title":"Enable Tracy","text":"<pre><code>cmake .. -DFLOX_ENABLE_TRACY=ON\n</code></pre> <p>Use profiling macros: <pre><code>void onTrade(const TradeEvent&amp; ev) {\n  FLOX_PROFILE_SCOPE(\"Strategy::onTrade\");\n\n  // Your code...\n}\n</code></pre></p>"},{"location":"how-to/optimize-performance/#measure-latency","title":"Measure Latency","text":"<pre><code>class LatencyTracker {\n  std::vector&lt;int64_t&gt; _samples;\n\npublic:\n  void record(int64_t latency_ns) {\n    _samples.push_back(latency_ns);\n  }\n\n  void report() {\n    std::sort(_samples.begin(), _samples.end());\n    size_t n = _samples.size();\n\n    std::cout &lt;&lt; \"p50: \" &lt;&lt; _samples[n * 0.50] &lt;&lt; \" ns\\n\";\n    std::cout &lt;&lt; \"p99: \" &lt;&lt; _samples[n * 0.99] &lt;&lt; \" ns\\n\";\n    std::cout &lt;&lt; \"max: \" &lt;&lt; _samples.back() &lt;&lt; \" ns\\n\";\n  }\n};\n</code></pre>"},{"location":"how-to/optimize-performance/#compression-trade-offs","title":"Compression Trade-offs","text":"<p>For replay:</p> <ul> <li>No compression: Fastest read, largest files</li> <li>LZ4: ~3-5x compression, small CPU overhead</li> </ul> <p>For recording, LZ4 is usually worth it: <pre><code>WriterConfig config;\nconfig.compression = CompressionType::LZ4;  // Good default\n</code></pre></p>"},{"location":"how-to/optimize-performance/#network-optimization","title":"Network Optimization","text":""},{"location":"how-to/optimize-performance/#socket-tuning","title":"Socket Tuning","text":"<pre><code># Increase receive buffer\nsudo sysctl -w net.core.rmem_max=16777216\nsudo sysctl -w net.core.rmem_default=16777216\n</code></pre>"},{"location":"how-to/optimize-performance/#busy-poll","title":"Busy-poll","text":"<p>For lowest latency with kernel 4.11+: <pre><code>sudo sysctl -w net.core.busy_poll=50\nsudo sysctl -w net.core.busy_read=50\n</code></pre></p>"},{"location":"how-to/optimize-performance/#checklist","title":"Checklist","text":"<ul> <li>[ ] Release build with <code>-O3 -march=native -flto</code></li> <li>[ ] EventBus capacity sized for peak load</li> <li>[ ] Object pools pre-allocated</li> <li>[ ] No allocations in callbacks</li> <li>[ ] CPU affinity configured (if dedicated hardware)</li> <li>[ ] CPU frequency scaling disabled</li> <li>[ ] Logging disabled during benchmarks</li> <li>[ ] Profiling enabled during tuning</li> <li>[ ] Socket buffers increased</li> <li>[ ] Kernel parameters tuned (isolated CPUs, etc.)</li> </ul>"},{"location":"how-to/optimize-performance/#benchmarking","title":"Benchmarking","text":"<p>Run included benchmarks: <pre><code>cmake .. -DFLOX_ENABLE_BENCHMARKS=ON\nmake -j\n./benchmarks/binary_log_benchmark\n./benchmarks/nlevel_order_book_benchmark\n</code></pre></p> <p>Run your own latency measurements to establish baseline for your hardware.</p>"},{"location":"how-to/optimize-performance/#see-also","title":"See Also","text":"<ul> <li>Configure CPU Affinity \u2014 Thread pinning</li> <li>The Disruptor Pattern \u2014 Understanding latency</li> <li>Memory Model \u2014 Zero-allocation design</li> </ul>"},{"location":"how-to/use-volume-profile/","title":"How to Use Volume Profile","text":"<p>This guide shows practical applications of VolumeProfile for trading.</p>"},{"location":"how-to/use-volume-profile/#basic-setup","title":"Basic Setup","text":"<pre><code>#include \"flox/aggregator/custom/volume_profile.h\"\n\nVolumeProfile&lt;256&gt; profile;\nprofile.setTickSize(Price::fromDouble(0.50));  // Aggregate to $0.50 levels\n</code></pre>"},{"location":"how-to/use-volume-profile/#building-a-session-profile","title":"Building a Session Profile","text":"<p>Reset at session start, build throughout the day:</p> <pre><code>class SessionProfileStrategy : public IMarketDataSubscriber\n{\n public:\n  void onSessionStart()\n  {\n    _profile.clear();\n  }\n\n  void onTrade(const TradeEvent&amp; ev) override\n  {\n    _profile.addTrade(ev);\n  }\n\n private:\n  VolumeProfile&lt;256&gt; _profile;\n};\n</code></pre>"},{"location":"how-to/use-volume-profile/#finding-key-levels","title":"Finding Key Levels","text":""},{"location":"how-to/use-volume-profile/#point-of-control-poc","title":"Point of Control (POC)","text":"<p>The price with highest volume - acts as a magnet:</p> <pre><code>Price poc = profile.poc();\n\n// Trade toward POC\nif (currentPrice &lt; poc) {\n  // Expect price to rise toward POC\n} else if (currentPrice &gt; poc) {\n  // Expect price to fall toward POC\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#value-area","title":"Value Area","text":"<p>Where 70% of volume traded - represents \"fair value\":</p> <pre><code>Price vaLow = profile.valueAreaLow();\nPrice vaHigh = profile.valueAreaHigh();\n\n// Fade extremes\nif (currentPrice &lt; vaLow) {\n  // Below value = potential long\n} else if (currentPrice &gt; vaHigh) {\n  // Above value = potential short\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#trading-strategies","title":"Trading Strategies","text":""},{"location":"how-to/use-volume-profile/#mean-reversion-to-poc","title":"Mean Reversion to POC","text":"<pre><code>void onTrade(const TradeEvent&amp; ev) override\n{\n  _profile.addTrade(ev);\n\n  Price poc = _profile.poc();\n  Price price = ev.trade.price;\n\n  // Entry: 0.5% away from POC\n  Price distance = Price::fromRaw(std::abs(price.raw() - poc.raw()));\n  Price threshold = Price::fromRaw(poc.raw() / 200);  // 0.5%\n\n  if (distance &gt; threshold) {\n    if (price &lt; poc) {\n      // BUY - expect reversion to POC\n      std::cout &lt;&lt; \"BUY @ \" &lt;&lt; price.toDouble()\n                &lt;&lt; \" target POC @ \" &lt;&lt; poc.toDouble() &lt;&lt; std::endl;\n    } else {\n      // SELL - expect reversion to POC\n      std::cout &lt;&lt; \"SELL @ \" &lt;&lt; price.toDouble()\n                &lt;&lt; \" target POC @ \" &lt;&lt; poc.toDouble() &lt;&lt; std::endl;\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#value-area-breakout","title":"Value Area Breakout","text":"<pre><code>void onBar(const BarEvent&amp; ev) override\n{\n  Price vaLow = _profile.valueAreaLow();\n  Price vaHigh = _profile.valueAreaHigh();\n  Price close = ev.bar.close;\n\n  // Breakout above value area\n  if (_prevClose &lt;= vaHigh &amp;&amp; close &gt; vaHigh) {\n    std::cout &lt;&lt; \"BREAKOUT LONG @ \" &lt;&lt; close.toDouble() &lt;&lt; std::endl;\n  }\n\n  // Breakdown below value area\n  if (_prevClose &gt;= vaLow &amp;&amp; close &lt; vaLow) {\n    std::cout &lt;&lt; \"BREAKDOWN SHORT @ \" &lt;&lt; close.toDouble() &lt;&lt; std::endl;\n  }\n\n  _prevClose = close;\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#delta-confirmation","title":"Delta Confirmation","text":"<p>Use delta to confirm direction:</p> <pre><code>void analyzeProfile()\n{\n  Volume delta = _profile.totalDelta();\n  Price poc = _profile.poc();\n\n  if (delta.raw() &gt; 0) {\n    // Net buying - bullish bias\n    std::cout &lt;&lt; \"Bullish bias, buy pullbacks to POC @ \"\n              &lt;&lt; poc.toDouble() &lt;&lt; std::endl;\n  } else {\n    // Net selling - bearish bias\n    std::cout &lt;&lt; \"Bearish bias, sell rallies to POC @ \"\n              &lt;&lt; poc.toDouble() &lt;&lt; std::endl;\n  }\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#multi-session-analysis","title":"Multi-Session Analysis","text":"<p>Combine profiles from multiple days:</p> <pre><code>class CompositeProfile\n{\n public:\n  void addSession(const VolumeProfile&lt;256&gt;&amp; session)\n  {\n    // Merge session POC into composite\n    Price poc = session.poc();\n    _pocLevels.push_back(poc);\n\n    // Track recurring high-volume levels\n    for (size_t i = 0; i &lt; session.numLevels(); ++i) {\n      const auto* lvl = session.level(i);\n      if (lvl &amp;&amp; lvl-&gt;volume.raw() &gt; _minVolume) {\n        _significantLevels[lvl-&gt;price.raw()]++;\n      }\n    }\n  }\n\n  std::vector&lt;Price&gt; getKeyLevels() const\n  {\n    std::vector&lt;Price&gt; result;\n    for (const auto&amp; [priceRaw, count] : _significantLevels) {\n      if (count &gt;= 3) {  // Appeared in 3+ sessions\n        result.push_back(Price::fromRaw(priceRaw));\n      }\n    }\n    return result;\n  }\n\n private:\n  std::vector&lt;Price&gt; _pocLevels;\n  std::map&lt;int64_t, int&gt; _significantLevels;\n  int64_t _minVolume = Volume::fromDouble(100000).raw();\n};\n</code></pre>"},{"location":"how-to/use-volume-profile/#volume-at-price-queries","title":"Volume at Price Queries","text":"<p>Check volume at specific levels:</p> <pre><code>// Check if current price is at high volume node\nVolume volAtPrice = profile.volumeAt(currentPrice);\nVolume avgVol = Volume::fromRaw(profile.totalVolume().raw() / profile.numLevels());\n\nif (volAtPrice.raw() &gt; avgVol.raw() * 2) {\n  // High Volume Node (HVN) - expect consolidation\n} else if (volAtPrice.raw() &lt; avgVol.raw() / 2) {\n  // Low Volume Node (LVN) - expect fast move through\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#combining-with-other-tools","title":"Combining with Other Tools","text":""},{"location":"how-to/use-volume-profile/#with-footprint","title":"With Footprint","text":"<pre><code>VolumeProfile&lt;256&gt; profile;\nFootprintBar&lt;64&gt; footprint;\n\nvoid onTrade(const TradeEvent&amp; ev) override\n{\n  profile.addTrade(ev);\n  footprint.addTrade(ev);\n}\n\nvoid analyze()\n{\n  Price poc = profile.poc();\n\n  // Check order flow at POC\n  const auto* lvl = footprint.levelAt(poc);\n  if (lvl) {\n    if (lvl-&gt;imbalanceRatio() &gt; 0.7) {\n      // Strong buying at POC - support confirmed\n    } else if (lvl-&gt;imbalanceRatio() &lt; 0.3) {\n      // Strong selling at POC - resistance forming\n    }\n  }\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#with-bar-data","title":"With Bar Data","text":"<pre><code>void onBar(const BarEvent&amp; ev) override\n{\n  Price poc = _profile.poc();\n  Price vaLow = _profile.valueAreaLow();\n  Price vaHigh = _profile.valueAreaHigh();\n\n  // Bar closes at POC\n  if (std::abs(ev.bar.close.raw() - poc.raw()) &lt; _tickSize.raw()) {\n    // Consolidation expected\n  }\n\n  // Bar closes outside value\n  if (ev.bar.close &lt; vaLow || ev.bar.close &gt; vaHigh) {\n    // Trend move or potential reversal\n  }\n}\n</code></pre>"},{"location":"how-to/use-volume-profile/#performance-tips","title":"Performance Tips","text":"<ol> <li>Tick size: Larger tick = fewer levels = faster lookups</li> <li>MaxLevels: Size appropriately (128-256 typical for crypto)</li> <li>Clear regularly: Reset at session boundaries to avoid stale data</li> </ol> <pre><code>// Appropriate sizing\nVolumeProfile&lt;128&gt; cryptoProfile;   // Volatile, fewer levels\nVolumeProfile&lt;256&gt; stockProfile;    // More granular\nVolumeProfile&lt;512&gt; futuresProfile;  // High precision needed\n</code></pre>"},{"location":"how-to/use-volume-profile/#see-also","title":"See Also","text":"<ul> <li>Volume Profile Reference</li> <li>Footprint Chart</li> <li>Bar Types Explained</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Technical specifications and API documentation.</p> <p>See API Reference for complete component documentation.</p>"},{"location":"reference/api/","title":"API Reference","text":"<p>Complete technical documentation for all FLOX components.</p>"},{"location":"reference/api/#component-categories","title":"Component Categories","text":"Category Description Engine Core orchestration and lifecycle management Book Order book structures and market data Execution Order management and execution Replay Data recording and playback Backtest Backtesting and optimization Util Utilities, memory pools, event buses Connector Exchange connectivity Strategy Strategy interfaces Risk Risk management"},{"location":"reference/api/#quick-links","title":"Quick Links","text":""},{"location":"reference/api/#core","title":"Core","text":"<ul> <li>Engine \u2014 System orchestration</li> <li>EngineConfig \u2014 Configuration structure</li> <li>SymbolRegistry \u2014 Symbol management</li> </ul>"},{"location":"reference/api/#market-data","title":"Market Data","text":"<ul> <li>Trade \u2014 Trade structure</li> <li>BookUpdate \u2014 Order book updates</li> <li>NLevelOrderBook \u2014 Order book implementation</li> <li>TradeBus \u2014 Trade event bus</li> <li>BookUpdateBus \u2014 Book update event bus</li> </ul>"},{"location":"reference/api/#execution","title":"Execution","text":"<ul> <li>Order \u2014 Order structure</li> <li>AbstractExecutor \u2014 Executor interface</li> <li>OrderExecutionBus \u2014 Execution event bus</li> </ul>"},{"location":"reference/api/#utilities","title":"Utilities","text":"<ul> <li>EventBus \u2014 Disruptor-style event bus</li> <li>Pool \u2014 Object pool</li> <li>Decimal \u2014 Fixed-point decimal</li> <li>SPSCQueue \u2014 Lock-free queue</li> </ul>"},{"location":"reference/api/#replay","title":"Replay","text":"<ul> <li>BinaryLogReader \u2014 Log reader</li> <li>ReplayConnector \u2014 Replay connector</li> <li>Binary Format \u2014 File format specification</li> </ul>"},{"location":"reference/api/#backtest","title":"Backtest","text":"<ul> <li>BacktestRunner \u2014 Backtest executor with interactive mode</li> <li>BacktestResult \u2014 Results container and stats</li> <li>BacktestOptimizer \u2014 Grid search optimizer</li> <li>OptimizationStatistics \u2014 Statistical analysis</li> <li>MmapBarStorage \u2014 Memory-mapped bar data</li> </ul>"},{"location":"reference/api/#header-organization","title":"Header Organization","text":"<pre><code>include/flox/\n\u251c\u2500\u2500 backtest/       # Backtesting and optimization\n\u251c\u2500\u2500 book/           # Order book, trades, events\n\u251c\u2500\u2500 connector/      # Exchange connectivity\n\u251c\u2500\u2500 engine/         # Core engine components\n\u251c\u2500\u2500 execution/      # Order execution\n\u251c\u2500\u2500 replay/         # Recording and playback\n\u251c\u2500\u2500 strategy/       # Strategy interfaces\n\u2514\u2500\u2500 util/           # Utilities\n</code></pre>"},{"location":"reference/api/#see-also","title":"See Also","text":"<ul> <li>Architecture \u2014 How components fit together</li> <li>Integration Flow \u2014 Wiring components</li> </ul>"},{"location":"reference/api/common/","title":"Common Types","text":"<p>This header defines core types and enums used throughout the FLOX engine, including identifiers, numeric types (price, quantity), and domain-specific enums.</p>"},{"location":"reference/api/common/#enums","title":"Enums","text":""},{"location":"reference/api/common/#instrumenttype","title":"<code>InstrumentType</code>","text":"<p>Represents the class of tradable instrument.</p> <pre><code>enum class InstrumentType\n{\n  Spot,\n  Future,\n  Inverse,\n  Option\n};\n</code></pre>"},{"location":"reference/api/common/#optiontype","title":"<code>OptionType</code>","text":"<p>Represents option direction (for option instruments only).</p> <pre><code>enum class OptionType\n{\n  CALL,\n  PUT\n};\n</code></pre>"},{"location":"reference/api/common/#ordertype","title":"<code>OrderType</code>","text":"<p>Represents the execution style of an order.</p> <pre><code>enum class OrderType : uint8_t\n{\n  LIMIT = 0,\n  MARKET = 1,\n  STOP_MARKET = 2,\n  STOP_LIMIT = 3,\n  TAKE_PROFIT_MARKET = 4,\n  TAKE_PROFIT_LIMIT = 5,\n  TRAILING_STOP = 6,\n  ICEBERG = 7,\n};\n</code></pre> Type Description <code>LIMIT</code> Limit order at specified price <code>MARKET</code> Market order, immediate execution <code>STOP_MARKET</code> Stop-loss that triggers market order <code>STOP_LIMIT</code> Stop-loss that triggers limit order <code>TAKE_PROFIT_MARKET</code> Take-profit that triggers market order <code>TAKE_PROFIT_LIMIT</code> Take-profit that triggers limit order <code>TRAILING_STOP</code> Trailing stop order <code>ICEBERG</code> Iceberg order with hidden quantity"},{"location":"reference/api/common/#timeinforce","title":"<code>TimeInForce</code>","text":"<p>Time-in-force policies for orders.</p> <pre><code>enum class TimeInForce : uint8_t\n{\n  GTC = 0,        // Good Till Cancel (default)\n  IOC = 1,        // Immediate Or Cancel\n  FOK = 2,        // Fill Or Kill\n  GTD = 3,        // Good Till Date\n  POST_ONLY = 4,  // Maker only\n};\n</code></pre> Policy Description <code>GTC</code> Order remains until canceled <code>IOC</code> Fill immediately or cancel unfilled portion <code>FOK</code> Fill entire order immediately or cancel <code>GTD</code> Order expires at specified date/time <code>POST_ONLY</code> Order must be maker (rejected if would take)"},{"location":"reference/api/common/#side","title":"<code>Side</code>","text":"<p>Represents the direction of an order.</p> <pre><code>enum class Side\n{\n  BUY,\n  SELL\n};\n</code></pre>"},{"location":"reference/api/common/#venuetype","title":"<code>VenueType</code>","text":"<p>Type of trading venue.</p> <pre><code>enum class VenueType : uint8_t\n{\n  CentralizedExchange,\n  AmmDex,\n  HybridDex\n};\n</code></pre>"},{"location":"reference/api/common/#identifiers","title":"Identifiers","text":"Type Underlying Description <code>SymbolId</code> <code>uint32_t</code> Unique identifier for a symbol. <code>OrderId</code> <code>uint64_t</code> Unique identifier for an order. <code>ExchangeId</code> <code>uint16_t</code> Unique identifier for an exchange. <pre><code>static constexpr ExchangeId InvalidExchangeId = 0xFFFF;\n</code></pre>"},{"location":"reference/api/common/#fixed-point-types","title":"Fixed-Point Types","text":"<p>Built on top of the <code>Decimal</code> template for safe, precise arithmetic.</p> Type Scale Description <code>Price</code> 1e-8 Decimal representation of price. <code>Quantity</code> 1e-8 Decimal quantity (e.g. number of contracts). <code>Volume</code> 1e-8 Price \u00d7 Quantity, used in bars etc. <p>All three types use <code>Decimal&lt;Tag, 100'000'000, 1&gt;</code> internally, ensuring:</p> <ul> <li>High precision (8 decimal places)</li> <li>Strong typing (tags prevent mixing price and size)</li> <li>Tick-aligned operations and rounding support</li> </ul>"},{"location":"reference/api/common/#arithmetic-operations","title":"Arithmetic Operations","text":"<pre><code>// Volume = Price \u00d7 Quantity\nVolume notional = price * quantity;\nVolume notional = quantity * price;  // Also works\n\n// Price = Volume / Quantity\nPrice avgPrice = totalVolume / totalQty;\n\n// Quantity = Volume / Price\nQuantity qty = notional / price;\n</code></pre> <p>Uses 128-bit arithmetic internally to prevent overflow on large values.</p>"},{"location":"reference/api/common/#notes","title":"Notes","text":"<ul> <li>These types are used pervasively across all order-related and market data structures.</li> <li>Prevents accidental unit mismatches (e.g., adding price and quantity).</li> <li><code>InstrumentType::Inverse</code> is used for inverse perpetual contracts.</li> <li><code>ExchangeId</code> is used in <code>SymbolRegistry</code> for multi-exchange scenarios.</li> </ul>"},{"location":"reference/api/aggregator/bar/","title":"Bar","text":"<p><code>Bar</code> is the core OHLCV data structure representing aggregated price action over a defined interval.</p> <pre><code>enum class BarType : uint8_t {\n  Time,       // Time-based intervals (e.g., 1 minute, 1 hour)\n  Tick,       // Fixed number of trades\n  Volume,     // Fixed notional volume\n  Renko,      // Fixed price movement (bricks)\n  Range,      // Fixed high-low range\n  HeikinAshi  // Smoothed time-based bars\n};\n\nenum class BarCloseReason : uint8_t {\n  Threshold,  // Normal close: interval/count/volume reached\n  Gap,        // Gap in data: new bar started due to time gap\n  Forced,     // Forced close: stop() called or manual flush\n  Warmup      // Historical warmup bar\n};\n\nstruct Bar {\n  Price open{};\n  Price high{};\n  Price low{};\n  Price close{};\n  Volume volume{};\n  Volume buyVolume{};     // For delta calculation\n  Quantity tradeCount{};  // Number of trades in this bar\n  TimePoint startTime{};\n  TimePoint endTime{};\n  BarCloseReason reason{BarCloseReason::Threshold};\n};\n</code></pre>"},{"location":"reference/api/aggregator/bar/#fields","title":"Fields","text":"Field Type Description <code>open</code> <code>Price</code> Opening price of the bar. <code>high</code> <code>Price</code> Highest price during the bar. <code>low</code> <code>Price</code> Lowest price during the bar. <code>close</code> <code>Price</code> Closing price of the bar. <code>volume</code> <code>Volume</code> Total notional volume (price \u00d7 quantity). <code>buyVolume</code> <code>Volume</code> Buy-side notional volume for delta calculation. <code>tradeCount</code> <code>Quantity</code> Number of trades aggregated into this bar. <code>startTime</code> <code>TimePoint</code> Bar open timestamp. <code>endTime</code> <code>TimePoint</code> Bar close timestamp. <code>reason</code> <code>BarCloseReason</code> Why this bar was closed."},{"location":"reference/api/aggregator/bar/#delta-calculation","title":"Delta Calculation","text":"<p>The buy/sell delta can be calculated as:</p> <pre><code>Volume sellVolume = bar.volume - bar.buyVolume;\nint64_t delta = bar.buyVolume.raw() - sellVolume.raw();\n</code></pre>"},{"location":"reference/api/aggregator/bar/#bartype-values","title":"BarType Values","text":"Type Closes When Use Case <code>Time</code> Fixed time interval elapsed Traditional charting <code>Tick</code> N trades occurred HFT, activity-based <code>Volume</code> Notional volume threshold reached Flow analysis <code>Renko</code> Price moved by brick size Trend following <code>Range</code> High-low exceeded threshold Volatility analysis <code>HeikinAshi</code> Time interval (smoothed OHLC) Trend clarity"},{"location":"reference/api/aggregator/bar/#see-also","title":"See Also","text":"<ul> <li>BarEvent \u2014 Event wrapper for bar delivery</li> <li>BarBus \u2014 Event bus for bar distribution</li> <li>Bar Types Guide \u2014 Detailed bar type comparison</li> </ul>"},{"location":"reference/api/aggregator/bar_aggregator/","title":"Bar Aggregator","text":"<p>The Bar Aggregator system provides flexible bar generation from trade data with support for multiple bar types, timeframes, and custom aggregated structures.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#overview","title":"Overview","text":"<p>The aggregator system is built around a policy-based design with zero-cost abstractions:</p> <pre><code>flowchart TB\n    TE[TradeEvent] --&gt; BA[BarAggregator]\n\n    subgraph Policies\n        direction LR\n        Time[TimeBarPolicy]\n        Tick[TickBarPolicy]\n        Volume[VolumeBarPolicy]\n        Renko[RenkoBarPolicy]\n        Range[RangeBarPolicy]\n    end\n\n    BA -.-&gt; Policies\n    BA --&gt; BE[BarEvent]\n\n    BE --&gt; BM[BarMatrix]\n    BE --&gt; Strategy[Strategy.onBar]\n\n    BM --&gt; Access[\"bars[symbol][timeframe][idx]\"]</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#quick-start","title":"Quick Start","text":"<pre><code>#include \"flox/aggregator/bar_aggregator.h\"\n#include \"flox/aggregator/bus/bar_bus.h\"\n\n// Create a 1-minute time bar aggregator\nBarBus bus;\nTimeBarAggregator aggregator(TimeBarPolicy(std::chrono::seconds(60)), &amp;bus);\n\n// Subscribe to bar events\nbus.subscribe(&amp;strategy);\n\n// Start\nbus.start();\naggregator.start();\n\n// Feed trades\naggregator.onTrade(tradeEvent);\n\n// Stop (flushes remaining bars)\naggregator.stop();\nbus.stop();\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#bar-types","title":"Bar Types","text":""},{"location":"reference/api/aggregator/bar_aggregator/#time-bars","title":"Time Bars","text":"<p>Close after a fixed time interval.</p> <pre><code>TimeBarAggregator aggregator(TimeBarPolicy(std::chrono::seconds(60)), &amp;bus);\n</code></pre> <p>Use cases: Traditional OHLCV charts, backtesting, most strategies.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#tick-bars","title":"Tick Bars","text":"<p>Close after a fixed number of trades.</p> <pre><code>TickBarAggregator aggregator(TickBarPolicy(100), &amp;bus);  // 100-tick bars\n</code></pre> <p>Use cases: High-frequency trading, eliminating time-based noise, volume-normalized analysis.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#volume-bars","title":"Volume Bars","text":"<p>Close after a fixed notional volume.</p> <pre><code>VolumeBarAggregator aggregator(VolumeBarPolicy::fromDouble(1000000.0), &amp;bus);  // $1M bars\n</code></pre> <p>Use cases: Volume-weighted analysis, consistent information content per bar.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#renko-bars","title":"Renko Bars","text":"<p>Close when price moves by a fixed amount (brick size).</p> <pre><code>RenkoBarAggregator aggregator(RenkoBarPolicy::fromDouble(10.0), &amp;bus);  // $10 bricks\n</code></pre> <p>Use cases: Trend following, noise elimination, support/resistance identification.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#range-bars","title":"Range Bars","text":"<p>Close when high-low range exceeds a threshold.</p> <pre><code>RangeBarAggregator aggregator(RangeBarPolicy::fromDouble(5.0), &amp;bus);  // $5 range\n</code></pre> <p>Use cases: Volatility-based analysis, breakout detection.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#heikin-ashi-bars","title":"Heikin-Ashi Bars","text":"<p>Smoothed candlesticks using averaged OHLC values:</p> <pre><code>HeikinAshiBarAggregator aggregator(HeikinAshiBarPolicy(std::chrono::seconds(60)), &amp;bus);\n</code></pre> <p>Use cases: Trend identification, noise reduction, smoother signals.</p>"},{"location":"reference/api/aggregator/bar_aggregator/#bar-structure","title":"Bar Structure","text":"<pre><code>struct Bar {\n  Price open, high, low, close;\n  Volume volume;          // Notional volume (price * quantity)\n  Volume buyVolume;       // Volume from buy trades (for delta calculation)\n  Quantity tradeCount;    // Number of trades in bar\n  TimePoint startTime;    // Bar open time\n  TimePoint endTime;      // Bar close time\n  BarCloseReason reason;  // Why bar closed (Threshold, Gap, Forced, Warmup)\n};\n\n// Calculate delta (buy pressure - sell pressure)\nVolume delta = bar.buyVolume.raw() - (bar.volume.raw() - bar.buyVolume.raw());\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#multi-timeframe-analysis","title":"Multi-Timeframe Analysis","text":"<p>Use <code>MultiTimeframeAggregator</code> to produce multiple timeframes from a single trade stream:</p> <pre><code>MultiTimeframeAggregator&lt;4&gt; aggregator(&amp;bus);\naggregator.addTimeInterval(std::chrono::seconds(60));    // M1\naggregator.addTimeInterval(std::chrono::seconds(300));   // M5\naggregator.addTimeInterval(std::chrono::seconds(3600));  // H1\naggregator.addTickInterval(100);                          // 100-tick bars\n\nbus.subscribe(&amp;strategy);\nbus.start();\naggregator.start();\n\n// All trades go to all timeframes\naggregator.onTrade(trade);\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#mixed-bar-types","title":"Mixed Bar Types","text":"<p>You can mix time, tick, and volume bars in a single aggregator:</p> <pre><code>aggregator.addTimeInterval(std::chrono::seconds(60));\naggregator.addTickInterval(50);\naggregator.addVolumeInterval(100000.0);\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#bar-history-barseries","title":"Bar History: BarSeries","text":"<p><code>BarSeries</code> is a ring buffer for storing bar history:</p> <pre><code>BarSeries&lt;256&gt; series;  // Last 256 bars\n\nseries.push(bar);\n\n// Access (0 = newest, 1 = previous, etc.)\nconst Bar&amp; latest = series[0];\nconst Bar&amp; previous = series[1];\n\n// Iteration (newest to oldest)\nfor (const auto&amp; bar : series) {\n  // ...\n}\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#multi-symbol-multi-timeframe-barmatrix","title":"Multi-Symbol Multi-Timeframe: BarMatrix","text":"<p><code>BarMatrix</code> provides O(1) access to bar history across symbols and timeframes:</p> <pre><code>BarMatrix&lt;256, 8, 64&gt; matrix;  // 256 symbols, 8 timeframes, 64 bars depth\n\nstd::array&lt;TimeframeId, 3&gt; tfs = {timeframe::M1, timeframe::M5, timeframe::H1};\nmatrix.configure(tfs);\n\n// Subscribe to receive bars\nbus.subscribe(&amp;matrix);\n\n// Access: matrix[symbol][timeframe][index]\nconst Bar* bar = matrix.bar(symbolId, timeframe::H1, 0);  // Latest H1 bar\nconst Bar* prev = matrix.bar(symbolId, timeframe::H1, 1); // Previous H1 bar\n\n// Or by timeframe index\nconst Bar* bar = matrix.bar(symbolId, 0, 0);  // First configured timeframe\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#warmup-with-historical-data","title":"Warmup with Historical Data","text":"<pre><code>std::vector&lt;Bar&gt; historicalBars = loadFromDatabase();\nmatrix.warmup(symbolId, timeframe::H1, historicalBars);\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#timeframeid","title":"TimeframeId","text":"<p><code>TimeframeId</code> encodes bar type and parameter:</p> <pre><code>// Presets\ntimeframe::M1   // 1 minute\ntimeframe::M5   // 5 minutes\ntimeframe::M15  // 15 minutes\ntimeframe::H1   // 1 hour\ntimeframe::H4   // 4 hours\ntimeframe::D1   // 1 day\n\n// Custom\nTimeframeId tf = TimeframeId::time(std::chrono::seconds(120));  // 2 minutes\nTimeframeId tick = TimeframeId::tick(500);                       // 500 ticks\nTimeframeId vol = TimeframeId::volume(1000000);                  // $1M volume\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#custom-policies","title":"Custom Policies","text":"<p>Implement your own bar policy by satisfying the <code>BarPolicy</code> concept:</p> <pre><code>struct MyCustomPolicy {\n  static constexpr BarType kBarType = BarType::Custom;\n\n  bool shouldClose(const TradeEvent&amp; trade, const Bar&amp; bar) noexcept {\n    // Your closing logic\n    return /* condition */;\n  }\n\n  void update(const TradeEvent&amp; trade, Bar&amp; bar) noexcept {\n    updateOHLCV(trade, bar);  // Use helper for OHLCV update\n    // Additional custom updates\n  }\n\n  void initBar(const TradeEvent&amp; trade, Bar&amp; bar) noexcept {\n    initializeBar(trade, bar);  // Use helper for initialization\n    // Additional initialization\n  }\n};\n\n// Use with BarAggregator\nBarAggregator&lt;MyCustomPolicy&gt; aggregator(MyCustomPolicy{...}, &amp;bus);\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#barevent","title":"BarEvent","text":"<p>Bar events contain full bar data plus metadata:</p> <pre><code>struct BarEvent {\n  SymbolId symbol;\n  InstrumentType instrument;\n  BarType barType;\n  uint32_t barTypeParam;  // seconds, tick count, volume threshold\n  Bar bar;\n};\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#strategy-integration","title":"Strategy Integration","text":""},{"location":"reference/api/aggregator/bar_aggregator/#using-barstrategy-helper","title":"Using BarStrategy Helper","text":"<pre><code>class MyStrategy : public BarStrategy&lt;4&gt; {\npublic:\n  void setBarMatrix(BarMatrix&lt;&gt;* matrix) {\n    BarStrategy::setBarMatrix(matrix);\n  }\n\n  void onBar(const BarEvent&amp; ev) override {\n    // Access bars via helper methods\n    auto* h1 = bar(timeframe::H1, 0);\n    auto* h1_prev = bar(timeframe::H1, 1);\n\n    // Or use optional-returning methods\n    auto closeOpt = close(timeframe::H1, 0);\n    if (closeOpt &amp;&amp; *closeOpt &gt; *close(timeframe::H1, 1)) {\n      // H1 closed higher\n    }\n  }\n};\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#manual-integration","title":"Manual Integration","text":"<pre><code>class MyStrategy : public IMarketDataSubscriber {\n  void onBar(const BarEvent&amp; ev) override {\n    if (ev.barType == BarType::Time &amp;&amp; ev.barTypeParam == 60) {\n      // Handle 1-minute bars\n    }\n  }\n};\n</code></pre>"},{"location":"reference/api/aggregator/bar_aggregator/#performance","title":"Performance","text":"Operation Complexity Policy shouldClose() O(1), inlined Symbol lookup O(1) via SymbolStateMap Bar history access O(1) ring buffer Timeframe lookup O(n), n \u2264 8 Bar push O(1) amortized <p>Benchmark results (GCC 14, LTO, Release):</p> <ul> <li>TimeBarAggregator.onTrade: ~45ns/trade</li> <li>MultiTimeframeAggregator (4 TF): ~15ns/timeframe (~60ns total)</li> <li>MultiTimeframeAggregator (8 TF): ~11ns/timeframe (~88ns total)</li> <li>BarMatrix random access: ~5ns</li> </ul>"},{"location":"reference/api/aggregator/bar_aggregator/#implementation-notes","title":"Implementation Notes","text":"<p><code>MultiTimeframeAggregator</code> uses tag + switch dispatch for policy execution, chosen after benchmarking against alternatives:</p> Dispatch Method ns/trade (4 TF) Notes Tag + Switch ~60ns Winner: fastest across GCC/Clang/MSVC std::variant/visit ~72ns 17-20% slower Function pointers ~85ns Indirect call overhead <p>The implementation uses:</p> <ul> <li><code>PolicyTag</code> enum for runtime type discrimination</li> <li><code>PolicyStorage</code> union for type-safe storage without vtables</li> <li>Single heap allocation for all slots (avoids stack overflow with large MaxTimeframes)</li> <li><code>FLOX_FORCE_INLINE</code> on hot path methods</li> </ul>"},{"location":"reference/api/aggregator/bar_aggregator/#files","title":"Files","text":"File Description <code>aggregator/bar.h</code> Bar struct, BarType, BarCloseReason <code>aggregator/timeframe.h</code> TimeframeId, presets <code>aggregator/aggregation_policy.h</code> BarPolicy concept <code>aggregator/bar_aggregator.h</code> BarAggregator template <code>aggregator/multi_timeframe_aggregator.h</code> Multi-TF aggregator <code>aggregator/bar_series.h</code> Ring buffer for history <code>aggregator/bar_matrix.h</code> Multi-symbol multi-TF storage <code>aggregator/events/bar_event.h</code> BarEvent struct <code>aggregator/bus/bar_bus.h</code> EventBus <code>aggregator/policies/*.h</code> Time, Tick, Volume, Renko, Range policies"},{"location":"reference/api/aggregator/bar_aggregator/#see-also","title":"See Also","text":"<ul> <li>Volume Profile - Volume distribution analysis</li> <li>Footprint Chart - Order flow analysis</li> <li>Market Profile - TPO-based session analysis</li> </ul>"},{"location":"reference/api/aggregator/footprint_chart/","title":"Footprint Chart","text":"<p>Footprint charts track bid and ask volume separately at each price level, enabling detailed order flow analysis and imbalance detection.</p>"},{"location":"reference/api/aggregator/footprint_chart/#overview","title":"Overview","text":"<pre><code>#include \"flox/aggregator/custom/footprint_bar.h\"\n\nFootprintBar&lt;64&gt; footprint;\nfootprint.setTickSize(Price::fromDouble(0.50));\n\n// Add trades\nfootprint.addTrade(tradeEvent);\n\n// Analyze\nQuantity delta = footprint.totalDelta();\nPrice buyPressure = footprint.highestBuyingPressure();\nPrice sellPressure = footprint.highestSellingPressure();\nPrice imbalance = footprint.strongestImbalance(0.7);\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#key-concepts","title":"Key Concepts","text":""},{"location":"reference/api/aggregator/footprint_chart/#bid-vs-ask-volume","title":"Bid vs Ask Volume","text":"<ul> <li>Ask Volume: Buy market orders hitting the ask (aggressive buyers)</li> <li>Bid Volume: Sell market orders hitting the bid (aggressive sellers)</li> </ul> <pre><code>const auto* level = footprint.levelAt(price);\nQuantity askVol = level-&gt;askVolume;  // Buyers\nQuantity bidVol = level-&gt;bidVolume;  // Sellers\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#delta","title":"Delta","text":"<p>The difference between buying and selling aggression at each level:</p> <pre><code>Quantity levelDelta = level-&gt;delta();      // askVolume - bidVolume\nQuantity totalDelta = footprint.totalDelta();\n</code></pre> <p>Positive delta = more aggressive buyers. Negative delta = more aggressive sellers.</p>"},{"location":"reference/api/aggregator/footprint_chart/#imbalance","title":"Imbalance","text":"<p>When one side dominates at a price level:</p> <pre><code>double ratio = level-&gt;imbalanceRatio();  // askVolume / totalVolume\n\nif (ratio &gt; 0.7) {\n  // Strong buying (70%+ ask volume)\n} else if (ratio &lt; 0.3) {\n  // Strong selling (70%+ bid volume)\n}\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#api-reference","title":"API Reference","text":""},{"location":"reference/api/aggregator/footprint_chart/#configuration","title":"Configuration","text":"<pre><code>FootprintBar&lt;MaxLevels&gt; footprint;\nfootprint.setTickSize(Price::fromDouble(0.25));  // Price quantization\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#adding-trades","title":"Adding Trades","text":"<pre><code>footprint.addTrade(tradeEvent);\n</code></pre> <p>Trade is classified as: - <code>isBuy = true</code> \u2192 Ask volume (buyer aggression) - <code>isBuy = false</code> \u2192 Bid volume (seller aggression)</p>"},{"location":"reference/api/aggregator/footprint_chart/#aggregate-metrics","title":"Aggregate Metrics","text":"<pre><code>Quantity delta = footprint.totalDelta();     // Sum of all level deltas\nQuantity volume = footprint.totalVolume();   // Total volume (bid + ask)\nsize_t levels = footprint.numLevels();       // Active price levels\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#level-access","title":"Level Access","text":"<pre><code>// By index\nconst Level* lvl = footprint.level(0);\n\n// By price\nconst Level* lvl = footprint.levelAt(Price::fromDouble(100.0));\n\n// Level structure\nstruct Level {\n  Price price;\n  Quantity bidVolume;   // Sellers hitting bid\n  Quantity askVolume;   // Buyers lifting ask\n\n  Quantity totalVolume() const;    // bid + ask\n  Quantity delta() const;          // ask - bid\n  double imbalanceRatio() const;   // ask / total (0.0 to 1.0)\n  bool isSinglePrint() const;      // Only one TPO (for market profile)\n};\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#key-levels","title":"Key Levels","text":"<pre><code>// Price with most aggressive buying\nPrice buyPressure = footprint.highestBuyingPressure();\n\n// Price with most aggressive selling\nPrice sellPressure = footprint.highestSellingPressure();\n\n// Strongest imbalance above threshold\nPrice imbalance = footprint.strongestImbalance(0.7);\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#reset","title":"Reset","text":"<pre><code>footprint.clear();\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#trading-strategies","title":"Trading Strategies","text":""},{"location":"reference/api/aggregator/footprint_chart/#supportresistance-from-imbalances","title":"Support/Resistance from Imbalances","text":"<pre><code>Price buyImbalance = footprint.strongestImbalance(0.7);\nPrice sellImbalance = footprint.strongestImbalance(0.3);\n\n// Strong buying = potential support\n// Strong selling = potential resistance\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#delta-divergence","title":"Delta Divergence","text":"<pre><code>void onBar(const BarEvent&amp; ev) {\n  if (ev.bar.close &gt; ev.bar.open) {  // Up bar\n    if (footprint.totalDelta().raw() &lt; 0) {\n      // Price up but sellers dominate - bearish divergence\n    }\n  }\n}\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#absorption-detection","title":"Absorption Detection","text":"<pre><code>const auto* highLevel = footprint.levelAt(highPrice);\nif (highLevel &amp;&amp; highLevel-&gt;bidVolume.raw() &gt; highLevel-&gt;askVolume.raw() * 2) {\n  // Heavy selling absorbed at high - potential reversal\n}\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#footprint-visualization","title":"Footprint Visualization","text":"<pre><code>+--------+--------+--------+--------+\n| Price  |  Bid   |  Ask   | Delta  |\n+--------+--------+--------+--------+\n|  101.0 |   18.0 |    2.0 | - 16.0 |  &lt;- Heavy selling\n|  100.5 |    4.0 |    5.0 | +  1.0 |\n|  100.0 |    3.0 |   27.0 | + 24.0 |  &lt;- Heavy buying\n|   99.5 |    6.0 |    4.0 | -  2.0 |\n|   99.0 |    8.0 |    3.0 | -  5.0 |\n+--------+--------+--------+--------+\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#combining-with-bars","title":"Combining with Bars","text":"<p>Reset footprint at each bar close to get per-bar order flow:</p> <pre><code>FootprintBar&lt;64&gt; currentFootprint;\n\nvoid onTrade(const TradeEvent&amp; ev) {\n  currentFootprint.addTrade(ev);\n}\n\nvoid onBar(const BarEvent&amp; ev) {\n  // Analyze footprint for completed bar\n  Quantity delta = currentFootprint.totalDelta();\n  Price imbalance = currentFootprint.strongestImbalance();\n\n  // Store for later analysis\n  footprintHistory.push_back({ev.bar, currentFootprint});\n\n  // Reset for next bar\n  currentFootprint.clear();\n}\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#performance","title":"Performance","text":"Operation Complexity addTrade O(n) worst case totalDelta O(n) highestBuyingPressure O(n) strongestImbalance O(n) levelAt O(n) <p>Where n = number of active price levels (\u2264 MaxLevels).</p>"},{"location":"reference/api/aggregator/footprint_chart/#example-output","title":"Example Output","text":"<pre><code>=== Order Flow Analysis ===\nTotal Volume: 80\nTotal Delta:  2\n\nHighest buying pressure:  $100\nHighest selling pressure: $101\n\nStrong imbalance at $100 (ratio: 90% buy)\n\n=== Trading Signals ===\n[BIAS] Bullish - Net buying pressure\n[SUPPORT] Strong buying at $100.0 - potential support\n[RESISTANCE] Strong selling at $101.0 - potential resistance\n</code></pre>"},{"location":"reference/api/aggregator/footprint_chart/#files","title":"Files","text":"File Description <code>aggregator/custom/footprint_bar.h</code> FootprintBar template"},{"location":"reference/api/aggregator/footprint_chart/#see-also","title":"See Also","text":"<ul> <li>Volume Profile - Aggregate volume distribution</li> <li>Market Profile - Time-based analysis (TPO)</li> <li>Bar Aggregator - OHLCV bar generation</li> </ul>"},{"location":"reference/api/aggregator/market_profile/","title":"Market Profile (TPO)","text":"<p>Market Profile tracks price activity across time periods using TPO (Time Price Opportunity) analysis. Each time period is assigned a letter (A, B, C...) and the profile shows which prices were visited during each period.</p>"},{"location":"reference/api/aggregator/market_profile/#overview","title":"Overview","text":"<pre><code>#include \"flox/aggregator/custom/market_profile.h\"\n\nMarketProfile&lt;256, 26&gt; profile;  // 256 price levels, 26 periods (A-Z)\nprofile.setTickSize(Price::fromDouble(1.0));\nprofile.setPeriodDuration(std::chrono::minutes(30));\nprofile.setSessionStart(sessionOpenNanoseconds);\n\n// Add trades\nprofile.addTrade(tradeEvent);\n\n// Analyze\nPrice poc = profile.poc();              // Point of Control\nPrice vaLow = profile.valueAreaLow();   // Value Area Low\nPrice vaHigh = profile.valueAreaHigh(); // Value Area High\nPrice ibLow = profile.initialBalanceLow();   // Initial Balance Low\nPrice ibHigh = profile.initialBalanceHigh(); // Initial Balance High\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#key-concepts","title":"Key Concepts","text":""},{"location":"reference/api/aggregator/market_profile/#tpo-time-price-opportunity","title":"TPO (Time Price Opportunity)","text":"<p>Each time price visits a level during a period, it creates a TPO. A price with multiple TPOs indicates acceptance; single TPOs indicate rejection.</p> <pre><code>const auto* level = profile.levelAt(price);\nuint32_t tpoCount = level-&gt;tpoCount;    // Number of periods at this price\nbool singlePrint = level-&gt;isSinglePrint();  // Only one period\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#point-of-control-poc","title":"Point of Control (POC)","text":"<p>The price with the most TPOs (not volume, unlike Volume Profile):</p> <pre><code>Price poc = profile.poc();\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#value-area-va","title":"Value Area (VA)","text":"<p>Price range containing 70% of all TPOs:</p> <pre><code>Price vaLow = profile.valueAreaLow();\nPrice vaHigh = profile.valueAreaHigh();\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#initial-balance-ib","title":"Initial Balance (IB)","text":"<p>The price range established in the first hour of trading (periods A + B):</p> <pre><code>Price ibLow = profile.initialBalanceLow();\nPrice ibHigh = profile.initialBalanceHigh();\n\n// IB range predicts day type\nPrice ibRange = Price::fromRaw(ibHigh.raw() - ibLow.raw());\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#single-prints","title":"Single Prints","text":"<p>Prices visited only once (single TPO). Often act as support/resistance:</p> <pre><code>auto [count, prices] = profile.singlePrints();\nfor (size_t i = 0; i &lt; count; ++i) {\n  // prices[i] is a potential S/R level\n}\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#poor-highslows","title":"Poor Highs/Lows","text":"<p>When the session high or low is a single print, it indicates weak rejection:</p> <pre><code>if (profile.isPoorHigh()) {\n  // Session high only visited once - weak resistance\n}\nif (profile.isPoorLow()) {\n  // Session low only visited once - weak support\n}\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#api-reference","title":"API Reference","text":""},{"location":"reference/api/aggregator/market_profile/#configuration","title":"Configuration","text":"<pre><code>MarketProfile&lt;MaxLevels, MaxPeriods&gt; profile;\n\nprofile.setTickSize(Price::fromDouble(0.25));\nprofile.setPeriodDuration(std::chrono::minutes(30));\nprofile.setSessionStart(sessionStartNs);  // Unix nanoseconds\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#adding-trades","title":"Adding Trades","text":"<pre><code>profile.addTrade(tradeEvent);\n</code></pre> <p>The period is calculated from <code>(tradeTs - sessionStart) / periodDuration</code>.</p>"},{"location":"reference/api/aggregator/market_profile/#key-levels","title":"Key Levels","text":"<pre><code>Price poc = profile.poc();\nPrice vaLow = profile.valueAreaLow();\nPrice vaHigh = profile.valueAreaHigh();\nPrice ibLow = profile.initialBalanceLow();\nPrice ibHigh = profile.initialBalanceHigh();\nPrice high = profile.highPrice();\nPrice low = profile.lowPrice();\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#structure-analysis","title":"Structure Analysis","text":"<pre><code>bool poorHigh = profile.isPoorHigh();   // Single TPO at high\nbool poorLow = profile.isPoorLow();     // Single TPO at low\n\nauto [count, singles] = profile.singlePrints();  // All single prints\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#level-access","title":"Level Access","text":"<pre><code>// By index\nconst Level* lvl = profile.level(0);\n\n// By price\nconst Level* lvl = profile.levelAt(price);\nuint32_t tpos = profile.tpoCountAt(price);\n\n// Level structure\nstruct Level {\n  Price price;\n  std::bitset&lt;MaxPeriods&gt; tpos;  // Which periods traded here\n  uint32_t tpoCount;             // Number of active periods\n\n  bool hasPeriod(size_t period) const;  // Did period trade here?\n  bool isSinglePrint() const;           // Only one TPO\n};\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#period-info","title":"Period Info","text":"<pre><code>size_t currentPeriod = profile.currentPeriod();  // Latest active period\nchar letter = MarketProfile&lt;&gt;::periodLetter(0);  // 'A'\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#reset","title":"Reset","text":"<pre><code>profile.clear();\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#trading-strategies","title":"Trading Strategies","text":""},{"location":"reference/api/aggregator/market_profile/#value-area-trading","title":"Value Area Trading","text":"<pre><code>Price vaLow = profile.valueAreaLow();\nPrice vaHigh = profile.valueAreaHigh();\nPrice close = currentPrice;\n\nif (close &lt; vaLow) {\n  // Below value - expect rotation back to POC\n  // Look for long entries\n} else if (close &gt; vaHigh) {\n  // Above value - expect rotation back to POC\n  // Look for short entries\n}\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#ib-breakout","title":"IB Breakout","text":"<pre><code>Price ibLow = profile.initialBalanceLow();\nPrice ibHigh = profile.initialBalanceHigh();\n\nif (currentPrice &gt; ibHigh) {\n  // IB breakout up - trend day potential\n} else if (currentPrice &lt; ibLow) {\n  // IB breakout down - trend day potential\n}\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#single-print-fade","title":"Single Print Fade","text":"<pre><code>auto [count, singles] = profile.singlePrints();\n\nfor (size_t i = 0; i &lt; count; ++i) {\n  if (currentPrice &gt; singles[i]) {\n    // Price above single print - potential support\n  }\n}\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#poor-highlow-continuation","title":"Poor High/Low Continuation","text":"<pre><code>if (profile.isPoorHigh() &amp;&amp; currentPrice &gt; profile.highPrice()) {\n  // Poor high broken - continuation likely\n}\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#profile-visualization","title":"Profile Visualization","text":"<pre><code> Price  | TPOs              | Markers\n--------+-------------------+---------\n 105.0  | D                 | &lt;HIGH&gt;\n 104.0  | BD                | &lt;IBH&gt;\n 103.0  | ABCDEF            | &lt;POC&gt; &lt;VAH&gt;\n 102.0  | ABCDEF            |\n 101.0  | ABCEF             |\n 100.0  | ABCF              | &lt;VAL&gt;\n  99.0  | A                 |\n  98.0  | A                 | &lt;IBL&gt; &lt;LOW&gt;\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#day-types","title":"Day Types","text":"<p>Based on IB extension and value area:</p> Day Type Characteristic Trading Approach Normal Most volume in middle, balanced Fade extremes to POC Normal Variation Slight extension one side Trade with extension Trend Strong extension, poor high/low Trade breakouts Double Distribution Two value areas Trade between them P-Shape Wide base, narrow top Shorts at top b-Shape Narrow base, wide top Longs at bottom"},{"location":"reference/api/aggregator/market_profile/#performance","title":"Performance","text":"Operation Complexity addTrade O(n) worst case poc O(n) valueAreaLow/High O(n log n) singlePrints O(n) isPoorHigh/Low O(n) <p>Where n = number of active price levels (\u2264 MaxLevels).</p>"},{"location":"reference/api/aggregator/market_profile/#example-output","title":"Example Output","text":"<pre><code>=== Profile Analysis ===\nSession High: $105\nSession Low:  $98\nPOC:          $103\nValue Area:   $100 - $103\nInitial Balance: $98 - $104\n\n=== Structure Analysis ===\n[WARNING] Poor high detected - weak resistance\n[OK] Strong low - good support\n\n=== Single Prints ===\n  $98\n  $99\n  $105\n\n=== Trading Signals ===\n[STRATEGY] Fade extremes, trade to value\n  - If price above VAH ($103): Look for shorts to POC\n  - If price below VAL ($100): Look for longs to POC\n</code></pre>"},{"location":"reference/api/aggregator/market_profile/#files","title":"Files","text":"File Description <code>aggregator/custom/market_profile.h</code> MarketProfile template"},{"location":"reference/api/aggregator/market_profile/#see-also","title":"See Also","text":"<ul> <li>Volume Profile - Volume-based distribution</li> <li>Footprint Chart - Order flow analysis</li> <li>Bar Aggregator - OHLCV bar generation</li> </ul>"},{"location":"reference/api/aggregator/volume_profile/","title":"Volume Profile","text":"<p>Volume Profile tracks the distribution of volume across price levels, providing insights into market structure and key support/resistance zones.</p>"},{"location":"reference/api/aggregator/volume_profile/#overview","title":"Overview","text":"<pre><code>#include \"flox/aggregator/custom/volume_profile.h\"\n\nVolumeProfile&lt;256&gt; profile;\nprofile.setTickSize(Price::fromDouble(0.50));  // Aggregate to $0.50 levels\n\n// Add trades\nprofile.addTrade(tradeEvent);\n\n// Analyze\nPrice poc = profile.poc();              // Point of Control\nPrice vaLow = profile.valueAreaLow();   // Value Area Low\nPrice vaHigh = profile.valueAreaHigh(); // Value Area High\nVolume delta = profile.totalDelta();    // Buy - Sell volume\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#key-concepts","title":"Key Concepts","text":""},{"location":"reference/api/aggregator/volume_profile/#point-of-control-poc","title":"Point of Control (POC)","text":"<p>The price level with the highest traded volume. Often acts as a magnet for price:</p> <pre><code>Price poc = profile.poc();\nif (currentPrice &lt; poc) {\n  // Expect price to move toward POC\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#value-area-va","title":"Value Area (VA)","text":"<p>The price range containing 70% of total volume. Represents \"fair value\":</p> <pre><code>Price vaLow = profile.valueAreaLow();\nPrice vaHigh = profile.valueAreaHigh();\n\nif (currentPrice &lt; vaLow) {\n  // Below value - potential buying opportunity\n} else if (currentPrice &gt; vaHigh) {\n  // Above value - potential selling opportunity\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#delta","title":"Delta","text":"<p>The difference between buy and sell volume. Indicates aggressor dominance:</p> <pre><code>Volume delta = profile.totalDelta();\n\nif (delta.raw() &gt; 0) {\n  // Net buying pressure - bullish\n} else {\n  // Net selling pressure - bearish\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#api-reference","title":"API Reference","text":""},{"location":"reference/api/aggregator/volume_profile/#configuration","title":"Configuration","text":"<pre><code>VolumeProfile&lt;MaxLevels&gt; profile;\n\n// Set tick size for price quantization\nprofile.setTickSize(Price::fromDouble(1.0));\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#adding-trades","title":"Adding Trades","text":"<pre><code>profile.addTrade(tradeEvent);\n</code></pre> <p>Volume is calculated as notional: <code>price * quantity</code>.</p>"},{"location":"reference/api/aggregator/volume_profile/#key-levels","title":"Key Levels","text":"<pre><code>Price poc = profile.poc();              // Highest volume price\nPrice vaLow = profile.valueAreaLow();   // Lower bound of 70% volume\nPrice vaHigh = profile.valueAreaHigh(); // Upper bound of 70% volume\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#volume-metrics","title":"Volume Metrics","text":"<pre><code>Volume total = profile.totalVolume();   // Total notional volume\nVolume delta = profile.totalDelta();    // Buy volume - Sell volume\nsize_t levels = profile.numLevels();    // Number of active price levels\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#level-access","title":"Level Access","text":"<pre><code>// By index\nconst Level* lvl = profile.level(0);\n\n// By price\nVolume vol = profile.volumeAt(Price::fromDouble(100.0));\n\n// Level structure\nstruct Level {\n  Price price;\n  Volume volume;      // Total volume at this price\n  Volume buyVolume;   // Buy-side volume\n\n  Volume sellVolume() const;  // volume - buyVolume\n  Volume delta() const;       // buyVolume - sellVolume\n};\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#reset","title":"Reset","text":"<pre><code>profile.clear();  // Reset for new session\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#trading-strategies","title":"Trading Strategies","text":""},{"location":"reference/api/aggregator/volume_profile/#mean-reversion-to-poc","title":"Mean Reversion to POC","text":"<pre><code>void onTrade(const TradeEvent&amp; ev) {\n  profile.addTrade(ev);\n\n  Price poc = profile.poc();\n  Price price = ev.trade.price;\n\n  if (price.raw() &lt; poc.raw() * 0.995) {  // 0.5% below POC\n    // Buy signal - expect reversion to POC\n  }\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#value-area-fade","title":"Value Area Fade","text":"<pre><code>void onBar(const BarEvent&amp; ev) {\n  Price vaLow = profile.valueAreaLow();\n  Price vaHigh = profile.valueAreaHigh();\n  Price close = ev.bar.close;\n\n  if (close &lt; vaLow) {\n    // Price below value - look for long entries\n  } else if (close &gt; vaHigh) {\n    // Price above value - look for short entries\n  }\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#delta-confirmation","title":"Delta Confirmation","text":"<pre><code>Volume delta = profile.totalDelta();\nVolume volumeAtPrice = profile.volumeAt(currentPrice);\n\nif (delta.raw() &gt; 0 &amp;&amp; volumeAtPrice.raw() &gt; avgVolume) {\n  // Bullish with high volume confirmation\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#multi-session-profiles","title":"Multi-Session Profiles","text":"<p>Build composite profiles from multiple sessions:</p> <pre><code>VolumeProfile&lt;256&gt; dailyProfile;\nVolumeProfile&lt;256&gt; weeklyProfile;\n\nvoid onSessionEnd() {\n  // Transfer daily levels to weekly\n  for (size_t i = 0; i &lt; dailyProfile.numLevels(); ++i) {\n    const auto* lvl = dailyProfile.level(i);\n    // Add to weekly...\n  }\n  dailyProfile.clear();\n}\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#performance","title":"Performance","text":"Operation Complexity addTrade O(n) worst case, O(1) average poc O(n) valueAreaLow/High O(n log n) volumeAt O(n) <p>Where n = number of active price levels (\u2264 MaxLevels).</p>"},{"location":"reference/api/aggregator/volume_profile/#example-output","title":"Example Output","text":"<pre><code>=== Volume Profile Analysis ===\nTotal volume: $279786\nTotal delta:  $16549.9\nPOC:          $100\nValue Area:   $97 - $103\nLevels:       19\n\nTop volume levels:\n  $100 | Vol: $37405 | Delta: $4403\n  $99  | Vol: $33570 | Delta: $4090\n  $101 | Vol: $33311 | Delta: $2222\n</code></pre>"},{"location":"reference/api/aggregator/volume_profile/#files","title":"Files","text":"File Description <code>aggregator/custom/volume_profile.h</code> VolumeProfile template"},{"location":"reference/api/aggregator/volume_profile/#see-also","title":"See Also","text":"<ul> <li>Footprint Chart - Bid/ask volume at each level</li> <li>Market Profile - Time-based distribution (TPO)</li> <li>Bar Aggregator - OHLCV bar generation</li> </ul>"},{"location":"reference/api/aggregator/bus/bar_bus/","title":"BarBus","text":"<p><code>BarBus</code> is the event bus for distributing <code>BarEvent</code> to subscribers.</p> <pre><code>using BarBus = EventBus&lt;BarEvent&gt;;\n\nstd::unique_ptr&lt;BarBus&gt; createOptimalBarBus(bool enablePerformanceOptimizations = false);\nbool configureBarBusForPerformance(BarBus&amp; bus, bool enablePerformanceOptimizations = false);\n</code></pre>"},{"location":"reference/api/aggregator/bus/bar_bus/#factory-functions","title":"Factory Functions","text":""},{"location":"reference/api/aggregator/bus/bar_bus/#createoptimalbarbus","title":"createOptimalBarBus","text":"<p>Creates a new <code>BarBus</code> with optional CPU affinity optimization.</p> <pre><code>auto bus = createOptimalBarBus(true);  // Enable performance optimizations\n</code></pre>"},{"location":"reference/api/aggregator/bus/bar_bus/#configurebarbusforperformance","title":"configureBarBusForPerformance","text":"<p>Configures an existing <code>BarBus</code> for optimal performance.</p> <pre><code>BarBus bus;\nconfigureBarBusForPerformance(bus, true);\n</code></pre>"},{"location":"reference/api/aggregator/bus/bar_bus/#example-usage","title":"Example Usage","text":"<pre><code>BarBus bus;\nbus.enableDrainOnStop();  // Flush pending bars on stop\n\n// Subscribe a strategy\nbus.subscribe(&amp;myStrategy);\n\nbus.start();\n\n// Bars are published by BarAggregator\n// myStrategy.onBar() receives BarEvent\n\nbus.stop();\n</code></pre>"},{"location":"reference/api/aggregator/bus/bar_bus/#see-also","title":"See Also","text":"<ul> <li>BarEvent \u2014 Event structure</li> <li>Bar \u2014 Bar data structure</li> <li>EventBus \u2014 Generic event bus</li> </ul>"},{"location":"reference/api/aggregator/events/bar_event/","title":"BarEvent","text":"<p><code>BarEvent</code> is the event wrapper for delivering completed bars through the event bus system.</p> <pre><code>struct BarEvent {\n  using Listener = IMarketDataSubscriber;\n\n  SymbolId symbol{};\n  InstrumentType instrument = InstrumentType::Spot;\n  BarType barType{};\n  uint64_t barTypeParam{};  // interval in nanoseconds, tick count, volume threshold, etc.\n  Bar bar{};\n\n  uint64_t tickSequence = 0;  // internal, set by bus\n};\n</code></pre>"},{"location":"reference/api/aggregator/events/bar_event/#fields","title":"Fields","text":"Field Type Description <code>symbol</code> <code>SymbolId</code> Symbol identifier for this bar. <code>instrument</code> <code>InstrumentType</code> Instrument type (Spot, Perpetual, etc.). <code>barType</code> <code>BarType</code> Type of bar (Time, Tick, Volume, etc.). <code>barTypeParam</code> <code>uint64_t</code> Bar-type-specific parameter (see below). <code>bar</code> <code>Bar</code> The actual OHLCV bar data. <code>tickSequence</code> <code>uint64_t</code> Internal sequence number, set by bus."},{"location":"reference/api/aggregator/events/bar_event/#bartypeparam-interpretation","title":"barTypeParam Interpretation","text":"<p>The meaning of <code>barTypeParam</code> depends on <code>barType</code>:</p> BarType barTypeParam Meaning <code>Time</code> Interval in nanoseconds <code>Tick</code> Number of trades per bar <code>Volume</code> Volume threshold (raw) <code>Renko</code> Brick size (raw price) <code>Range</code> Range threshold (raw price) <code>HeikinAshi</code> Interval in nanoseconds"},{"location":"reference/api/aggregator/events/bar_event/#example-usage","title":"Example Usage","text":"<pre><code>void onBar(const BarEvent&amp; ev) override {\n  if (ev.barType == BarType::Time) {\n    auto intervalNs = ev.barTypeParam;\n    auto intervalSec = intervalNs / 1'000'000'000;\n    // Handle time bar\n  }\n\n  // Access bar data\n  Price close = ev.bar.close;\n  Volume delta = ev.bar.buyVolume;\n}\n</code></pre>"},{"location":"reference/api/aggregator/events/bar_event/#see-also","title":"See Also","text":"<ul> <li>Bar \u2014 Bar data structure</li> <li>BarBus \u2014 Event bus for bar distribution</li> <li>IMarketDataSubscriber \u2014 Listener interface</li> </ul>"},{"location":"reference/api/backtest/backtest_optimizer/","title":"BacktestOptimizer","text":"<p>Grid search optimizer for strategy parameter tuning.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#overview","title":"Overview","text":"<p><code>BacktestOptimizer</code> runs exhaustive parameter search by executing backtests for all combinations in a parameter grid and collecting results for analysis.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#header","title":"Header","text":"<pre><code>#include \"flox/backtest/backtest_optimizer.h\"\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#template-parameters","title":"Template Parameters","text":"<pre><code>template &lt;typename ParamsT, typename GridT&gt;\nclass BacktestOptimizer;\n</code></pre> <ul> <li><code>ParamsT</code> - Parameter struct, must have <code>toString()</code> method</li> <li><code>GridT</code> - Grid type, must implement <code>totalCombinations()</code> and <code>operator[]</code></li> </ul>"},{"location":"reference/api/backtest/backtest_optimizer/#class-definition","title":"Class Definition","text":"<pre><code>template &lt;typename ParamsT, typename GridT&gt;\nclass BacktestOptimizer {\npublic:\n  using BacktestFactory = MoveOnlyFunction&lt;BacktestResult(const ParamsT&amp;)&gt;;\n  using ProgressCallback = MoveOnlyFunction&lt;void(size_t, size_t, const OptimizationResult&lt;ParamsT&gt;&amp;)&gt;;\n\n  BacktestOptimizer() = default;\n\n  void setParameterGrid(const GridT&amp; grid);\n  void setBacktestFactory(BacktestFactory factory);\n  void setProgressCallback(ProgressCallback callback);\n\n  size_t totalCombinations() const;\n\n  std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; runLocal(size_t numThreads = 0);\n  OptimizationResult&lt;ParamsT&gt; runSingle(size_t index);\n\n  static std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; rankResults(\n      std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; results,\n      RankMetric metric,\n      bool ascending = false);\n\n  template &lt;typename Predicate&gt;\n  static std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; filterResults(\n      const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n      Predicate&amp;&amp; predicate);\n\n  static bool exportToCSV(\n      const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n      const std::filesystem::path&amp; path);\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#grid-requirements","title":"Grid Requirements","text":"<pre><code>struct MyGrid {\n  size_t totalCombinations() const;        // Total param combinations\n  MyParams operator[](size_t index) const; // Get params at index\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#params-requirements","title":"Params Requirements","text":"<pre><code>struct MyParams {\n  std::string toString() const;  // For CSV export\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#methods","title":"Methods","text":""},{"location":"reference/api/backtest/backtest_optimizer/#setparametergrid","title":"setParameterGrid","text":"<pre><code>void setParameterGrid(const GridT&amp; grid);\n</code></pre> <p>Set the parameter grid to search.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#setbacktestfactory","title":"setBacktestFactory","text":"<pre><code>void setBacktestFactory(BacktestFactory factory);\n</code></pre> <p>Set function that creates and runs a backtest for given parameters.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#setprogresscallback","title":"setProgressCallback","text":"<pre><code>void setProgressCallback(ProgressCallback callback);\n</code></pre> <p>Optional callback invoked periodically during optimization.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#runlocal","title":"runLocal","text":"<pre><code>std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; runLocal(size_t numThreads = 0);\n</code></pre> <p>Run all backtests. Returns empty vector if no factory set or grid is empty.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#runsingle","title":"runSingle","text":"<pre><code>OptimizationResult&lt;ParamsT&gt; runSingle(size_t index);\n</code></pre> <p>Run single backtest at grid index.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#rankresults-static","title":"rankResults (static)","text":"<pre><code>static std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; rankResults(\n    std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; results,\n    RankMetric metric,\n    bool ascending = false);\n</code></pre> <p>Sort results by metric. Descending by default (best first).</p>"},{"location":"reference/api/backtest/backtest_optimizer/#filterresults-static","title":"filterResults (static)","text":"<pre><code>template &lt;typename Predicate&gt;\nstatic std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt; filterResults(\n    const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n    Predicate&amp;&amp; predicate);\n</code></pre> <p>Filter results matching predicate.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#exporttocsv-static","title":"exportToCSV (static)","text":"<pre><code>static bool exportToCSV(\n    const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n    const std::filesystem::path&amp; path);\n</code></pre> <p>Export results to CSV file. Returns false on error.</p>"},{"location":"reference/api/backtest/backtest_optimizer/#rankmetric","title":"RankMetric","text":"<pre><code>enum class RankMetric {\n  SharpeRatio,\n  SortinoRatio,\n  CalmarRatio,\n  TotalReturn,\n  MaxDrawdown,\n  WinRate,\n  ProfitFactor\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#optimizationresult","title":"OptimizationResult","text":"<pre><code>template &lt;typename ParamsT&gt;\nstruct OptimizationResult {\n  ParamsT parameters;\n  BacktestStats stats;\n\n  double sharpeRatio() const;\n  double sortinoRatio() const;\n  double calmarRatio() const;\n  double totalReturn() const;\n  double maxDrawdown() const;\n  double maxDrawdownPct() const;\n  double winRate() const;\n  double profitFactor() const;\n  size_t totalTrades() const;\n\n  void setFromStats(const BacktestStats&amp; s);\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#example","title":"Example","text":"<pre><code>struct MAParams {\n  int fast, slow;\n  std::string toString() const {\n    return std::to_string(fast) + \",\" + std::to_string(slow);\n  }\n};\n\nstruct MAGrid {\n  std::vector&lt;int&gt; fasts = {5, 10, 15};\n  std::vector&lt;int&gt; slows = {20, 30, 40};\n  size_t totalCombinations() const { return fasts.size() * slows.size(); }\n  MAParams operator[](size_t i) const {\n    return {fasts[i / slows.size()], slows[i % slows.size()]};\n  }\n};\n\nBacktestOptimizer&lt;MAParams, MAGrid&gt; opt;\nopt.setParameterGrid(MAGrid{});\nopt.setBacktestFactory([](const MAParams&amp; p) {\n  return runMyStrategy(p);\n});\n\nauto results = opt.runLocal();\nauto ranked = decltype(opt)::rankResults(results, RankMetric::SharpeRatio);\ndecltype(opt)::exportToCSV(ranked, \"results.csv\");\n</code></pre>"},{"location":"reference/api/backtest/backtest_optimizer/#see-also","title":"See Also","text":"<ul> <li>optimization_stats.h</li> <li>BacktestResult</li> <li>How-to: Grid Search</li> </ul>"},{"location":"reference/api/backtest/backtest_result/","title":"BacktestResult","text":"<p><code>BacktestResult</code> collects fills during backtest execution and computes performance statistics.</p>"},{"location":"reference/api/backtest/backtest_result/#backtestconfig","title":"BacktestConfig","text":"<pre><code>struct BacktestConfig\n{\n  double initialCapital{100000.0};\n  double feeRate{0.0001};        // 0.01% per trade\n  bool usePercentageFee{true};\n  double fixedFeePerTrade{0.0};\n};\n</code></pre> Field Default Description <code>initialCapital</code> 100000.0 Starting capital <code>feeRate</code> 0.0001 Fee as fraction of notional (0.01%) <code>usePercentageFee</code> true Use percentage fee vs fixed <code>fixedFeePerTrade</code> 0.0 Fixed fee per trade"},{"location":"reference/api/backtest/backtest_result/#backteststats","title":"BacktestStats","text":"<pre><code>struct BacktestStats\n{\n  size_t totalTrades{0};\n  size_t winningTrades{0};\n  size_t losingTrades{0};\n\n  double initialCapital{0.0};\n  double finalCapital{0.0};\n  double totalPnl{0.0};\n  double totalFees{0.0};\n  double netPnl{0.0};\n  double grossProfit{0.0};\n  double grossLoss{0.0};\n\n  double maxDrawdown{0.0};\n  double maxDrawdownPct{0.0};\n\n  double winRate{0.0};\n  double profitFactor{0.0};\n  double avgWin{0.0};\n  double avgLoss{0.0};\n\n  double sharpeRatio{0.0};\n  double returnPct{0.0};\n\n  UnixNanos startTimeNs{0};\n  UnixNanos endTimeNs{0};\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_result/#backtestresult_1","title":"BacktestResult","text":"<pre><code>class BacktestResult\n{\npublic:\n  explicit BacktestResult(const BacktestConfig&amp; config = {}, size_t expectedFills = 16384);\n\n  void recordFill(const Fill&amp; fill);\n  BacktestStats computeStats() const noexcept;\n\n  const std::vector&lt;Fill&gt;&amp; fills() const noexcept;\n  const std::vector&lt;TradeRecord&gt;&amp; trades() const noexcept;\n  double totalPnl() const noexcept;\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_result/#metrics","title":"Metrics","text":"Metric Formula <code>netPnl</code> <code>totalPnl - totalFees</code> <code>returnPct</code> <code>(netPnl / initialCapital) * 100</code> <code>winRate</code> <code>winningTrades / totalTrades</code> <code>profitFactor</code> <code>grossProfit / grossLoss</code> <code>avgWin</code> <code>grossProfit / winningTrades</code> <code>avgLoss</code> <code>grossLoss / losingTrades</code> <code>maxDrawdownPct</code> <code>maxDrawdown / peakEquity * 100</code> <code>sharpeRatio</code> <code>mean(returns) / std(returns) * sqrt(252)</code>"},{"location":"reference/api/backtest/backtest_result/#fee-calculation","title":"Fee Calculation","text":"<pre><code>// Percentage fee (default)\nfee = price * quantity * feeRate\n\n// Fixed fee\nfee = fixedFeePerTrade\n</code></pre>"},{"location":"reference/api/backtest/backtest_result/#usage","title":"Usage","text":"<pre><code>auto stats = result.computeStats();\n\nstd::cout &lt;&lt; \"Return: \" &lt;&lt; stats.returnPct &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Sharpe: \" &lt;&lt; stats.sharpeRatio &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Max DD: \" &lt;&lt; stats.maxDrawdownPct &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Win rate: \" &lt;&lt; stats.winRate * 100 &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Profit factor: \" &lt;&lt; stats.profitFactor &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/backtest/backtest_runner/","title":"BacktestRunner","text":"<p><code>BacktestRunner</code> replays historical market data through a strategy, simulates order execution, and collects performance statistics. Supports both batch and interactive modes.</p> <pre><code>class BacktestRunner : public ISignalHandler\n{\npublic:\n  using EventCallback = std::function&lt;void(const replay::ReplayEvent&amp;, const BacktestState&amp;)&gt;;\n  using PauseCallback = std::function&lt;void(const BacktestState&amp;)&gt;;\n\n  explicit BacktestRunner(const BacktestConfig&amp; config = {});\n\n  // Strategy setup\n  void setStrategy(IStrategy* strategy);\n  void addMarketDataSubscriber(IMarketDataSubscriber* subscriber);\n  void addExecutionListener(IOrderExecutionListener* listener);\n\n  // Non-interactive mode\n  BacktestResult run(replay::IMultiSegmentReader&amp; reader);\n\n  // Interactive mode\n  void start(replay::IMultiSegmentReader&amp; reader);\n  void resume();\n  void step();\n  void stepUntil(BacktestMode mode);\n  void pause();\n  void stop();\n\n  // Breakpoints\n  void addBreakpoint(Breakpoint bp);\n  void clearBreakpoints();\n  void setBreakOnSignal(bool enable);\n\n  // State inspection\n  BacktestState state() const;\n  bool isPaused() const;\n  bool isFinished() const;\n\n  // Callbacks (interactive mode)\n  void setEventCallback(EventCallback cb);\n  void setPauseCallback(PauseCallback cb);\n\n  // Results\n  BacktestResult result() const;\n  BacktestResult extractResult();  // Move results out (clears internal state)\n\n  // ISignalHandler\n  void onSignal(const Signal&amp; signal) override;\n\n  // Access internals\n  SimulatedExecutor&amp; executor() noexcept;\n  IClock&amp; clock() noexcept;\n  const BacktestConfig&amp; config() const noexcept;\n};\n</code></pre>"},{"location":"reference/api/backtest/backtest_runner/#two-modes","title":"Two Modes","text":""},{"location":"reference/api/backtest/backtest_runner/#non-interactive-mode","title":"Non-Interactive Mode","text":"<p>Synchronous execution from start to end:</p> <pre><code>BacktestRunner runner(config);\nrunner.setStrategy(&amp;strategy);\n\n// Blocks until complete\nBacktestResult result = runner.run(*reader);\n</code></pre>"},{"location":"reference/api/backtest/backtest_runner/#interactive-mode","title":"Interactive Mode","text":"<p>Async execution with pause/step control. See Interactive Backtest Mode for full documentation.</p> <pre><code>BacktestRunner runner(config);\nrunner.setStrategy(&amp;strategy);\n\n// Start in background (begins paused)\nstd::thread t([&amp;]() { runner.start(*reader); });\n\n// Control execution\nrunner.step();    // One event\nrunner.resume();  // Run until breakpoint/end\nrunner.pause();   // Pause execution\n\nt.join();\n</code></pre>"},{"location":"reference/api/backtest/backtest_runner/#strategy-setup","title":"Strategy Setup","text":"<pre><code>void setStrategy(IStrategy* strategy);\nvoid addMarketDataSubscriber(IMarketDataSubscriber* subscriber);\n</code></pre> <p><code>setStrategy</code> connects the strategy to receive market events. Use <code>addMarketDataSubscriber</code> to add additional subscribers (e.g., bar aggregators, analytics).</p>"},{"location":"reference/api/backtest/backtest_runner/#data-flow","title":"Data Flow","text":"<pre><code>flowchart TB\n    RE[ReplayEvent] --&gt; BR[BacktestRunner]\n\n    BR --&gt; SE1[SimulatedExecutor.onTrade/onBookUpdate]\n    BR --&gt; ST[Strategy.onTrade/onBookUpdate]\n\n    ST --&gt; Emit[emitMarketBuy / emitMarketSell]\n    Emit --&gt; Signal[BacktestRunner.onSignal]\n    Signal --&gt; Submit[SimulatedExecutor.submitOrder]\n    Submit --&gt; Fill[Fill]\n    Fill --&gt; Result[BacktestResult]</code></pre>"},{"location":"reference/api/backtest/backtest_runner/#usage","title":"Usage","text":"<pre><code>// 1. Config\nBacktestConfig config;\nconfig.initialCapital = 10000.0;\nconfig.feeRate = 0.0004;\n\nBacktestRunner runner(config);\n\n// 2. Strategy\nMyStrategy strategy(/*params*/);\nrunner.setStrategy(&amp;strategy);\n\n// 3. Execution listeners (optional)\nrunner.addExecutionListener(&amp;positionTracker);\n\n// 4. Data\nreplay::ReaderFilter filter;\nfilter.symbols = {1};\nauto reader = replay::createMultiSegmentReader(\"./data\", filter);\n\n// 5. Run\nBacktestResult result = runner.run(*reader);\nauto stats = result.computeStats();\n\nstd::cout &lt;&lt; \"Return: \" &lt;&lt; stats.returnPct &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Sharpe: \" &lt;&lt; stats.sharpeRatio &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/backtest/backtest_runner/#notes","title":"Notes","text":"<ul> <li>Virtual clock advances based on event timestamps from reader</li> <li>Strategy receives events in the same order as in real-time</li> <li>Signals are converted to orders and submitted to SimulatedExecutor</li> <li>All fills are recorded in BacktestResult</li> </ul>"},{"location":"reference/api/backtest/backtest_runner/#see-also","title":"See Also","text":"<ul> <li>Interactive Backtest Mode \u2014 Pause, step, breakpoints</li> <li>SimulatedExecutor \u2014 Order execution simulation</li> <li>BacktestResult \u2014 Performance statistics</li> </ul>"},{"location":"reference/api/backtest/mmap_bar_storage/","title":"MmapBarStorage","text":"<p>Memory-mapped storage for efficient bar data access.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#overview","title":"Overview","text":"<p><code>MmapBarStorage</code> provides zero-copy access to pre-computed bar data stored in binary files. Uses memory-mapping for optimal performance with large datasets.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#header","title":"Header","text":"<pre><code>#include \"flox/backtest/mmap_bar_storage.h\"\n</code></pre>"},{"location":"reference/api/backtest/mmap_bar_storage/#class-definition","title":"Class Definition","text":"<pre><code>class MmapBarStorage {\npublic:\n  explicit MmapBarStorage(const std::filesystem::path&amp; symbolDir);\n  ~MmapBarStorage();\n\n  // Move-only\n  MmapBarStorage(MmapBarStorage&amp;&amp;) noexcept;\n  MmapBarStorage&amp; operator=(MmapBarStorage&amp;&amp;) noexcept;\n\n  // Access methods\n  const Bar* getBar(TimeframeId tf, size_t index) const;\n  const Bar* findBar(TimeframeId tf, TimePoint time, char mode = 'e') const;\n  std::span&lt;const Bar&gt; getBars(TimeframeId tf) const;\n\n  // Query methods\n  size_t barCount(TimeframeId tf) const;\n  size_t totalBars() const;\n  std::pair&lt;TimePoint, TimePoint&gt; timeRange() const;\n  std::vector&lt;TimeframeId&gt; timeframes() const;\n};\n</code></pre>"},{"location":"reference/api/backtest/mmap_bar_storage/#constructor","title":"Constructor","text":"<pre><code>explicit MmapBarStorage(const std::filesystem::path&amp; symbolDir);\n</code></pre> <p>Opens all <code>bars_*.bin</code> files in the directory. File naming convention: - <code>bars_60s.bin</code> - 60-second bars - <code>bars_300s.bin</code> - 5-minute bars - <code>bars_3600s.bin</code> - 1-hour bars</p> <p>Throws: <code>std::runtime_error</code> if directory doesn't exist or no bar files found.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#file-format","title":"File Format","text":"<p>Each <code>.bin</code> file: <pre><code>[uint64_t bar_count][Bar][Bar][Bar]...\n</code></pre></p> <p>The <code>Bar</code> struct is written directly in binary format.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#methods","title":"Methods","text":""},{"location":"reference/api/backtest/mmap_bar_storage/#getbar","title":"getBar","text":"<pre><code>const Bar* getBar(TimeframeId tf, size_t index) const;\n</code></pre> <p>Get bar by index. Returns <code>nullptr</code> if timeframe not found or index out of bounds.</p> <p>Performance: O(1), no copy.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#findbar","title":"findBar","text":"<pre><code>const Bar* findBar(TimeframeId tf, TimePoint time, char mode = 'e') const;\n</code></pre> <p>Find bar by time with search mode: - <code>'e'</code> - Exact match only - <code>'b'</code> - Bar before (or at) time - <code>'a'</code> - Bar at or after time</p> <p>Performance: O(log n) binary search.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#getbars","title":"getBars","text":"<pre><code>std::span&lt;const Bar&gt; getBars(TimeframeId tf) const;\n</code></pre> <p>Get all bars for timeframe as span. Zero-copy access to memory-mapped data.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#barcount-totalbars","title":"barCount / totalBars","text":"<pre><code>size_t barCount(TimeframeId tf) const;\nsize_t totalBars() const;\n</code></pre> <p>Get bar count for specific timeframe or total across all timeframes.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#timerange","title":"timeRange","text":"<pre><code>std::pair&lt;TimePoint, TimePoint&gt; timeRange() const;\n</code></pre> <p>Get earliest and latest bar times across all timeframes.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#timeframes","title":"timeframes","text":"<pre><code>std::vector&lt;TimeframeId&gt; timeframes() const;\n</code></pre> <p>List all available timeframes.</p>"},{"location":"reference/api/backtest/mmap_bar_storage/#example","title":"Example","text":"<pre><code>// Open bar storage\nMmapBarStorage storage(\"/data/BTCUSDT\");\n\n// Get available timeframes\nfor (auto tf : storage.timeframes()) {\n  std::cout &lt;&lt; \"TF: \" &lt;&lt; tf.seconds() &lt;&lt; \"s, \"\n            &lt;&lt; storage.barCount(tf) &lt;&lt; \" bars\\n\";\n}\n\n// Iterate 1-minute bars\nauto tf1m = TimeframeId::time(std::chrono::seconds(60));\nfor (const auto&amp; bar : storage.getBars(tf1m)) {\n  double vwap = (bar.high.toDouble() + bar.low.toDouble() +\n                 bar.close.toDouble()) / 3.0;\n  // ...\n}\n\n// Find specific bar\nauto time = TimePoint(std::chrono::milliseconds(1703980800000));\nif (auto* bar = storage.findBar(tf1m, time, 'b')) {\n  std::cout &lt;&lt; \"Close: \" &lt;&lt; bar-&gt;close.toDouble() &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"reference/api/backtest/mmap_bar_storage/#platform-support","title":"Platform Support","text":"<p>Uses platform-specific memory mapping:</p> <ul> <li>Linux/macOS: <code>mmap()</code></li> <li>Windows: <code>CreateFileMapping()</code> + <code>MapViewOfFile()</code></li> </ul>"},{"location":"reference/api/backtest/mmap_bar_storage/#see-also","title":"See Also","text":"<ul> <li>Bar</li> </ul>"},{"location":"reference/api/backtest/optimization_stats/","title":"OptimizationStatistics","text":"<p>Statistical utilities for analyzing optimization results.</p>"},{"location":"reference/api/backtest/optimization_stats/#overview","title":"Overview","text":"<p><code>OptimizationStatistics</code> provides statistical functions for analyzing and comparing backtest results: confidence intervals, significance tests, correlations, and reporting.</p>"},{"location":"reference/api/backtest/optimization_stats/#header","title":"Header","text":"<pre><code>#include \"flox/backtest/optimization_stats.h\"\n</code></pre>"},{"location":"reference/api/backtest/optimization_stats/#helper-functions-detail-namespace","title":"Helper Functions (detail namespace)","text":"<pre><code>namespace detail {\n  double mean(const std::vector&lt;double&gt;&amp; data);\n  double variance(const std::vector&lt;double&gt;&amp; data);\n  double stddev(const std::vector&lt;double&gt;&amp; data);\n}\n</code></pre> <p>Basic statistical functions. Returns 0.0 for empty data.</p>"},{"location":"reference/api/backtest/optimization_stats/#extractmetric","title":"extractMetric","text":"<pre><code>template &lt;typename ParamsT&gt;\nstd::vector&lt;double&gt; extractMetric(\n    const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n    RankMetric metric);\n</code></pre> <p>Extract specified metric values from all results.</p> <p>Example: <pre><code>auto sharpes = extractMetric(results, RankMetric::SharpeRatio);\ndouble avgSharpe = detail::mean(sharpes);\n</code></pre></p>"},{"location":"reference/api/backtest/optimization_stats/#class-definition","title":"Class Definition","text":"<pre><code>template &lt;typename ParamsT, typename GridT&gt;\nclass OptimizationStatistics {\npublic:\n  struct ConfidenceInterval {\n    double lower;\n    double median;\n    double upper;\n  };\n\n  static double permutationTest(\n      const std::vector&lt;double&gt;&amp; group1,\n      const std::vector&lt;double&gt;&amp; group2,\n      size_t numPermutations = 10000);\n\n  static double correlation(\n      const std::vector&lt;double&gt;&amp; x,\n      const std::vector&lt;double&gt;&amp; y);\n\n  static ConfidenceInterval bootstrapCI(\n      const std::vector&lt;double&gt;&amp; data,\n      double confidenceLevel = 0.95,\n      size_t numSamples = 10000);\n\n  static void printSummary(\n      const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results);\n\n  static void generateReport(\n      const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n      const std::filesystem::path&amp; outputPath);\n};\n</code></pre>"},{"location":"reference/api/backtest/optimization_stats/#methods","title":"Methods","text":""},{"location":"reference/api/backtest/optimization_stats/#permutationtest","title":"permutationTest","text":"<pre><code>static double permutationTest(\n    const std::vector&lt;double&gt;&amp; group1,\n    const std::vector&lt;double&gt;&amp; group2,\n    size_t numPermutations = 10000);\n</code></pre> <p>Two-sample permutation test for comparing group means. Returns p-value.</p> <p>Example: <pre><code>// Compare two parameter configurations\nstd::vector&lt;double&gt; configA = {1.2, 1.5, 1.3};\nstd::vector&lt;double&gt; configB = {0.8, 0.9, 0.7};\ndouble pValue = Stats::permutationTest(configA, configB);\n// pValue &lt; 0.05 suggests significant difference\n</code></pre></p>"},{"location":"reference/api/backtest/optimization_stats/#correlation","title":"correlation","text":"<pre><code>static double correlation(\n    const std::vector&lt;double&gt;&amp; x,\n    const std::vector&lt;double&gt;&amp; y);\n</code></pre> <p>Pearson correlation coefficient between two vectors. Returns value in [-1, 1].</p> <p>Example: <pre><code>auto sharpes = extractMetric(results, RankMetric::SharpeRatio);\nauto returns = extractMetric(results, RankMetric::TotalReturn);\ndouble r = Stats::correlation(sharpes, returns);\n</code></pre></p>"},{"location":"reference/api/backtest/optimization_stats/#bootstrapci","title":"bootstrapCI","text":"<pre><code>static ConfidenceInterval bootstrapCI(\n    const std::vector&lt;double&gt;&amp; data,\n    double confidenceLevel = 0.95,\n    size_t numSamples = 10000);\n</code></pre> <p>Bootstrap confidence interval for the mean.</p> <p>Example: <pre><code>auto sharpes = extractMetric(results, RankMetric::SharpeRatio);\nauto ci = Stats::bootstrapCI(sharpes, 0.95);\n// ci.lower, ci.median, ci.upper\n</code></pre></p>"},{"location":"reference/api/backtest/optimization_stats/#printsummary","title":"printSummary","text":"<pre><code>static void printSummary(\n    const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results);\n</code></pre> <p>Print optimization summary to log. Shows total combinations, mean/stddev Sharpe, and best result details.</p>"},{"location":"reference/api/backtest/optimization_stats/#generatereport","title":"generateReport","text":"<pre><code>static void generateReport(\n    const std::vector&lt;OptimizationResult&lt;ParamsT&gt;&gt;&amp; results,\n    const std::filesystem::path&amp; outputPath);\n</code></pre> <p>Generate Markdown report with top 10 results table and statistics.</p>"},{"location":"reference/api/backtest/optimization_stats/#example","title":"Example","text":"<pre><code>using Stats = OptimizationStatistics&lt;MAParams, MAGrid&gt;;\n\n// Run optimization\nauto results = optimizer.runLocal();\n\n// Quick summary\nStats::printSummary(results);\n\n// Full report\nStats::generateReport(results, \"optimization_report.md\");\n\n// Statistical analysis\nauto sharpes = extractMetric(results, RankMetric::SharpeRatio);\nauto ci = Stats::bootstrapCI(sharpes);\nstd::cout &lt;&lt; \"95% CI: [\" &lt;&lt; ci.lower &lt;&lt; \", \" &lt;&lt; ci.upper &lt;&lt; \"]\\n\";\n\n// Compare top vs bottom half\nauto ranked = optimizer.rankResults(results, RankMetric::SharpeRatio);\nsize_t mid = ranked.size() / 2;\nstd::vector&lt;double&gt; topHalf, bottomHalf;\nfor (size_t i = 0; i &lt; mid; ++i) {\n  topHalf.push_back(ranked[i].sharpeRatio());\n  bottomHalf.push_back(ranked[mid + i].sharpeRatio());\n}\ndouble pValue = Stats::permutationTest(topHalf, bottomHalf);\n</code></pre>"},{"location":"reference/api/backtest/optimization_stats/#see-also","title":"See Also","text":"<ul> <li>BacktestOptimizer</li> <li>How-to: Grid Search</li> </ul>"},{"location":"reference/api/backtest/simulated_executor/","title":"SimulatedExecutor","text":"<p><code>SimulatedExecutor</code> simulates order execution against historical market data for backtesting.</p> <pre><code>class SimulatedExecutor : public IOrderExecutor\n{\npublic:\n  static constexpr size_t kMaxSymbols = 256;\n  static constexpr size_t kDefaultOrderCapacity = 64;\n  static constexpr size_t kDefaultFillCapacity = 4096;\n\n  using OrderEventCallback = std::function&lt;void(const OrderEvent&amp;)&gt;;\n\n  explicit SimulatedExecutor(IClock&amp; clock);\n\n  void setOrderEventCallback(OrderEventCallback cb);\n\n  void start() override;\n  void stop() override;\n\n  void submitOrder(const Order&amp; order) override;\n  void cancelOrder(OrderId orderId) override;\n  void cancelAllOrders(SymbolId symbol) override;\n  void replaceOrder(OrderId oldOrderId, const Order&amp; newOrder) override;\n\n  // OCO: one-cancels-other\n  void submitOCO(const OCOParams&amp; params) override;\n\n  ExchangeCapabilities capabilities() const override;\n\n  void onBookUpdate(SymbolId symbol, const std::pmr::vector&lt;BookLevel&gt;&amp; bids,\n                    const std::pmr::vector&lt;BookLevel&gt;&amp; asks);\n  void onTrade(SymbolId symbol, Price price, bool isBuy);\n  void onBar(SymbolId symbol, Price close);\n\n  const std::vector&lt;Fill&gt;&amp; fills() const;\n  std::vector&lt;Fill&gt; extractFills();  // Move fills out (clears internal vector)\n  const std::vector&lt;Order&gt;&amp; conditionalOrders() const;\n\n  CompositeOrderLogic&amp; compositeLogic() noexcept;\n};\n</code></pre>"},{"location":"reference/api/backtest/simulated_executor/#execution-logic","title":"Execution Logic","text":""},{"location":"reference/api/backtest/simulated_executor/#market-orders","title":"Market Orders","text":"Side Fill Price BUY Best ask (or last trade if no book) SELL Best bid (or last trade if no book)"},{"location":"reference/api/backtest/simulated_executor/#limit-orders","title":"Limit Orders","text":"Side Condition to Fill BUY <code>orderPrice &gt;= bestAsk</code> SELL <code>orderPrice &lt;= bestBid</code> <p>Unfilled limit orders stay pending until price crosses or canceled.</p>"},{"location":"reference/api/backtest/simulated_executor/#conditional-orders","title":"Conditional Orders","text":"<p>Conditional orders (stop, take-profit, trailing stop) are stored separately and checked on each market update.</p> Type Trigger Condition STOP_MARKET / STOP_LIMIT SELL: price \u2264 trigger, BUY: price \u2265 trigger TAKE_PROFIT_MARKET / TAKE_PROFIT_LIMIT SELL: price \u2265 trigger, BUY: price \u2264 trigger TRAILING_STOP Trigger follows price, executes on reversal <p>When triggered, conditional orders convert to market/limit and execute.</p>"},{"location":"reference/api/backtest/simulated_executor/#oco-orders","title":"OCO Orders","text":"<p>One-Cancels-Other orders are managed via <code>CompositeOrderLogic</code>:</p> <pre><code>OCOParams params;\nparams.stopOrder = stopOrder;\nparams.takeProfitOrder = tpOrder;\nexecutor.submitOCO(params);\n</code></pre> <p>When one order fills, the other is automatically canceled.</p>"},{"location":"reference/api/backtest/simulated_executor/#trailing-stop","title":"Trailing Stop","text":"<p>Trailing stops track price movement:</p> <pre><code>struct TrailingState\n{\n  Price activationPrice{};  // price when trailing stop was activated\n  Price currentTrigger{};   // current trigger price (moves with price)\n};\n</code></pre> <ul> <li>SELL trailing: trigger follows price UP (never down)</li> <li>BUY trailing: trigger follows price DOWN (never up)</li> </ul>"},{"location":"reference/api/backtest/simulated_executor/#order-events","title":"Order Events","text":"<p>Emitted via callback:</p> Event When <code>SUBMITTED</code> Order received <code>ACCEPTED</code> Order validated <code>PENDING_TRIGGER</code> Conditional order waiting for trigger <code>TRIGGERED</code> Conditional order triggered <code>FILLED</code> Fully executed <code>PARTIALLY_FILLED</code> Partial execution <code>CANCELED</code> Order canceled <code>REPLACED</code> Order modified <p>Trailing stop updates emit <code>TRAILING_UPDATE</code> events with new trigger price.</p>"},{"location":"reference/api/backtest/simulated_executor/#exchange-capabilities","title":"Exchange Capabilities","text":"<pre><code>ExchangeCapabilities capabilities() const override {\n  return ExchangeCapabilities::simulated();\n}\n</code></pre> <p>Returns capabilities indicating support for:</p> <ul> <li>All order types (limit, market, stop, take-profit, trailing)</li> <li>OCO orders</li> <li>Replace orders</li> <li>Cancel all orders</li> </ul>"},{"location":"reference/api/backtest/simulated_executor/#market-state","title":"Market State","text":"<p>Per-symbol state updated via <code>onBookUpdate()</code> and <code>onTrade()</code>:</p> <pre><code>struct MarketState\n{\n  int64_t bestBidRaw{0};\n  int64_t bestAskRaw{0};\n  int64_t lastTradeRaw{0};\n  bool hasBid{false};\n  bool hasAsk{false};\n  bool hasTrade{false};\n};\n</code></pre>"},{"location":"reference/api/backtest/simulated_executor/#performance","title":"Performance","text":"<ul> <li>Fixed-size array for symbols 0-255 (fast path)</li> <li>Overflow vector for symbol IDs &gt;= 256</li> <li>O(n) pending order scan on each market update</li> <li>Pre-allocated fill vector (default 4096)</li> </ul>"},{"location":"reference/api/backtest/simulated_executor/#see-also","title":"See Also","text":"<ul> <li>BacktestRunner \u2014 Run backtests with strategies</li> <li>BacktestResult \u2014 Performance statistics</li> <li>Order Types \u2014 Order type enum</li> <li>ExchangeCapabilities \u2014 Feature discovery</li> </ul>"},{"location":"reference/api/book/abstract_order_book/","title":"IOrderBook","text":"<p><code>IOrderBook</code> defines the abstract interface for order book implementations that consume <code>BookUpdateEvent</code>s and provide access to market depth and price levels.</p> <pre><code>class IOrderBook {\npublic:\n  virtual ~IOrderBook() = default;\n\n  virtual void applyBookUpdate(const BookUpdateEvent&amp; update) = 0;\n  virtual std::optional&lt;Price&gt; bestBid() const = 0;\n  virtual std::optional&lt;Price&gt; bestAsk() const = 0;\n\n  virtual Quantity bidAtPrice(Price price) const = 0;\n  virtual Quantity askAtPrice(Price price) const = 0;\n};\n</code></pre>"},{"location":"reference/api/book/abstract_order_book/#purpose","title":"Purpose","text":"<ul> <li>Define a common contract for order book consumers, simulators, and strategy components.</li> </ul>"},{"location":"reference/api/book/abstract_order_book/#responsibilities","title":"Responsibilities","text":"Aspect Details Update <code>applyBookUpdate()</code> ingests raw changes from <code>BookUpdateEvent</code>. Top of book <code>bestBid()</code> / <code>bestAsk()</code> expose inside market prices. Depth query <code>bidAtPrice()</code> / <code>askAtPrice()</code> return size at arbitrary levels."},{"location":"reference/api/book/abstract_order_book/#notes","title":"Notes","text":"<ul> <li>Stateless interface \u2014 actual book implementation (e.g. <code>NLevelOrderBook</code>) manages memory and performance.</li> <li>Compatible with pooled update dispatch via <code>BookUpdateBus</code>.</li> <li>Returns <code>std::optional</code> for top-of-book queries to reflect potential emptiness.</li> </ul>"},{"location":"reference/api/book/book_update/","title":"BookUpdate","text":"<p><code>BookUpdate</code> is a zero-allocation container for transmitting order-book snapshots or deltas. It supports multiple instrument classes (spot, futures, options) and includes optional option metadata.</p> <pre><code>enum class BookUpdateType\n{\n  SNAPSHOT,\n  DELTA\n};\n\nstruct BookLevel\n{\n  Price price{};\n  Quantity quantity{};\n  BookLevel() = default;\n  BookLevel(Price p, Quantity q) : price(p), quantity(q) {}\n};\n\nstruct BookUpdate\n{\n  SymbolId symbol{};\n  InstrumentType instrument = InstrumentType::Spot;\n  BookUpdateType type{};\n  std::pmr::vector&lt;BookLevel&gt; bids;\n  std::pmr::vector&lt;BookLevel&gt; asks;\n\n  UnixNanos exchangeTsNs{0};\n  UnixNanos systemTsNs{0};\n\n  std::optional&lt;Price&gt; strike;\n  std::optional&lt;TimePoint&gt; expiry;\n  std::optional&lt;OptionType&gt; optionType;\n\n  BookUpdate(std::pmr::memory_resource* res) : bids(res), asks(res) {}\n};\n</code></pre>"},{"location":"reference/api/book/book_update/#purpose","title":"Purpose","text":"<ul> <li>Provide a normalized, memory-efficient representation of an order-book update (full snapshot or incremental delta).</li> <li>Embed the instrument class so downstream components can branch without a registry lookup.</li> </ul>"},{"location":"reference/api/book/book_update/#fields","title":"Fields","text":"Field Description symbol Unique <code>SymbolId</code> of the instrument. instrument <code>Spot</code>, <code>Future</code>, or <code>Option</code>. type <code>SNAPSHOT</code> (full overwrite) or <code>DELTA</code> (incremental change). bids / asks Depth updates stored in PMR vectors (<code>BookLevel</code>). exchangeTsNs Exchange timestamp in nanoseconds since Unix epoch. systemTsNs Local system receive time in nanoseconds, for latency metrics. strike Strike price \u2014 only for option updates. expiry Expiry date/time \u2014 only for option updates. optionType <code>Call</code> or <code>Put</code> \u2014 only for option updates."},{"location":"reference/api/book/book_update/#notes","title":"Notes","text":"<ul> <li>When <code>type == SNAPSHOT</code>, consumers must fully replace their local book for <code>symbol</code>.</li> <li><code>bids</code> and <code>asks</code> are typically reserved to capacity in an object pool, avoiding runtime allocations.</li> <li>Downstream filters can quickly ignore instruments by checking <code>instrument</code> without a <code>SymbolRegistry</code> lookup.</li> <li>Option fields are optional: they are populated only when <code>instrument == InstrumentType::Option</code>.</li> <li>Uses <code>UnixNanos</code> (int64_t nanoseconds) for precise timestamps.</li> </ul>"},{"location":"reference/api/book/nlevel_order_book/","title":"NLevelOrderBook","text":"<p><code>NLevelOrderBook</code> is a high-performance, fixed-depth limit order book optimized for HFT and simulation. It uses tick-based indexing for fast access and zero allocations in the hot path.</p> <pre><code>template &lt;size_t MaxLevels = 8192&gt;\nclass NLevelOrderBook : public IOrderBook\n{\npublic:\n  static constexpr size_t MAX_LEVELS = MaxLevels;\n\n  explicit NLevelOrderBook(Price tickSize);\n\n  void applyBookUpdate(const BookUpdateEvent&amp; ev) override;\n\n  std::optional&lt;Price&gt; bestBid() const override;\n  std::optional&lt;Price&gt; bestAsk() const override;\n  Quantity bidAtPrice(Price p) const override;\n  Quantity askAtPrice(Price p) const override;\n\n  // Market state helpers\n  bool isCrossed() const;\n  std::optional&lt;Price&gt; spread() const;\n  std::optional&lt;Price&gt; mid() const;\n\n  // Depth consumption (slippage calculation)\n  std::pair&lt;Quantity, Volume&gt; consumeAsks(Quantity needQty) const;\n  std::pair&lt;Quantity, Volume&gt; consumeBids(Quantity needQty) const;\n\n  // Level extraction\n  struct PriceLevel { Price price; Quantity quantity; };\n  std::vector&lt;PriceLevel&gt; getBidLevels(size_t maxLevels) const;\n  std::vector&lt;PriceLevel&gt; getAskLevels(size_t maxLevels) const;\n\n  // Utilities\n  Price tickSize() const;\n  void clear();\n  void dump(std::ostream&amp; os, size_t levels,\n            int pricePrec = 4, int qtyPrec = 3, bool ansi = false) const;\n};\n</code></pre>"},{"location":"reference/api/book/nlevel_order_book/#purpose","title":"Purpose","text":"<ul> <li>Maintain and query an efficient in-memory representation of top-of-book and full depth using indexed price levels.</li> </ul>"},{"location":"reference/api/book/nlevel_order_book/#responsibilities","title":"Responsibilities","text":"Aspect Details Input Consumes <code>BookUpdateEvent</code> messages, supports both <code>SNAPSHOT</code> and <code>DELTA</code>. Resolution Tick-based price quantization via <code>_tickSize</code>. Depth Query Provides <code>bestBid</code>, <code>bestAsk</code>, and <code>Quantity</code> at arbitrary price levels. Storage Preallocated arrays for bids and asks indexed by tick-level offset."},{"location":"reference/api/book/nlevel_order_book/#internal-behavior","title":"Internal Behavior","text":"<ol> <li> <p>Price Indexing    Prices are mapped to array indices using <code>price / tickSize</code>, enabling constant-time access.</p> </li> <li> <p>Snapshot Handling    A <code>SNAPSHOT</code> clears all state and resets index bounds before applying levels.</p> </li> <li> <p>Bounds Tracking    Maintains <code>_minBid</code>, <code>_maxBid</code>, <code>_minAsk</code>, <code>_maxAsk</code> for efficient best-level scans.</p> </li> <li> <p>Cached Best Bid/Ask    Tracks <code>_bestBidTick</code> and <code>_bestAskTick</code> for O(1) best price queries without scanning.</p> </li> <li> <p>No Dynamic Allocation    Uses <code>std::array</code> of fixed size; fully cache-friendly and allocation-free after construction.</p> </li> <li> <p>Cache-Aligned Storage    Bids and asks arrays are 64-byte aligned for optimal cache performance.</p> </li> </ol>"},{"location":"reference/api/book/nlevel_order_book/#market-state-helpers","title":"Market State Helpers","text":"<pre><code>bool isCrossed() const;\nstd::optional&lt;Price&gt; spread() const;\nstd::optional&lt;Price&gt; mid() const;\n</code></pre> Method Description <code>isCrossed</code> Returns <code>true</code> if best bid &gt;= best ask (crossed/locked market). <code>spread</code> Returns ask - bid spread, or <code>nullopt</code> if either side is empty. <code>mid</code> Returns midpoint price, or <code>nullopt</code> if either side is empty."},{"location":"reference/api/book/nlevel_order_book/#depth-consumption","title":"Depth Consumption","text":"<p>Calculate fill price and slippage by walking through book levels:</p> <pre><code>// Simulate market buy: consume asks up to 10 BTC\nauto [filledQty, totalCost] = book.consumeAsks(Quantity::fromDouble(10.0));\nPrice avgPrice = totalCost / filledQty;\n\n// Simulate market sell: consume bids\nauto [filledQty, totalProceeds] = book.consumeBids(Quantity::fromDouble(10.0));\n</code></pre> <p>Uses 128-bit arithmetic on GCC/Clang for precision; portable fallback otherwise.</p>"},{"location":"reference/api/book/nlevel_order_book/#level-extraction","title":"Level Extraction","text":"<p>Get multiple price levels for display or analysis:</p> <pre><code>// Get top 10 bid levels\nauto bids = book.getBidLevels(10);\nfor (const auto&amp; level : bids) {\n  std::cout &lt;&lt; level.price.toDouble() &lt;&lt; \" @ \" &lt;&lt; level.quantity.toDouble() &lt;&lt; \"\\n\";\n}\n\n// Get top 10 ask levels\nauto asks = book.getAskLevels(10);\n</code></pre>"},{"location":"reference/api/book/nlevel_order_book/#debug-output","title":"Debug Output","text":"<pre><code>// Print order book to console with ANSI colors\nbook.dump(std::cout, 20, /*pricePrec=*/2, /*qtyPrec=*/4, /*ansi=*/true);\n</code></pre> <p>Output includes tick size, base index, spread, and mid price in header.</p>"},{"location":"reference/api/book/nlevel_order_book/#notes","title":"Notes","text":"<ul> <li>Extremely fast and deterministic \u2014 suitable for backtests and production.</li> <li>Requires external enforcement of tick-aligned prices.</li> <li>Offers predictable latency across workloads, assuming sparse updates.</li> <li>Uses <code>math::FastDiv64</code> for optimized tick division.</li> </ul>"},{"location":"reference/api/book/trade/","title":"Trade","text":"<p><code>Trade</code> represents a single executed transaction between a buyer and seller on a specific instrument, including price, quantity, taker side, and instrument class.</p> <pre><code>struct Trade\n{\n  SymbolId symbol{};\n  InstrumentType instrument = InstrumentType::Spot;\n  Price price{};\n  Quantity quantity{};\n  bool isBuy{false};\n  UnixNanos exchangeTsNs{0};\n};\n</code></pre>"},{"location":"reference/api/book/trade/#purpose","title":"Purpose","text":"<ul> <li>Convey executed market activity in a normalized, low-allocation format for downstream components.</li> </ul>"},{"location":"reference/api/book/trade/#fields","title":"Fields","text":"Field Description symbol Unique <code>SymbolId</code> of the traded instrument. instrument Instrument class: <code>Spot</code>, <code>Future</code>, or <code>Option</code>. price Execution price. quantity Executed size (base units). isBuy <code>true</code> if the taker was the buyer; <code>false</code> if the taker was the seller. exchangeTsNs Exchange timestamp in nanoseconds since Unix epoch."},{"location":"reference/api/book/trade/#notes","title":"Notes","text":"<ul> <li>Emitted via <code>TradeEvent</code> through <code>TradeBus</code>.</li> <li>Serves as input for bar aggregation, PnL tracking, flow analysis, and latency metrics.</li> <li><code>instrument</code> allows immediate filtering without a registry lookup in hot paths.</li> <li>Uses <code>UnixNanos</code> (int64_t nanoseconds) for precise exchange timestamps.</li> </ul>"},{"location":"reference/api/book/bus/book_update_bus/","title":"BookUpdateBus","text":"<p><code>BookUpdateBus</code> is a Disruptor-style fan-out event channel for <code>BookUpdateEvent</code> messages, wrapped in pooled <code>Handle</code>s for zero-allocation delivery across components such as order books, strategies, and analytics.</p> <pre><code>using BookUpdateBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;&gt;;\n\nstd::unique_ptr&lt;BookUpdateBus&gt; createOptimalBookUpdateBus(bool enablePerformanceOptimizations = false);\nbool configureBookUpdateBusForPerformance(BookUpdateBus&amp; bus, bool enablePerformanceOptimizations = false);\n</code></pre>"},{"location":"reference/api/book/bus/book_update_bus/#purpose","title":"Purpose","text":"<ul> <li>Efficiently distribute <code>BookUpdateEvent</code>s to multiple subscribers with zero allocations in the hot path.</li> </ul>"},{"location":"reference/api/book/bus/book_update_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload Uses <code>pool::Handle&lt;BookUpdateEvent&gt;</code> for memory reuse and ref-counting. Pattern Disruptor-style ring buffer with lock-free sequencing. Target Consumed by order book processors, strategies, and market monitors."},{"location":"reference/api/book/bus/book_update_bus/#factory-functions","title":"Factory Functions","text":"Function Description <code>createOptimalBookUpdateBus()</code> Creates bus with optimal CPU affinity for market data. <code>configureBookUpdateBusForPerformance()</code> Configures existing bus for optimal performance."},{"location":"reference/api/book/bus/book_update_bus/#notes","title":"Notes","text":"<ul> <li>Uses <code>ComponentType::MARKET_DATA</code> for CPU affinity configuration.</li> <li>Pooling ensures <code>BookUpdateEvent</code>s are reused without dynamic heap allocations.</li> <li>Designed for high-frequency message flow in HFT environments.</li> <li>Supports optional CPU affinity via <code>FLOX_CPU_AFFINITY_ENABLED</code>.</li> </ul>"},{"location":"reference/api/book/bus/trade_bus/","title":"TradeBus","text":"<p><code>TradeBus</code> is a high-throughput Disruptor-style delivery channel for <code>TradeEvent</code> messages, used to broadcast trade prints across system components such as aggregators, strategies, and analytics modules.</p> <pre><code>using TradeBus = EventBus&lt;TradeEvent&gt;;\n\nstd::unique_ptr&lt;TradeBus&gt; createOptimalTradeBus(bool enablePerformanceOptimizations = false);\nbool configureTradeBusForPerformance(TradeBus&amp; bus, bool enablePerformanceOptimizations = false);\n</code></pre>"},{"location":"reference/api/book/bus/trade_bus/#purpose","title":"Purpose","text":"<ul> <li>Propagate real-time <code>TradeEvent</code>s to all registered consumers in the system.</li> </ul>"},{"location":"reference/api/book/bus/trade_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload Direct delivery of <code>TradeEvent</code> instances (no wrapping or pooling). Pattern Disruptor-style ring buffer with lock-free sequencing. Usage Used by connectors, aggregators (e.g., <code>BarAggregator</code>), and strategies."},{"location":"reference/api/book/bus/trade_bus/#factory-functions","title":"Factory Functions","text":"Function Description <code>createOptimalTradeBus()</code> Creates bus with optimal CPU affinity for market data. <code>configureTradeBusForPerformance()</code> Configures existing bus for optimal performance."},{"location":"reference/api/book/bus/trade_bus/#notes","title":"Notes","text":"<ul> <li>Uses <code>ComponentType::MARKET_DATA</code> for CPU affinity configuration.</li> <li>Stateless; the bus itself performs no buffering or transformation.</li> <li>Supports optional CPU affinity via <code>FLOX_CPU_AFFINITY_ENABLED</code>.</li> </ul>"},{"location":"reference/api/book/events/book_update_event/","title":"BookUpdateEvent","text":"<p><code>BookUpdateEvent</code> represents a snapshot or delta update to the order book, encapsulated in a pooled, memory-resource-aware structure for zero-allocation fan-out.</p> <pre><code>struct BookUpdateEvent : public pool::PoolableBase&lt;BookUpdateEvent&gt;\n{\n  using Listener = IMarketDataSubscriber;\n\n  BookUpdate update;\n\n  int64_t seq{0};      // Exchange sequence number\n  int64_t prevSeq{0};  // Previous sequence for gap detection\n\n  uint64_t tickSequence = 0;  // Internal, set by bus\n\n  MonoNanos recvNs{0};       // Local receive time (monotonic)\n  MonoNanos publishTsNs{0};  // Bus publish time (monotonic)\n\n  ExchangeId sourceExchange{InvalidExchangeId};  // Source exchange for CEX coordination\n\n  BookUpdateEvent(std::pmr::memory_resource* res);\n  void clear();\n};\n</code></pre>"},{"location":"reference/api/book/events/book_update_event/#purpose","title":"Purpose","text":"<ul> <li>Deliver normalized order book changes with minimal latency and no heap allocations.</li> </ul>"},{"location":"reference/api/book/events/book_update_event/#fields","title":"Fields","text":"Field Description <code>update</code> <code>BookUpdate</code> payload with bid/ask vectors. <code>seq</code> Exchange-assigned sequence number. <code>prevSeq</code> Previous sequence number for gap detection. <code>tickSequence</code> Internal bus sequence for ordered delivery. <code>recvNs</code> Local receive timestamp (monotonic nanoseconds). <code>publishTsNs</code> Bus publish timestamp (monotonic nanoseconds). <code>sourceExchange</code> Source exchange ID for CEX coordination."},{"location":"reference/api/book/events/book_update_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Memory Constructed with <code>std::pmr::memory_resource</code> for scoped allocation. Pooling Inherits from <code>PoolableBase</code> for reuse via <code>pool::Handle&lt;T&gt;</code>. Payload Holds a <code>BookUpdate</code> with bid/ask vectors allocated from the PMR. Sequencing <code>tickSequence</code> ensures ordered processing across consumers. Gap Detection <code>seq</code> / <code>prevSeq</code> enable detection of missed updates. Latency <code>recvNs</code> / <code>publishTsNs</code> enable end-to-end latency measurement. Subscription Declares <code>IMarketDataSubscriber</code> as the receiver interface."},{"location":"reference/api/book/events/book_update_event/#notes","title":"Notes","text":"<ul> <li><code>clear()</code> resets bid/ask containers in-place without releasing memory.</li> <li>Intended for high-frequency delivery over <code>BookUpdateBus</code>.</li> <li>Construction asserts non-null memory resource to enforce deterministic allocation control.</li> <li>Immutable after dispatch; reused through pooled lifecycle.</li> <li><code>sourceExchange</code> enables cross-exchange book aggregation in CEX mode.</li> </ul>"},{"location":"reference/api/book/events/trade_event/","title":"TradeEvent","text":"<p><code>TradeEvent</code> represents a single trade tick \u2014 a filled transaction between counterparties \u2014 and is broadcast across the system for aggregation, analytics, and strategy input.</p> <pre><code>struct TradeEvent\n{\n  using Listener = IMarketDataSubscriber;\n\n  Trade trade{};\n\n  int64_t seq = 0;        // Exchange sequence number\n  uint64_t trade_id = 0;  // Exchange-assigned trade ID\n\n  uint64_t tickSequence = 0;  // Internal, set by bus\n\n  MonoNanos recvNs{0};         // Local receive time (monotonic)\n  MonoNanos publishTsNs{0};    // Bus publish time (monotonic)\n  UnixNanos exchangeMsgTsNs{0}; // Exchange message timestamp\n\n  ExchangeId sourceExchange{InvalidExchangeId};  // Source exchange for CEX coordination\n};\n</code></pre>"},{"location":"reference/api/book/events/trade_event/#purpose","title":"Purpose","text":"<ul> <li>Encapsulate trade prints received from exchanges for delivery via <code>TradeBus</code>.</li> </ul>"},{"location":"reference/api/book/events/trade_event/#fields","title":"Fields","text":"Field Description <code>trade</code> <code>Trade</code> payload with symbol, price, quantity, side, timestamp. <code>seq</code> Exchange-assigned sequence number. <code>trade_id</code> Exchange-assigned trade ID. <code>tickSequence</code> Internal bus sequence for ordered delivery. <code>recvNs</code> Local receive timestamp (monotonic nanoseconds). <code>publishTsNs</code> Bus publish timestamp (monotonic nanoseconds). <code>exchangeMsgTsNs</code> Exchange message timestamp (Unix nanoseconds). <code>sourceExchange</code> Source exchange ID for CEX coordination."},{"location":"reference/api/book/events/trade_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload <code>trade</code> holds symbol, price, quantity, timestamp, and taker direction. Sequencing <code>tickSequence</code> guarantees strict event order for replay and backtests. Latency <code>recvNs</code> / <code>publishTsNs</code> / <code>exchangeMsgTsNs</code> enable latency analysis. Subscription Targets <code>IMarketDataSubscriber</code> interface for generic event delivery."},{"location":"reference/api/book/events/trade_event/#notes","title":"Notes","text":"<ul> <li>Used by <code>BarAggregator</code>, PnL trackers, and all signal generation components.</li> <li>Designed for ultra-low-latency delivery; no heap allocation involved.</li> <li>Stateless container \u2014 no logic beyond encapsulation.</li> <li><code>sourceExchange</code> enables cross-exchange trade aggregation in CEX mode.</li> </ul>"},{"location":"reference/api/cex/","title":"Cross-Exchange Coordination (CEX)","text":"<p>Components for multi-exchange trading on centralized exchanges.</p>"},{"location":"reference/api/cex/#overview","title":"Overview","text":"<p>The CEX module provides building blocks for:</p> <ul> <li>Multi-exchange book aggregation - CompositeBookMatrix provides atomic, thread-safe top-of-book across exchanges</li> <li>Cross-exchange arbitrage detection - Identify when bid on one exchange exceeds ask on another</li> <li>Aggregated position tracking - Track positions across exchanges with lock-free reads</li> <li>Clock synchronization - RTT-based offset estimation with EMA smoothing</li> <li>Smart order routing - Route orders based on best price, lowest latency, or custom strategies</li> <li>Split order tracking - Track parent-child order relationships</li> </ul>"},{"location":"reference/api/cex/#design-principles","title":"Design Principles","text":"<ul> <li>Zero allocations on hot paths</li> <li>No <code>std::variant</code> - 17-20% slower than tag+switch dispatch</li> <li>No <code>std::expected</code> - C++23, poor platform support</li> <li>Fixed-size containers where possible</li> <li>Thread-safe atomic reads for multi-consumer EventBus architecture</li> </ul>"},{"location":"reference/api/cex/#components","title":"Components","text":"Component Description ExchangeInfo Exchange metadata with fixed-size name ExchangeClockSync RTT-based clock synchronization CompositeBookMatrix Thread-safe multi-exchange order book AggregatedPositionTracker Thread-safe position aggregation SplitOrderTracker Parent-child order tracking OrderRouter Smart order routing"},{"location":"reference/api/cex/#quick-start","title":"Quick Start","text":"<pre><code>#include \"flox/book/composite_book_matrix.h\"\n#include \"flox/position/aggregated_position_tracker.h\"\n#include \"flox/execution/order_router.h\"\n#include \"flox/util/sync/exchange_clock_sync.h\"\n\n// 1. Set up exchanges\nSymbolRegistry registry;\nExchangeId binance = registry.registerExchange(\"Binance\");\nExchangeId bybit = registry.registerExchange(\"Bybit\");\n\n// 2. Register symbols with equivalence\nSymbolId btcBinance = registry.registerSymbol(binance, \"BTCUSDT\");\nSymbolId btcBybit = registry.registerSymbol(bybit, \"BTCUSDT\");\nregistry.mapEquivalentSymbols({btcBinance, btcBybit});\n\n// 3. Set up composite book (thread-safe)\nCompositeBookMatrix&lt;4&gt; matrix;\n// ... subscribe to book updates from both exchanges\n\n// 4. Check for arbitrage\nif (matrix.hasArbitrageOpportunity(btcBinance)) {\n    auto bid = matrix.bestBid(btcBinance);\n    auto ask = matrix.bestAsk(btcBinance);\n    // bid.exchange != ask.exchange and bid.priceRaw &gt; ask.priceRaw\n}\n\n// 5. Track aggregated positions\nAggregatedPositionTracker&lt;4&gt; positions;\nauto total = positions.totalPosition(btcBinance);  // Lock-free read\n\n// 6. Route orders\nOrderRouter&lt;4&gt; router;\nrouter.registerExecutor(binance, &amp;binanceExecutor);\nrouter.registerExecutor(bybit, &amp;bybitExecutor);\nrouter.setRoutingStrategy(RoutingStrategy::BestPrice);\nrouter.route(btcBinance, Side::BUY, priceRaw, qtyRaw, orderId);\n</code></pre>"},{"location":"reference/api/cex/#thread-safety-model","title":"Thread Safety Model","text":"<p>The CEX components are designed for the EventBus multi-consumer architecture where each consumer runs in its own thread:</p> <pre><code>BookBus Consumer Thread          Strategy Consumer Thread\n        \u2502                                  \u2502\n        \u25bc                                  \u25bc\nCompositeBookMatrix.onBookUpdate()   CompositeBookMatrix.bestBid()\n        \u2502                                  \u2502\n        \u25bc                                  \u25bc\n   Atomic store (release)            Atomic load (acquire)\n</code></pre> Component Writer Thread Reader Thread Mechanism CompositeBookMatrix BookBus consumer Strategy consumer Atomic top-of-book AggregatedPositionTracker ExecutionBus consumer Strategy consumer Atomic position snapshot ExchangeClockSync Connector thread OrderRouter Single writer, atomic reads SplitOrderTracker Single thread only Single thread only No atomics needed OrderRouter N/A (stateless routing) Strategy thread Reads atomic data from above"},{"location":"reference/api/cex/#performance","title":"Performance","text":"<p>Benchmark results (Intel Core i7, Release build):</p> Operation Latency Throughput CompositeBookMatrix.bestBid() (4 exchanges) ~6ns 160M/s CompositeBookMatrix.update() ~5ns 218M/s PositionTracker.position() (single exchange) ~3ns 390M/s PositionTracker.totalPosition() (8 exchanges) ~7ns 144M/s ClockSync.toLocalTimeNs() &lt;1ns 10G/s Atomic load (baseline) ~0.1ns 7.8G/s"},{"location":"reference/api/cex/#demo","title":"Demo","text":"<p>Run the CEX demo to see all components in action:</p> <pre><code>./build/external/flox-connectors/external/flox/demo/cex_demo\n</code></pre> <p>The demo demonstrates: 1. Exchange registration and symbol equivalence 2. Clock synchronization with multiple exchanges 3. Composite order book with arbitrage detection 4. Aggregated position tracking 5. Smart order routing with failover 6. Split order tracking 7. Arbitrage detection and execution</p>"},{"location":"reference/api/cex/aggregated_position_tracker/","title":"AggregatedPositionTracker","text":"<p>Thread-safe aggregated position tracking across multiple exchanges.</p>"},{"location":"reference/api/cex/aggregated_position_tracker/#header","title":"Header","text":"<pre><code>#include \"flox/position/aggregated_position_tracker.h\"\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#synopsis","title":"Synopsis","text":"<pre><code>template &lt;size_t MaxExchanges = 8&gt;\nclass AggregatedPositionTracker : public ISubsystem\n{\npublic:\n  struct PositionSnapshot {\n    int64_t quantityRaw{0};\n    int64_t avgEntryPriceRaw{0};\n    int64_t costBasisRaw{0};\n  };\n\n  // Per-exchange position (lock-free read)\n  PositionSnapshot position(ExchangeId exchange, SymbolId symbol) const noexcept;\n\n  // Aggregated position across all exchanges (lock-free read, O(MaxExchanges))\n  PositionSnapshot totalPosition(SymbolId symbol) const noexcept;\n\n  // Unrealized PnL calculation (lazy, not on hot path)\n  int64_t unrealizedPnlRaw(SymbolId symbol, int64_t currentPriceRaw) const noexcept;\n\n  // Position update (writer thread only)\n  void onFill(ExchangeId exchangeId, SymbolId symbol,\n              int64_t filledQtyRaw, int64_t fillPriceRaw) noexcept;\n\n  // Reset\n  void reset(SymbolId symbol) noexcept;\n  void resetAll() noexcept;\n};\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#thread-safety","title":"Thread Safety","text":"<p>The AggregatedPositionTracker uses atomic operations for thread-safe reads:</p> <ul> <li>Writer thread: <code>onFill()</code> updates position atomically</li> <li>Reader threads: <code>position()</code>, <code>totalPosition()</code> use lock-free atomic loads</li> </ul> <pre><code>// Writer thread (ExecutionBus consumer)\nvoid onFill(...) {\n  // Atomic publish with release semantics\n  pos.costBasisRaw.store(cost, std::memory_order_release);\n  pos.quantityRaw.store(qty, std::memory_order_release);\n}\n\n// Reader thread (Strategy consumer)\nPositionSnapshot position(...) const noexcept {\n  // Atomic load with acquire semantics\n  int64_t qty = state-&gt;quantityRaw.load(std::memory_order_acquire);\n  int64_t cost = state-&gt;costBasisRaw.load(std::memory_order_acquire);\n  // ...\n}\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#usage","title":"Usage","text":""},{"location":"reference/api/cex/aggregated_position_tracker/#basic-setup","title":"Basic Setup","text":"<pre><code>AggregatedPositionTracker&lt;4&gt; tracker;\n\n// Subscribe to ExecutionBus for fill events\n// or call onFill() directly\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#recording-fills","title":"Recording Fills","text":"<pre><code>// Buy 1 BTC @ $50,000 on Binance (exchange 0)\ntracker.onFill(0, symbol,\n    Quantity::fromDouble(1.0).raw(),\n    Price::fromDouble(50000.0).raw());\n\n// Buy 0.5 BTC @ $50,001 on Bybit (exchange 1)\ntracker.onFill(1, symbol,\n    Quantity::fromDouble(0.5).raw(),\n    Price::fromDouble(50001.0).raw());\n\n// Sell 0.3 BTC @ $50,002 on Kraken (exchange 2)\n// Note: negative quantity for sells\ntracker.onFill(2, symbol,\n    Quantity::fromDouble(-0.3).raw(),\n    Price::fromDouble(50002.0).raw());\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#query-positions","title":"Query Positions","text":"<pre><code>// Per-exchange position (lock-free)\nauto binancePos = tracker.position(0, symbol);\nQuantity qty = Quantity::fromRaw(binancePos.quantityRaw);\nPrice avgEntry = Price::fromRaw(binancePos.avgEntryPriceRaw);\nstd::cout &lt;&lt; \"Binance: qty=\" &lt;&lt; qty.toDouble()\n          &lt;&lt; \" avg=\" &lt;&lt; avgEntry.toDouble() &lt;&lt; \"\\n\";\n\n// Aggregated position across all exchanges (lock-free)\nauto total = tracker.totalPosition(symbol);\nstd::cout &lt;&lt; \"Total: qty=\" &lt;&lt; Quantity::fromRaw(total.quantityRaw).toDouble()\n          &lt;&lt; \" avg=\" &lt;&lt; Price::fromRaw(total.avgEntryPriceRaw).toDouble() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#unrealized-pnl","title":"Unrealized PnL","text":"<pre><code>Price currentPrice = Price::fromDouble(50100.0);\nint64_t pnlRaw = tracker.unrealizedPnlRaw(symbol, currentPrice.raw());\ndouble pnl = Price::fromRaw(pnlRaw).toDouble();\n// pnl = totalQty * (currentPrice - avgEntry)\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#position-math","title":"Position Math","text":""},{"location":"reference/api/cex/aggregated_position_tracker/#buy-fill","title":"Buy Fill","text":"<pre><code>cost += fillQty * fillPrice;\nqty += fillQty;\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#sell-fill","title":"Sell Fill","text":"<pre><code>avgEntry = (qty != 0) ? cost / qty : 0;\ncost -= sellQty * avgEntry;  // Reduce cost at avg entry\nqty -= sellQty;\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#close-to-flat","title":"Close to Flat","text":"<pre><code>if (qty == 0) {\n  cost = 0;  // Reset cost basis when flat\n}\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#performance","title":"Performance","text":"Operation Complexity Latency position() O(1) ~3ns totalPosition() O(MaxExchanges) ~7ns onFill() O(1) ~3ns unrealizedPnlRaw() O(MaxExchanges) ~5ns"},{"location":"reference/api/cex/aggregated_position_tracker/#cache-alignment","title":"Cache Alignment","text":"<p>The per-position state is aligned to 64-byte cache lines:</p> <pre><code>struct alignas(64) AtomicPositionState {\n  std::atomic&lt;int64_t&gt; quantityRaw{0};\n  std::atomic&lt;int64_t&gt; costBasisRaw{0};\n};\n</code></pre>"},{"location":"reference/api/cex/aggregated_position_tracker/#see-also","title":"See Also","text":"<ul> <li>CompositeBookMatrix - Get current prices for PnL calculation</li> <li>SplitOrderTracker - Track split orders and their fills</li> </ul>"},{"location":"reference/api/cex/composite_book_matrix/","title":"CompositeBookMatrix","text":"<p>Thread-safe composite order book across multiple exchanges.</p>"},{"location":"reference/api/cex/composite_book_matrix/#header","title":"Header","text":"<pre><code>#include \"flox/book/composite_book_matrix.h\"\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#synopsis","title":"Synopsis","text":"<pre><code>template &lt;size_t MaxExchanges = 4&gt;\nclass CompositeBookMatrix : public IMarketDataSubscriber\n{\npublic:\n  struct BestQuote {\n    int64_t priceRaw{0};\n    int64_t qtyRaw{0};\n    ExchangeId exchange{InvalidExchangeId};\n    bool valid{false};\n  };\n\n  // ISubscriber interface\n  SubscriberId id() const override;\n  void setId(SubscriberId id) noexcept;\n\n  // Writer thread (BookBus consumer)\n  void onBookUpdate(const BookUpdateEvent&amp; ev) override;\n\n  // Reader thread (Strategy consumer) - lock-free\n  BestQuote bestBid(SymbolId symbol) const noexcept;\n  BestQuote bestAsk(SymbolId symbol) const noexcept;\n\n  // Per-exchange queries\n  BestQuote bidForExchange(SymbolId symbol, ExchangeId exchange) const noexcept;\n  BestQuote askForExchange(SymbolId symbol, ExchangeId exchange) const noexcept;\n\n  // Arbitrage detection\n  bool hasArbitrageOpportunity(SymbolId symbol) const noexcept;\n  int64_t spreadRaw(SymbolId symbol) const noexcept;\n\n  // Staleness management\n  void markStale(ExchangeId exchange, SymbolId symbol) noexcept;\n  void markExchangeStale(ExchangeId exchange) noexcept;\n  void checkStaleness(int64_t nowNs, int64_t thresholdNs) noexcept;\n};\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#thread-safety","title":"Thread Safety","text":"<p>The CompositeBookMatrix uses atomic operations for thread-safe reads:</p> <ul> <li>Writer thread: <code>onBookUpdate()</code> updates atomic top-of-book snapshot</li> <li>Reader threads: <code>bestBid()</code>, <code>bestAsk()</code> use lock-free atomic loads</li> </ul> <pre><code>// Writer thread (BookBus consumer)\nvoid onBookUpdate(const BookUpdateEvent&amp; ev) {\n  // ... find best bid/ask from update ...\n\n  // Atomic publish with release semantics\n  exState.bidPrice.store(bestBidPrice, std::memory_order_release);\n  exState.bidQty.store(bestBidQty, std::memory_order_release);\n  // ...\n}\n\n// Reader thread (Strategy consumer)\nBestQuote bestBid(SymbolId symbol) const noexcept {\n  // Atomic load with acquire semantics\n  int64_t price = exState.bidPrice.load(std::memory_order_acquire);\n  // ...\n}\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#usage","title":"Usage","text":""},{"location":"reference/api/cex/composite_book_matrix/#basic-setup","title":"Basic Setup","text":"<pre><code>CompositeBookMatrix&lt;4&gt; matrix;  // Support up to 4 exchanges\n\n// Subscribe to BookBus\nbookBus.subscribe(&amp;matrix);\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#query-best-quotes","title":"Query Best Quotes","text":"<pre><code>auto bid = matrix.bestBid(symbol);\nauto ask = matrix.bestAsk(symbol);\n\nif (bid.valid &amp;&amp; ask.valid) {\n  std::cout &lt;&lt; \"Best bid: \" &lt;&lt; bid.priceRaw &lt;&lt; \" on exchange \" &lt;&lt; bid.exchange &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Best ask: \" &lt;&lt; ask.priceRaw &lt;&lt; \" on exchange \" &lt;&lt; ask.exchange &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Spread: \" &lt;&lt; (ask.priceRaw - bid.priceRaw) &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#arbitrage-detection","title":"Arbitrage Detection","text":"<pre><code>if (matrix.hasArbitrageOpportunity(symbol)) {\n  auto bid = matrix.bestBid(symbol);\n  auto ask = matrix.bestAsk(symbol);\n\n  // bid.exchange != ask.exchange (different exchanges)\n  // bid.priceRaw &gt; ask.priceRaw (can buy low, sell high)\n\n  int64_t profit = bid.priceRaw - ask.priceRaw;\n  // Execute arbitrage...\n}\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#staleness-management","title":"Staleness Management","text":"<pre><code>// Mark specific symbol on exchange as stale\nmatrix.markStale(exchangeId, symbol);\n\n// Mark all symbols on exchange as stale (e.g., on disconnect)\nmatrix.markExchangeStale(exchangeId);\n\n// Periodic staleness check based on time\nmatrix.checkStaleness(nowNs, staleThresholdNs);\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#performance","title":"Performance","text":"Operation Complexity Latency onBookUpdate() O(bids + asks) ~5ns bestBid() O(MaxExchanges) ~3-6ns bestAsk() O(MaxExchanges) ~6-10ns hasArbitrageOpportunity() O(MaxExchanges) ~11-16ns markStale() O(1) &lt;1ns"},{"location":"reference/api/cex/composite_book_matrix/#cache-alignment","title":"Cache Alignment","text":"<p>The per-exchange state is aligned to 64-byte cache lines to prevent false sharing:</p> <pre><code>struct alignas(64) ExchangeBookState {\n  std::atomic&lt;int64_t&gt; bidPrice{0};\n  std::atomic&lt;int64_t&gt; bidQty{0};\n  std::atomic&lt;int64_t&gt; askPrice{0};\n  std::atomic&lt;int64_t&gt; askQty{0};\n  std::atomic&lt;int64_t&gt; lastUpdateNs{0};\n  std::atomic&lt;bool&gt; stale{true};\n};\n</code></pre>"},{"location":"reference/api/cex/composite_book_matrix/#see-also","title":"See Also","text":"<ul> <li>AggregatedPositionTracker - Thread-safe position tracking</li> <li>OrderRouter - Smart order routing using CompositeBookMatrix</li> </ul>"},{"location":"reference/api/cex/exchange_clock_sync/","title":"ExchangeClockSync","text":"<p>Clock synchronization for exchanges using RTT-based offset estimation with EMA smoothing.</p>"},{"location":"reference/api/cex/exchange_clock_sync/#header","title":"Header","text":"<pre><code>#include \"flox/util/sync/exchange_clock_sync.h\"\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#synopsis","title":"Synopsis","text":"<pre><code>template &lt;size_t MaxExchanges = 8&gt;\nclass ExchangeClockSync\n{\npublic:\n  struct ClockEstimate {\n    int64_t offsetNs{0};       // exchange - local (nanoseconds)\n    int64_t confidenceNs{0};   // \u00b1 uncertainty (2 sigma)\n    int64_t latencyNs{0};      // one-way estimate\n    uint32_t sampleCount{0};\n  };\n\n  // Record timing sample with validation\n  bool recordSample(ExchangeId exchange,\n                    int64_t localSendNs,\n                    int64_t exchangeNs,\n                    int64_t localRecvNs) noexcept;\n\n  // Get clock estimate\n  ClockEstimate estimate(ExchangeId exchange) const noexcept;\n\n  // Time conversion\n  int64_t toLocalTimeNs(ExchangeId exchange, int64_t exchangeNs) const noexcept;\n  int64_t toExchangeTimeNs(ExchangeId exchange, int64_t localNs) const noexcept;\n\n  // Sync status\n  bool hasSync(ExchangeId exchange) const noexcept;\n  bool hasReliableSync(ExchangeId exchange) const noexcept;\n\n  // Reset\n  void reset(ExchangeId exchange) noexcept;\n  void resetAll() noexcept;\n\n  static constexpr uint32_t kMinSamplesForReliable = 10;\n};\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#offset-calculation","title":"Offset Calculation","text":"<p>The clock offset is estimated using the classic NTP algorithm:</p> <pre><code>RTT = localRecv - localSend\noneWay = RTT / 2\noffset = exchangeTs - (localSend + oneWay)\n</code></pre> <p>Samples are smoothed using EMA (alpha = 0.1): <pre><code>offset = (offset * 9 + rawOffset) / 10;\nlatency = (latency * 9 + oneWay) / 10;\n</code></pre></p>"},{"location":"reference/api/cex/exchange_clock_sync/#sample-validation","title":"Sample Validation","text":"<p>Samples are rejected if: - RTT \u2264 0 (impossible) - RTT &gt; 10 seconds (network issue) - Exchange time &gt; 1 hour behind local (clock drift)</p> <pre><code>bool accepted = sync.recordSample(exchange, localSend, exchangeTs, localRecv);\nif (!accepted) {\n  // Sample rejected - invalid timing\n}\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#usage","title":"Usage","text":""},{"location":"reference/api/cex/exchange_clock_sync/#recording-samples","title":"Recording Samples","text":"<pre><code>ExchangeClockSync&lt;4&gt; sync;\n\n// Record timing from API call\nauto localSend = std::chrono::steady_clock::now().time_since_epoch().count();\nauto response = exchange.getServerTime();\nauto localRecv = std::chrono::steady_clock::now().time_since_epoch().count();\n\nsync.recordSample(exchangeId, localSend, response.serverTime, localRecv);\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#checking-sync-status","title":"Checking Sync Status","text":"<pre><code>if (!sync.hasSync(exchangeId)) {\n  // No samples recorded yet\n}\n\nif (sync.hasReliableSync(exchangeId)) {\n  // At least 10 samples, estimate is reliable\n}\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#getting-clock-estimate","title":"Getting Clock Estimate","text":"<pre><code>auto est = sync.estimate(exchangeId);\nstd::cout &lt;&lt; \"Offset: \" &lt;&lt; est.offsetNs / 1e6 &lt;&lt; \" ms\\n\";\nstd::cout &lt;&lt; \"Latency: \" &lt;&lt; est.latencyNs / 1e6 &lt;&lt; \" ms\\n\";\nstd::cout &lt;&lt; \"Confidence: \u00b1\" &lt;&lt; est.confidenceNs / 1e6 &lt;&lt; \" ms\\n\";\nstd::cout &lt;&lt; \"Samples: \" &lt;&lt; est.sampleCount &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#time-conversion","title":"Time Conversion","text":"<pre><code>// Convert exchange timestamp to local time\nint64_t localTs = sync.toLocalTimeNs(exchangeId, exchangeTs);\n\n// Convert local timestamp to exchange time\nint64_t exchangeTs = sync.toExchangeTimeNs(exchangeId, localTs);\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#using-with-orderrouter","title":"Using with OrderRouter","text":"<pre><code>OrderRouter&lt;4&gt; router;\nExchangeClockSync&lt;4&gt; clockSync;\n\n// Record samples during normal operation\n// ...\n\n// Use for lowest-latency routing\nrouter.setClockSync(&amp;clockSync);\nrouter.setRoutingStrategy(RoutingStrategy::LowestLatency);\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#performance","title":"Performance","text":"Operation Complexity Latency recordSample() O(1) &lt;1ns estimate() O(1) &lt;1ns toLocalTimeNs() O(1) &lt;1ns hasSync() O(1) &lt;1ns"},{"location":"reference/api/cex/exchange_clock_sync/#confidence-interval","title":"Confidence Interval","text":"<p>The confidence interval is calculated as 2\u03c3 of the offset variance:</p> <pre><code>// Variance accumulator (EMA)\nint64_t diff = rawOffset - offset;\nvarianceAcc = (varianceAcc * 9 + diff * diff) / 10;\n\n// Confidence = 2 * sqrt(variance)\nconfidenceNs = 2 * sqrt(varianceAcc);\n</code></pre>"},{"location":"reference/api/cex/exchange_clock_sync/#see-also","title":"See Also","text":"<ul> <li>OrderRouter - Uses clock sync for LowestLatency routing</li> </ul>"},{"location":"reference/api/cex/exchange_info/","title":"ExchangeInfo","text":"<p>Exchange metadata with fixed-size name storage.</p>"},{"location":"reference/api/cex/exchange_info/#header","title":"Header","text":"<pre><code>#include \"flox/exchange/exchange_info.h\"\n</code></pre>"},{"location":"reference/api/cex/exchange_info/#synopsis","title":"Synopsis","text":"<pre><code>struct ExchangeInfo\n{\n  static constexpr size_t kMaxNameLength = 16;\n\n  std::array&lt;char, kMaxNameLength&gt; name{};\n  VenueType type{VenueType::CentralizedExchange};\n\n  [[nodiscard]] std::string_view nameView() const noexcept;\n  void setName(std::string_view n) noexcept;\n};\n</code></pre>"},{"location":"reference/api/cex/exchange_info/#venuetype","title":"VenueType","text":"<pre><code>enum class VenueType : uint8_t\n{\n  CentralizedExchange,  // Binance, Bybit, Kraken, etc\n  AmmDex,               // Uniswap, Raydium, etc (future)\n  HybridDex             // dYdX, Hyperliquid, etc (future)\n};\n</code></pre>"},{"location":"reference/api/cex/exchange_info/#design","title":"Design","text":"<ul> <li>Fixed-size name - No heap allocation, 16 bytes</li> <li>No <code>std::string_view</code> storage - Avoids dangling reference risk</li> <li>No runtime metrics - Static info only, metrics tracked separately</li> </ul>"},{"location":"reference/api/cex/exchange_info/#usage","title":"Usage","text":""},{"location":"reference/api/cex/exchange_info/#creating-exchangeinfo","title":"Creating ExchangeInfo","text":"<pre><code>ExchangeInfo info;\ninfo.setName(\"Binance\");\ninfo.type = VenueType::CentralizedExchange;\n</code></pre>"},{"location":"reference/api/cex/exchange_info/#via-symbolregistry","title":"Via SymbolRegistry","text":"<pre><code>SymbolRegistry registry;\n\n// Register returns ExchangeId (uint8_t)\nExchangeId id = registry.registerExchange(\"Binance\", VenueType::CentralizedExchange);\n\n// Get info by ID\nconst ExchangeInfo* info = registry.getExchange(id);\nstd::cout &lt;&lt; \"Name: \" &lt;&lt; info-&gt;nameView() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Type: \" &lt;&lt; static_cast&lt;int&gt;(info-&gt;type) &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/cex/exchange_info/#name-truncation","title":"Name Truncation","text":"<p>Names longer than <code>kMaxNameLength - 1</code> (15 characters) are truncated:</p> <pre><code>info.setName(\"VeryLongExchangeName\");\n// info.nameView() == \"VeryLongExchang\" (15 chars)\n</code></pre>"},{"location":"reference/api/cex/exchange_info/#constants","title":"Constants","text":"Constant Value Description <code>kMaxNameLength</code> 16 Maximum name storage (15 chars + null) <code>InvalidExchangeId</code> 255 Sentinel value for invalid exchange"},{"location":"reference/api/cex/exchange_info/#memory-layout","title":"Memory Layout","text":"<pre><code>struct ExchangeInfo {\n  std::array&lt;char, 16&gt; name;  // 16 bytes\n  VenueType type;             // 1 byte\n  // 15 bytes padding (to 32-byte alignment if needed)\n};\n</code></pre> <p>Total size: 17 bytes (plus padding).</p>"},{"location":"reference/api/cex/exchange_info/#see-also","title":"See Also","text":"<ul> <li>SymbolRegistry - Exchange and symbol management</li> <li>CEX Overview - Cross-exchange coordination</li> </ul>"},{"location":"reference/api/cex/order_router/","title":"OrderRouter","text":"<p>Smart order routing across multiple exchanges.</p>"},{"location":"reference/api/cex/order_router/#header","title":"Header","text":"<pre><code>#include \"flox/execution/order_router.h\"\n</code></pre>"},{"location":"reference/api/cex/order_router/#synopsis","title":"Synopsis","text":"<pre><code>enum class RoutingStrategy : uint8_t {\n  BestPrice,      // Route to exchange with best price\n  LowestLatency,  // Route to exchange with lowest latency\n  LargestSize,    // Route to exchange with most liquidity\n  RoundRobin,     // Cycle through available exchanges\n  Explicit        // Use targetExchange field in order\n};\n\nenum class FailoverPolicy : uint8_t {\n  Reject,           // Reject if target unavailable\n  FailoverToBest,   // Failover to best available\n  Notify            // Notify via callback\n};\n\nenum class RoutingError : uint8_t {\n  Success = 0,\n  NoExecutor,\n  ExchangeDisabled,\n  InvalidSymbol,\n  RejectedByPolicy\n};\n\ntemplate &lt;size_t MaxExchanges = 4&gt;\nclass OrderRouter : public ISubsystem\n{\npublic:\n  // Executor registration\n  void registerExecutor(ExchangeId exchange, IOrderExecutor* executor) noexcept;\n  void setEnabled(ExchangeId exchange, bool enabled) noexcept;\n\n  // Configuration\n  void setCompositeBook(CompositeBookMatrix&lt;MaxExchanges&gt;* book) noexcept;\n  void setClockSync(ExchangeClockSync&lt;MaxExchanges&gt;* clockSync) noexcept;\n  void setRoutingStrategy(RoutingStrategy strategy) noexcept;\n  void setFailoverPolicy(FailoverPolicy policy) noexcept;\n\n  // Routing\n  RoutingError route(SymbolId symbol, Side side, int64_t priceRaw,\n                     int64_t quantityRaw, OrderId orderId,\n                     ExchangeId* outExchange = nullptr) noexcept;\n\n  // Explicit routing\n  RoutingError routeTo(ExchangeId exchange, SymbolId symbol, Side side,\n                       int64_t priceRaw, int64_t quantityRaw,\n                       OrderId orderId) noexcept;\n\n  // Cancel\n  RoutingError cancelOn(ExchangeId exchange, OrderId orderId) noexcept;\n\n  // Exchange selection (analysis only)\n  ExchangeId selectExchange(SymbolId symbol, Side side) const noexcept;\n};\n</code></pre>"},{"location":"reference/api/cex/order_router/#routing-strategies","title":"Routing Strategies","text":""},{"location":"reference/api/cex/order_router/#bestprice","title":"BestPrice","text":"<p>Routes to the exchange with the best price for the order: - BUY orders: Route to exchange with lowest ask - SELL orders: Route to exchange with highest bid</p> <p>Requires <code>setCompositeBook()</code> to be called.</p> <pre><code>router.setCompositeBook(&amp;matrix);\nrouter.setRoutingStrategy(RoutingStrategy::BestPrice);\nrouter.route(symbol, Side::BUY, priceRaw, qtyRaw, orderId);\n</code></pre>"},{"location":"reference/api/cex/order_router/#lowestlatency","title":"LowestLatency","text":"<p>Routes to the exchange with the lowest measured latency.</p> <p>Requires <code>setClockSync()</code> to be called.</p> <pre><code>router.setClockSync(&amp;clockSync);\nrouter.setRoutingStrategy(RoutingStrategy::LowestLatency);\nrouter.route(symbol, Side::BUY, priceRaw, qtyRaw, orderId);\n</code></pre>"},{"location":"reference/api/cex/order_router/#roundrobin","title":"RoundRobin","text":"<p>Cycles through available exchanges in sequence.</p> <pre><code>router.setRoutingStrategy(RoutingStrategy::RoundRobin);\n// First order goes to exchange 0, second to exchange 1, etc.\n</code></pre>"},{"location":"reference/api/cex/order_router/#explicit","title":"Explicit","text":"<p>Uses the <code>routeTo()</code> method to explicitly specify the target exchange.</p> <pre><code>router.routeTo(exchangeId, symbol, side, priceRaw, qtyRaw, orderId);\n</code></pre>"},{"location":"reference/api/cex/order_router/#failover-policies","title":"Failover Policies","text":""},{"location":"reference/api/cex/order_router/#reject-default","title":"Reject (Default)","text":"<p>Returns <code>RoutingError::NoExecutor</code> or <code>RoutingError::ExchangeDisabled</code> if the target exchange is unavailable.</p>"},{"location":"reference/api/cex/order_router/#failovertobest","title":"FailoverToBest","text":"<p>If the target exchange is unavailable, routes to the best available exchange.</p> <pre><code>router.setFailoverPolicy(FailoverPolicy::FailoverToBest);\nrouter.setEnabled(0, false);  // Disable exchange 0\n\nExchangeId routedTo;\nauto err = router.route(symbol, side, priceRaw, qtyRaw, orderId, &amp;routedTo);\n// err == Success, routedTo is next best exchange\n</code></pre>"},{"location":"reference/api/cex/order_router/#usage","title":"Usage","text":""},{"location":"reference/api/cex/order_router/#basic-setup","title":"Basic Setup","text":"<pre><code>OrderRouter&lt;4&gt; router;\n\n// Register executors\nrouter.registerExecutor(0, &amp;binanceExecutor);\nrouter.registerExecutor(1, &amp;bybitExecutor);\nrouter.registerExecutor(2, &amp;krakenExecutor);\n\n// Configure routing\nrouter.setRoutingStrategy(RoutingStrategy::BestPrice);\nrouter.setFailoverPolicy(FailoverPolicy::FailoverToBest);\nrouter.setCompositeBook(&amp;matrix);\nrouter.setClockSync(&amp;clockSync);\n</code></pre>"},{"location":"reference/api/cex/order_router/#routing-orders","title":"Routing Orders","text":"<pre><code>ExchangeId routedTo;\nauto err = router.route(symbol, Side::BUY, priceRaw, qtyRaw, orderId, &amp;routedTo);\n\nif (err == RoutingError::Success) {\n  std::cout &lt;&lt; \"Routed to exchange \" &lt;&lt; routedTo &lt;&lt; \"\\n\";\n} else if (err == RoutingError::NoExecutor) {\n  std::cout &lt;&lt; \"No executor available\\n\";\n} else if (err == RoutingError::ExchangeDisabled) {\n  std::cout &lt;&lt; \"Exchange disabled\\n\";\n}\n</code></pre>"},{"location":"reference/api/cex/order_router/#dynamic-exchange-management","title":"Dynamic Exchange Management","text":"<pre><code>// Disable an exchange (e.g., on disconnect)\nrouter.setEnabled(exchangeId, false);\n\n// Re-enable when reconnected\nrouter.setEnabled(exchangeId, true);\n</code></pre>"},{"location":"reference/api/cex/order_router/#error-handling","title":"Error Handling","text":"<p>All routing methods return <code>RoutingError</code>:</p> Error Description <code>Success</code> Order successfully routed <code>NoExecutor</code> No executor registered for selected exchange <code>ExchangeDisabled</code> Exchange is disabled via <code>setEnabled(false)</code> <code>InvalidSymbol</code> Symbol not recognized <code>RejectedByPolicy</code> Rejected by failover policy"},{"location":"reference/api/cex/order_router/#performance","title":"Performance","text":"Operation Complexity route() with BestPrice O(MaxExchanges) route() with LowestLatency O(MaxExchanges) route() with RoundRobin O(MaxExchanges) worst case routeTo() O(1) selectExchange() O(MaxExchanges) <p>No allocations in any routing path.</p>"},{"location":"reference/api/cex/order_router/#see-also","title":"See Also","text":"<ul> <li>CompositeBookMatrix - Multi-exchange book for BestPrice routing</li> <li>ExchangeClockSync - Latency measurement for LowestLatency routing</li> <li>SplitOrderTracker - Track split orders across exchanges</li> </ul>"},{"location":"reference/api/cex/split_order_tracker/","title":"SplitOrderTracker","text":"<p>Track parent-child order relationships for split order execution.</p>"},{"location":"reference/api/cex/split_order_tracker/#header","title":"Header","text":"<pre><code>#include \"flox/execution/split_order_tracker.h\"\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#synopsis","title":"Synopsis","text":"<pre><code>class SplitOrderTracker\n{\npublic:\n  static constexpr size_t kMaxChildrenPerSplit = 8;\n\n  struct SplitState {\n    OrderId parentId{};\n    std::array&lt;OrderId, kMaxChildrenPerSplit&gt; childIds{};\n    uint8_t childCount{0};\n    uint8_t completedCount{0};\n    uint8_t failedCount{0};\n    int64_t totalQtyRaw{0};\n    int64_t filledQtyRaw{0};\n    int64_t createdAtNs{0};\n\n    bool allDone() const noexcept;\n    bool allSuccess() const noexcept;\n    double fillRatio() const noexcept;\n  };\n\n  // Register a split order\n  bool registerSplit(OrderId parent, std::span&lt;const OrderId&gt; children,\n                     int64_t totalQtyRaw, int64_t nowNs) noexcept;\n\n  // Update on child events\n  void onChildFill(OrderId childId, int64_t fillQtyRaw) noexcept;\n  void onChildComplete(OrderId childId, bool success) noexcept;\n\n  // Query\n  const SplitState* getState(OrderId parentId) const noexcept;\n  bool isComplete(OrderId parentId) const noexcept;\n  bool isSuccessful(OrderId parentId) const noexcept;\n\n  // Management\n  void cleanup(int64_t nowNs, int64_t timeoutNs) noexcept;\n  size_t size() const noexcept;\n};\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#use-case","title":"Use Case","text":"<p>When executing a large order across multiple exchanges, split it into child orders and track their aggregate status:</p> <pre><code>Parent Order (1000 qty)\n    \u251c\u2500\u2500 Child 1 (Binance): 400 qty\n    \u251c\u2500\u2500 Child 2 (Bybit): 350 qty\n    \u2514\u2500\u2500 Child 3 (Kraken): 250 qty\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#usage","title":"Usage","text":""},{"location":"reference/api/cex/split_order_tracker/#register-split-order","title":"Register Split Order","text":"<pre><code>SplitOrderTracker tracker;\n\n// Parent order 1000 split into 3 children\nstd::array&lt;OrderId, 3&gt; children = {1001, 1002, 1003};\nQuantity totalQty = Quantity::fromDouble(10.0);  // 10 BTC\nint64_t nowNs = /* current time */;\n\nbool ok = tracker.registerSplit(1000, children, totalQty.raw(), nowNs);\nif (!ok) {\n  // Failed - parent already exists or too many children\n}\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#track-fills","title":"Track Fills","text":"<pre><code>// Child 1001 filled 4 BTC\ntracker.onChildFill(1001, Quantity::fromDouble(4.0).raw());\n\n// Child 1002 filled 3.5 BTC\ntracker.onChildFill(1002, Quantity::fromDouble(3.5).raw());\n\n// Check fill ratio\nauto* state = tracker.getState(1000);\nstd::cout &lt;&lt; \"Fill ratio: \" &lt;&lt; (state-&gt;fillRatio() * 100) &lt;&lt; \"%\\n\";\n// Output: Fill ratio: 75%\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#track-completion","title":"Track Completion","text":"<pre><code>// Mark children as complete\ntracker.onChildComplete(1001, true);   // Success\ntracker.onChildComplete(1002, true);   // Success\ntracker.onChildComplete(1003, false);  // Failed (e.g., rejected)\n\n// Check overall status\nif (tracker.isComplete(1000)) {\n  if (tracker.isSuccessful(1000)) {\n    std::cout &lt;&lt; \"All children succeeded\\n\";\n  } else {\n    std::cout &lt;&lt; \"Some children failed\\n\";\n  }\n}\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#cleanup-old-entries","title":"Cleanup Old Entries","text":"<pre><code>// Remove splits older than 1 hour\nconstexpr int64_t oneHourNs = 3600LL * 1'000'000'000LL;\ntracker.cleanup(nowNs, oneHourNs);\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#splitstate-fields","title":"SplitState Fields","text":"Field Description <code>parentId</code> Parent order ID <code>childIds</code> Array of child order IDs <code>childCount</code> Number of children <code>completedCount</code> Children completed (success or fail) <code>failedCount</code> Children that failed <code>totalQtyRaw</code> Total quantity to fill <code>filledQtyRaw</code> Quantity filled so far <code>createdAtNs</code> Creation timestamp for timeout cleanup"},{"location":"reference/api/cex/split_order_tracker/#helper-methods","title":"Helper Methods","text":""},{"location":"reference/api/cex/split_order_tracker/#alldone","title":"allDone()","text":"<pre><code>bool allDone() const noexcept {\n  return completedCount + failedCount &gt;= childCount;\n}\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#allsuccess","title":"allSuccess()","text":"<pre><code>bool allSuccess() const noexcept {\n  return completedCount &gt;= childCount &amp;&amp; failedCount == 0;\n}\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#fillratio","title":"fillRatio()","text":"<pre><code>double fillRatio() const noexcept {\n  return totalQtyRaw &gt; 0 ? static_cast&lt;double&gt;(filledQtyRaw) / totalQtyRaw : 0.0;\n}\n</code></pre>"},{"location":"reference/api/cex/split_order_tracker/#limits","title":"Limits","text":"<ul> <li>Maximum children per split: 8 (<code>kMaxChildrenPerSplit</code>)</li> <li>Attempting to register more children returns <code>false</code></li> </ul>"},{"location":"reference/api/cex/split_order_tracker/#performance","title":"Performance","text":"Operation Complexity registerSplit() O(children) onChildFill() O(1) amortized onChildComplete() O(1) amortized getState() O(1) amortized cleanup() O(n) where n = active splits <p>Uses hash maps internally for O(1) lookups.</p>"},{"location":"reference/api/cex/split_order_tracker/#see-also","title":"See Also","text":"<ul> <li>OrderRouter - Route split orders to exchanges</li> <li>AggregatedPositionTracker - Track aggregate position from fills</li> </ul>"},{"location":"reference/api/connector/connector_factory/","title":"ConnectorFactory","text":"<p><code>ConnectorFactory</code> is a global registry and dynamic constructor for <code>IExchangeConnector</code> instances, used to instantiate exchange adapters based on type and symbol at runtime.</p> <pre><code>class ConnectorFactory\n{\npublic:\n  using CreatorFunc =\n      MoveOnlyFunction&lt;std::shared_ptr&lt;IExchangeConnector&gt;(const std::string&amp;)&gt;;\n\n  static ConnectorFactory&amp; instance();\n  void registerConnector(const std::string&amp; type, CreatorFunc creator);\n  std::shared_ptr&lt;IExchangeConnector&gt; createConnector(const std::string&amp; type,\n                                                      const std::string&amp; symbol);\n\nprivate:\n  ConnectorFactory() = default;\n  std::unordered_map&lt;std::string, CreatorFunc&gt; _creators;\n};\n</code></pre>"},{"location":"reference/api/connector/connector_factory/#purpose","title":"Purpose","text":"<ul> <li>Enable pluggable, type-based instantiation of exchange connectors without static bindings.</li> </ul>"},{"location":"reference/api/connector/connector_factory/#responsibilities","title":"Responsibilities","text":"Aspect Details Registration Maps string identifiers (e.g. <code>\"bybit\"</code>, <code>\"mock\"</code>) to creator functions. Construction Calls registered factory to produce a connector for a given <code>symbol</code>. Lifetime Singleton pattern via <code>instance()</code>; all connectors share same registry."},{"location":"reference/api/connector/connector_factory/#notes","title":"Notes","text":"<ul> <li>Supports dynamic module systems or runtime configuration of connector types.</li> <li>Not thread-safe by default \u2014 external synchronization may be required during registration.</li> <li>Returns <code>nullptr</code> if the requested connector type is not registered.</li> </ul>"},{"location":"reference/api/connector/connector_manager/","title":"ConnectorManager","text":"<p><code>ConnectorManager</code> coordinates lifecycle and callback wiring for multiple <code>IExchangeConnector</code> instances, managing startup and routing of market data events.</p> <pre><code>class ConnectorManager\n{\npublic:\n  void registerConnector(std::shared_ptr&lt;IExchangeConnector&gt; connector);\n  void startAll(IExchangeConnector::BookUpdateCallback onBookUpdate,\n                IExchangeConnector::TradeCallback onTrade);\n\nprivate:\n  std::map&lt;std::string, std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors;\n};\n</code></pre>"},{"location":"reference/api/connector/connector_manager/#purpose","title":"Purpose","text":"<ul> <li>Aggregate multiple exchange connectors and manage their startup and event forwarding.</li> </ul>"},{"location":"reference/api/connector/connector_manager/#responsibilities","title":"Responsibilities","text":"Aspect Details Registration Stores connectors indexed by their <code>exchangeId()</code> value. Startup Calls <code>start()</code> on all registered connectors. Callbacks Wires trade and book update callbacks to each connector during startup. Output Logs startup of each connector via <code>FLOX_LOG</code>."},{"location":"reference/api/connector/connector_manager/#notes","title":"Notes","text":"<ul> <li>Assumes connectors are ready to start at the time of <code>startAll()</code> \u2014 no deferred registration.</li> <li>Wraps callbacks using lambdas to allow mutation and move-only semantics.</li> <li>Primarily intended for system bootstrap and orchestration; not used in performance-critical paths.</li> <li>Callback dispatch remains connector-local; manager only wires them once.</li> </ul>"},{"location":"reference/api/connector/exchange_connector/","title":"IExchangeConnector","text":"<p><code>IExchangeConnector</code> is the abstract interface for real-time market data adapters. It provides lifecycle control, typed callback delivery for market data events, and error notifications.</p> <pre><code>class IExchangeConnector : public ISubsystem, public IDrainable\n{\npublic:\n  using BookUpdateCallback = MoveOnlyFunction&lt;void(const BookUpdateEvent&amp;)&gt;;\n  using TradeCallback = MoveOnlyFunction&lt;void(const TradeEvent&amp;)&gt;;\n  using DisconnectCallback = MoveOnlyFunction&lt;void(std::string_view reason)&gt;;\n  using SequenceGapCallback = MoveOnlyFunction&lt;void(uint64_t expected, uint64_t received)&gt;;\n  using StaleDataCallback = MoveOnlyFunction&lt;void(SymbolId symbol, uint64_t lastUpdateMs)&gt;;\n\n  virtual ~IExchangeConnector() = default;\n\n  bool drain(uint32_t timeoutMs) override { return true; }\n\n  virtual std::string exchangeId() const = 0;\n\n  virtual void setCallbacks(BookUpdateCallback onBookUpdate, TradeCallback onTrade);\n  virtual void setErrorCallbacks(DisconnectCallback onDisconnect,\n                                 SequenceGapCallback onSequenceGap,\n                                 StaleDataCallback onStaleData);\n\nprotected:\n  void emitBookUpdate(const BookUpdateEvent&amp; bu);\n  void emitTrade(const TradeEvent&amp; t);\n  void emitDisconnect(std::string_view reason);\n  void emitSequenceGap(uint64_t expected, uint64_t received);\n  void emitStaleData(SymbolId symbol, uint64_t lastUpdateMs);\n};\n</code></pre>"},{"location":"reference/api/connector/exchange_connector/#purpose","title":"Purpose","text":"<ul> <li>Abstract base for all exchange-specific connectors (e.g. Bybit, Mock, Replay), handling event emission and lifecycle.</li> </ul>"},{"location":"reference/api/connector/exchange_connector/#responsibilities","title":"Responsibilities","text":"Aspect Details Lifecycle Inherits <code>start()</code> and <code>stop()</code> from <code>ISubsystem</code>. Draining Implements <code>IDrainable</code> for graceful shutdown with pending operations. Identity <code>exchangeId()</code> provides a stable identifier for the connector instance. Data Callbacks <code>setCallbacks()</code> binds handlers for book and trade events. Error Callbacks <code>setErrorCallbacks()</code> binds handlers for connection/data errors. Event Routing <code>emit*()</code> methods dispatch data and errors to subscribers."},{"location":"reference/api/connector/exchange_connector/#error-callbacks","title":"Error Callbacks","text":"Callback When Called onDisconnect Connection lost or closed unexpectedly. onSequenceGap Sequence number gap detected (expected vs received). onStaleData No updates received for a symbol beyond threshold."},{"location":"reference/api/connector/exchange_connector/#notes","title":"Notes","text":"<ul> <li>Inherits from <code>ISubsystem</code> and <code>IDrainable</code>, enabling unified lifecycle and graceful shutdown.</li> <li>Callbacks use <code>MoveOnlyFunction</code> to avoid <code>std::function</code> overhead and enable capturing closures with ownership.</li> <li>Implementations must call <code>emit*()</code> manually from internal processing (e.g. websocket handler).</li> <li>The class is intentionally non-copyable and non-thread-safe \u2014 connectors are expected to run in isolated threads.</li> </ul>"},{"location":"reference/api/engine/abstract_market_data_subscriber/","title":"IMarketDataSubscriber","text":"<p><code>IMarketDataSubscriber</code> is a unified interface for components that consume real-time market data events. It supports optional handling of order book updates, trades, and bars.</p> <pre><code>class IMarketDataSubscriber : public ISubscriber\n{\npublic:\n  virtual ~IMarketDataSubscriber() = default;\n\n  virtual void onBookUpdate(const BookUpdateEvent&amp; ev) {}\n  virtual void onTrade(const TradeEvent&amp; ev) {}\n  virtual void onBar(const BarEvent&amp; ev) {}\n};\n</code></pre>"},{"location":"reference/api/engine/abstract_market_data_subscriber/#purpose","title":"Purpose","text":"<ul> <li>Serve as a polymorphic listener for all market-facing event types across the system.</li> </ul>"},{"location":"reference/api/engine/abstract_market_data_subscriber/#methods","title":"Methods","text":"Method Description onBookUpdate Receives <code>BookUpdateEvent</code> from <code>BookUpdateBus</code>. onTrade Receives <code>TradeEvent</code> from <code>TradeBus</code>. onBar Receives <code>BarEvent</code> from <code>BarBus</code>."},{"location":"reference/api/engine/abstract_market_data_subscriber/#notes","title":"Notes","text":"<ul> <li>Default implementations are no-ops \u2014 subscribers override only what they care about.</li> <li>Used with <code>EventBus&lt;T&gt;</code> which delivers events via <code>EventDispatcher</code>.</li> <li>Inherits from <code>ISubscriber</code>, which provides <code>id()</code> for routing.</li> </ul>"},{"location":"reference/api/engine/abstract_subscriber/","title":"ISubscriber","text":"<p><code>ISubscriber</code> defines the minimal interface for any component that consumes events via <code>EventBus</code>. It provides a stable identity for routing.</p> <pre><code>using SubscriberId = uint64_t;\n\nstruct ISubscriber\n{\n  virtual SubscriberId id() const = 0;\n};\n</code></pre>"},{"location":"reference/api/engine/abstract_subscriber/#purpose","title":"Purpose","text":"<ul> <li>Abstract base for all event consumers, enabling uniform routing and identification.</li> </ul>"},{"location":"reference/api/engine/abstract_subscriber/#responsibilities","title":"Responsibilities","text":"Method Description id() Returns a globally unique ID for this subscriber."},{"location":"reference/api/engine/abstract_subscriber/#notes","title":"Notes","text":"<ul> <li><code>SubscriberId</code> is typically derived from pointer identity or hash \u2014 no strong ownership implied.</li> <li>Used by <code>EventBus&lt;T&gt;</code> to track subscribers and apply fan-out policy.</li> <li>Derived interfaces like <code>IMarketDataSubscriber</code> and <code>IOrderExecutionListener</code> extend this base.</li> </ul>"},{"location":"reference/api/engine/abstract_subsystem/","title":"ISubsystem","text":"<p><code>ISubsystem</code> defines a lifecycle interface for engine components that require explicit startup and shutdown phases.</p> <pre><code>class ISubsystem\n{\npublic:\n  virtual ~ISubsystem() = default;\n\n  virtual void start() {}\n  virtual void stop() {}\n};\n</code></pre>"},{"location":"reference/api/engine/abstract_subsystem/#purpose","title":"Purpose","text":"<ul> <li>Provide deterministic initialization and teardown hooks for stateful modules in the system.</li> </ul>"},{"location":"reference/api/engine/abstract_subsystem/#responsibilities","title":"Responsibilities","text":"Method Description start Called during engine bootstrapping. stop Called during shutdown or reset."},{"location":"reference/api/engine/abstract_subsystem/#notes","title":"Notes","text":"<ul> <li>Methods have default empty implementations, allowing derived classes to override only what they need.</li> <li>Used by core modules like <code>BarAggregator</code>, <code>Strategy</code>, <code>ExecutionTracker</code>, <code>SymbolRegistry</code>, etc.</li> <li>Lifecycle is typically orchestrated by the engine or test harness.</li> <li>No assumptions about threading \u2014 start/stop are always externally coordinated.</li> </ul>"},{"location":"reference/api/engine/abstract_subsystem/#idrainable","title":"IDrainable","text":"<p><code>IDrainable</code> is a separate interface for components with pending async work that must complete before shutdown.</p> <pre><code>class IDrainable\n{\npublic:\n  virtual ~IDrainable() = default;\n  virtual bool drain(uint32_t timeoutMs) = 0;\n};\n</code></pre>"},{"location":"reference/api/engine/abstract_subsystem/#purpose_1","title":"Purpose","text":"<ul> <li>Wait for in-flight operations (e.g., pending orders, network requests) to complete.</li> </ul>"},{"location":"reference/api/engine/abstract_subsystem/#when-to-implement","title":"When to Implement","text":"<p>Only implement <code>IDrainable</code> for components with actual async work: * Exchange connectors (in-flight order confirmations) * Order executors (pending order submissions) * Network transports (pending requests)</p> <p>Do NOT implement for stateless or synchronous components like strategies, aggregators, or registries.</p>"},{"location":"reference/api/engine/engine/","title":"Engine","text":"<p><code>Engine</code> coordinates the startup and shutdown of the entire trading system. It owns the engine configuration, all exchange connectors, and system subsystems.</p> <pre><code>class Engine : public ISubsystem\n{\npublic:\n  Engine(const EngineConfig&amp; config,\n         std::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems,\n         std::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors);\n\n  void start() override;\n  void stop() override;\n};\n</code></pre>"},{"location":"reference/api/engine/engine/#purpose","title":"Purpose","text":"<ul> <li>Central orchestration unit responsible for lifecycle management of all core components.</li> </ul>"},{"location":"reference/api/engine/engine/#responsibilities","title":"Responsibilities","text":"Aspect Description Configuration Stores full <code>EngineConfig</code> used by subsystems and connectors. Subsystems Owns and manages startup/teardown of all registered <code>ISubsystem</code>s. Connectors Retains exchange adapters to prevent premature destruction."},{"location":"reference/api/engine/engine/#exchangeinstance","title":"ExchangeInstance","text":"<pre><code>struct ExchangeInstance\n{\n  std::string exchangeType;\n  std::string name;\n  std::string symbol;\n  std::shared_ptr&lt;IExchangeConnector&gt; connector;\n};\n</code></pre> Field Description exchangeType Registered type used in factory resolution. name User-defined alias for logging or mapping. symbol Symbol string for routing or filtering. connector Pointer to live exchange connection."},{"location":"reference/api/engine/engine/#notes","title":"Notes","text":"<ul> <li><code>start()</code>/<code>stop()</code> invoke lifecycle methods on all subsystems in the order defined.</li> <li>All subsystems are owned via <code>unique_ptr</code>; destruction is deterministic and ordered.</li> <li>Designed to decouple bootstrapping logic from component logic \u2014 the <code>Engine</code> is not involved in runtime signal or data flow.</li> </ul>"},{"location":"reference/api/engine/engine_config/","title":"EngineConfig","text":"<p><code>EngineConfig</code> holds top-level runtime configuration for the trading engine, including exchange definitions, kill switch limits, and logging preferences.</p> <pre><code>struct EngineConfig\n{\n  std::vector&lt;ExchangeConfig&gt; exchanges;\n  KillSwitchConfig killSwitchConfig;\n  std::string logLevel = \"info\";\n  std::string logFile;\n  uint32_t drainTimeoutMs = 5000;\n};\n</code></pre>"},{"location":"reference/api/engine/engine_config/#purpose","title":"Purpose","text":"<ul> <li>Aggregate all user-specified engine parameters into a single loadable structure.</li> </ul>"},{"location":"reference/api/engine/engine_config/#fields","title":"Fields","text":"Field Description exchanges List of exchanges and symbols to connect (via <code>ExchangeConfig</code>). killSwitchConfig Limits for order size, frequency, and loss (see <code>KillSwitchConfig</code>). logLevel Runtime log verbosity (<code>info</code>, <code>debug</code>, <code>trace</code>, etc.). logFile Optional path to write logs to disk. drainTimeoutMs Timeout for draining subsystems during shutdown (default: 5000ms)."},{"location":"reference/api/engine/engine_config/#substructures","title":"Substructures","text":""},{"location":"reference/api/engine/engine_config/#exchangeconfig","title":"<code>ExchangeConfig</code>","text":"<pre><code>struct ExchangeConfig\n{\n  std::string name;\n  std::string type;\n  std::vector&lt;SymbolConfig&gt; symbols;\n};\n</code></pre> Field Description name Display name or label (e.g. <code>\"Bybit\"</code>). type Connector type (used by <code>ConnectorFactory</code>). symbols List of <code>SymbolConfig</code> entries."},{"location":"reference/api/engine/engine_config/#symbolconfig","title":"<code>SymbolConfig</code>","text":"<pre><code>struct SymbolConfig\n{\n  std::string symbol;\n  double tickSize;\n  double expectedDeviation;\n};\n</code></pre> Field Description symbol Symbol name (e.g. <code>\"DOTUSDT\"</code>). tickSize Price resolution used by the order book. expectedDeviation Max allowed distance from center price."},{"location":"reference/api/engine/engine_config/#killswitchconfig","title":"<code>KillSwitchConfig</code>","text":"<pre><code>struct KillSwitchConfig\n{\n  double maxOrderQty = 10'000.0;\n  double maxLoss = -1e6;\n  int maxOrdersPerSecond = -1;\n};\n</code></pre> Field Default Description maxOrderQty 10,000 Per-order size limit. maxLoss -1,000,000 Hard loss cap per session. maxOrdersPerSecond -1 Throttling limit for message rate (\u2264 0 = disabled)."},{"location":"reference/api/engine/engine_config/#global-constants","title":"Global Constants","text":"<p>The header also defines compile-time defaults via <code>flox::config</code> namespace:</p> <pre><code>namespace config\n{\n  inline constexpr size_t DEFAULT_EVENTBUS_CAPACITY = 4096;\n  inline constexpr size_t DEFAULT_EVENTBUS_MAX_CONSUMERS = 128;\n\n  // Connector pool capacity (must be &gt; EventBus capacity to prevent exhaustion)\n  inline constexpr size_t DEFAULT_CONNECTOR_POOL_CAPACITY = 8191;\n\n  // CPU Affinity Priority Constants\n  inline constexpr int ISOLATED_CORE_PRIORITY_BOOST = 5;\n  inline constexpr int DEFAULT_REALTIME_PRIORITY = 80;\n  inline constexpr int FALLBACK_REALTIME_PRIORITY = 90;\n\n  // Component-specific priority constants\n  inline constexpr int MARKET_DATA_PRIORITY = 90;\n  inline constexpr int EXECUTION_PRIORITY = 85;\n  inline constexpr int STRATEGY_PRIORITY = 80;\n  inline constexpr int RISK_PRIORITY = 75;\n  inline constexpr int GENERAL_PRIORITY = 70;\n\n  // Order tracker capacity\n  inline constexpr int ORDER_TRACKER_CAPACITY = 4096;\n}\n</code></pre> <p>These can be overridden via preprocessor defines:</p> <ul> <li><code>FLOX_DEFAULT_EVENTBUS_CAPACITY</code></li> <li><code>FLOX_DEFAULT_EVENTBUS_MAX_CONSUMERS</code></li> <li><code>FLOX_DEFAULT_ORDER_TRACKER_CAPACITY</code></li> <li><code>FLOX_DEFAULT_CONNECTOR_POOL_CAPACITY</code></li> </ul> <p>Important: <code>DEFAULT_CONNECTOR_POOL_CAPACITY</code> must be greater than <code>DEFAULT_EVENTBUS_CAPACITY</code>. EventBus only reclaims events on wrap-around, so if pool capacity \u2264 bus capacity, the pool will exhaust before any events are returned.</p>"},{"location":"reference/api/engine/engine_config/#notes","title":"Notes","text":"<ul> <li>Typically loaded from JSON during engine bootstrap.</li> <li>Used by multiple components: symbol registry, kill switch, connector setup, and logging.</li> <li>Priority constants are used for CPU affinity and thread scheduling when <code>FLOX_ENABLE_CPU_AFFINITY</code> is enabled.</li> </ul>"},{"location":"reference/api/engine/event_dispatcher/","title":"EventDispatcher","text":"<p><code>EventDispatcher&lt;T&gt;</code> provides a compile-time dispatch mechanism that routes events to the appropriate subscriber method without relying on virtual functions or dynamic casting.</p> <pre><code>template &lt;typename T&gt;\nstruct EventDispatcher;\n\ntemplate &lt;typename T&gt;\nstruct EventDispatcher&lt;pool::Handle&lt;T&gt;&gt; {\n  static void dispatch(const pool::Handle&lt;T&gt;&amp; ev, typename T::Listener&amp; sub);\n};\n\n// Specializations for each event type...\n</code></pre>"},{"location":"reference/api/engine/event_dispatcher/#purpose","title":"Purpose","text":"<ul> <li>Deliver strongly-typed events (<code>BookUpdateEvent</code>, <code>TradeEvent</code>, etc.) to their matching handler methods on subscribers, using static dispatch.</li> </ul>"},{"location":"reference/api/engine/event_dispatcher/#responsibilities","title":"Responsibilities","text":"Specialization Routed To <code>BookUpdateEvent</code> <code>IMarketDataSubscriber::onBookUpdate()</code> <code>TradeEvent</code> <code>IMarketDataSubscriber::onTrade()</code> <code>BarEvent</code> <code>IMarketDataSubscriber::onBar()</code> <code>OrderEvent</code> <code>IOrderExecutionListener::onOrderFilled()</code> via <code>dispatchTo()</code> <code>pool::Handle&lt;T&gt;</code> Unwraps and forwards to <code>EventDispatcher&lt;T&gt;</code>"},{"location":"reference/api/engine/event_dispatcher/#notes","title":"Notes","text":"<ul> <li>Eliminates virtual overhead in <code>EventBus</code> by avoiding <code>event-&gt;dispatchTo()</code> directly.</li> <li>Pooled events (<code>pool::Handle&lt;T&gt;</code>) are transparently unwrapped and dispatched.</li> <li>Extensible \u2014 any new event type must define a matching specialization.</li> <li>Dispatch is strictly type-safe and resolved at compile time.</li> </ul>"},{"location":"reference/api/engine/symbol_registry/","title":"SymbolRegistry","text":"<p><code>SymbolRegistry</code> assigns and resolves stable <code>SymbolId</code> and <code>ExchangeId</code> values for instruments and exchanges. Exposes full metadata (<code>SymbolInfo</code>, <code>ExchangeInfo</code>) for fast, type-safe access across the engine.</p> <pre><code>struct SymbolInfo\n{\n  SymbolId id{0};\n  std::string exchange;\n  std::string symbol;\n  InstrumentType type = InstrumentType::Spot;\n  Price tickSize{Price::fromDouble(0.01)};\n  ExchangeId exchangeId{InvalidExchangeId};\n\n  std::optional&lt;Price&gt; strike;\n  std::optional&lt;TimePoint&gt; expiry;\n  std::optional&lt;OptionType&gt; optionType;\n};\n\nclass SymbolRegistry : public ISubsystem\n{\npublic:\n  static constexpr size_t kMaxExchanges = 32;\n  static constexpr size_t kMaxSymbols = 4096;\n  static constexpr size_t kMaxEquivalentsPerSymbol = 8;\n\n  // Exchange management\n  ExchangeId registerExchange(std::string_view name,\n                              VenueType type = VenueType::CentralizedExchange);\n  const ExchangeInfo* getExchange(ExchangeId id) const;\n  ExchangeId getExchangeId(std::string_view name) const;\n  size_t exchangeCount() const;\n\n  // Symbol registration (legacy string-based API)\n  SymbolId registerSymbol(const std::string&amp; exchange, const std::string&amp; symbol);\n  SymbolId registerSymbol(const SymbolInfo&amp; info);\n  std::optional&lt;SymbolId&gt; getSymbolId(const std::string&amp; exchange,\n                                      const std::string&amp; symbol) const;\n  std::optional&lt;SymbolInfo&gt; getSymbolInfo(SymbolId id) const;\n  std::pair&lt;std::string, std::string&gt; getSymbolName(SymbolId id) const;\n\n  // Symbol registration (ExchangeId-based API)\n  SymbolId registerSymbol(ExchangeId exchange, std::string_view symbol);\n  ExchangeId getExchangeForSymbol(SymbolId symbol) const;\n\n  // Symbol equivalence (cross-exchange mapping)\n  void mapEquivalentSymbols(std::span&lt;const SymbolId&gt; equivalentSymbols);\n  std::span&lt;const SymbolId&gt; getEquivalentSymbols(SymbolId symbol) const;\n  SymbolId getEquivalentOnExchange(SymbolId symbol, ExchangeId exchange) const;\n\n  // Persistence\n  bool saveToFile(const std::filesystem::path&amp; path) const;\n  bool loadFromFile(const std::filesystem::path&amp; path);\n  std::vector&lt;std::byte&gt; serialize() const;\n  bool deserialize(std::span&lt;const std::byte&gt; data);\n\n  // Utilities\n  void clear();\n  std::vector&lt;SymbolInfo&gt; getAllSymbols() const;\n  size_t size() const;\n};\n</code></pre>"},{"location":"reference/api/engine/symbol_registry/#purpose","title":"Purpose","text":"<ul> <li>Provide a thread-safe, bidirectional mapping between human-readable instrument keys and compact numeric <code>SymbolId</code>s.</li> <li>Manage exchange registrations with <code>ExchangeId</code> for multi-exchange scenarios.</li> <li>Support cross-exchange symbol equivalence for arbitrage and routing.</li> <li>Expose complete instrument metadata (<code>SymbolInfo</code>) for latency-critical components without repeated parsing.</li> <li>Support persistence and serialization for replay and data recording scenarios.</li> </ul>"},{"location":"reference/api/engine/symbol_registry/#exchange-management","title":"Exchange Management","text":"Method Description <code>registerExchange</code> Registers an exchange, returns <code>ExchangeId</code>. <code>getExchange</code> Returns <code>ExchangeInfo*</code> for the given ID. <code>getExchangeId</code> Lookup <code>ExchangeId</code> by name. <code>exchangeCount</code> Returns number of registered exchanges."},{"location":"reference/api/engine/symbol_registry/#symbol-registration","title":"Symbol Registration","text":"Method Description <code>registerSymbol(str)</code> Registers a spot instrument, returns existing <code>id</code> if present. <code>registerSymbol(info)</code> Registers any instrument type with full metadata. <code>registerSymbol(ExchangeId, symbol)</code> Registers using <code>ExchangeId</code> instead of string. <code>getSymbolId</code> Forward lookup from <code>(exchange, symbol)</code> to <code>SymbolId</code>. <code>getSymbolName</code> Reverse lookup from <code>SymbolId</code> to <code>(exchange, symbol)</code> string pair. <code>getSymbolInfo</code> Returns <code>std::optional&lt;SymbolInfo&gt;</code> for the given ID. <code>getExchangeForSymbol</code> Returns <code>ExchangeId</code> for a given symbol."},{"location":"reference/api/engine/symbol_registry/#symbol-equivalence","title":"Symbol Equivalence","text":"<p>For cross-exchange trading, symbols on different exchanges can be mapped as equivalent:</p> <pre><code>// Register symbols on different exchanges\nauto btcBinance = registry.registerSymbol(\"binance\", \"BTCUSDT\");\nauto btcBybit = registry.registerSymbol(\"bybit\", \"BTCUSDT\");\nauto btcOkx = registry.registerSymbol(\"okx\", \"BTC-USDT\");\n\n// Map them as equivalent\nregistry.mapEquivalentSymbols({btcBinance, btcBybit, btcOkx});\n\n// Query equivalents\nauto equivalents = registry.getEquivalentSymbols(btcBinance);  // Returns all 3\nauto bybitEquiv = registry.getEquivalentOnExchange(btcBinance, bybitExchangeId);\n</code></pre> Method Description <code>mapEquivalentSymbols</code> Links symbols as equivalent across exchanges. <code>getEquivalentSymbols</code> Returns span of all equivalent symbols. <code>getEquivalentOnExchange</code> Returns equivalent symbol on a specific exchange."},{"location":"reference/api/engine/symbol_registry/#persistence","title":"Persistence","text":"Method Description <code>saveToFile</code> Persists registry to a binary file. <code>loadFromFile</code> Loads registry from a binary file. <code>serialize</code> Returns binary representation as <code>std::vector&lt;std::byte&gt;</code>. <code>deserialize</code> Restores state from binary data."},{"location":"reference/api/engine/symbol_registry/#capacity-limits","title":"Capacity Limits","text":"Constant Value Description <code>kMaxExchanges</code> 32 Maximum number of exchanges. <code>kMaxSymbols</code> 4096 Maximum number of symbols. <code>kMaxEquivalentsPerSymbol</code> 8 Maximum equivalents per symbol."},{"location":"reference/api/engine/symbol_registry/#internal-design","title":"Internal Design","text":"<ul> <li>Composite key <code>\"exchange:symbol\"</code> ensures O(1) forward lookups via <code>_map</code>.</li> <li><code>_symbols</code> is an unordered_map for direct <code>id</code> lookups.</li> <li><code>_symbolToExchange</code> provides O(1) symbol-to-exchange mapping.</li> <li>Equivalence uses flat storage: <code>[sym * kMaxEquivalentsPerSymbol ... (sym+1) * kMaxEquivalentsPerSymbol)</code> for O(1) lookup.</li> <li>A single mutex protects all structures; registration is rare, lookups are frequent.</li> </ul>"},{"location":"reference/api/engine/symbol_registry/#notes","title":"Notes","text":"<ul> <li>Inherits from <code>ISubsystem</code> for lifecycle management integration.</li> <li><code>InstrumentType</code> allows immediate filtering (<code>Spot</code>, <code>Future</code>, <code>Option</code>) without extra registry calls in hot paths.</li> <li><code>SymbolId</code> remains a compact, contiguous 32-bit value suitable for array indices in event buses and order books.</li> <li>Option-specific fields (<code>strike</code>, <code>expiry</code>, <code>optionType</code>) are populated only when <code>type == InstrumentType::Option</code>.</li> <li><code>tickSize</code> stores the minimum price increment for the instrument (default 0.01).</li> <li><code>exchangeId</code> links symbol directly to its exchange for O(1) access.</li> <li>Persistence methods are useful for storing symbol mappings alongside recorded market data.</li> </ul>"},{"location":"reference/api/execution/abstract_execution_listener/","title":"IOrderExecutionListener","text":"<p><code>IOrderExecutionListener</code> defines the interface for components that react to order lifecycle events. It is used by <code>OrderExecutionBus</code> to notify subscribers of changes in order state.</p> <pre><code>class IOrderExecutionListener : public ISubscriber {\npublic:\n  explicit IOrderExecutionListener(SubscriberId id);\n  virtual ~IOrderExecutionListener() = default;\n\n  SubscriberId id() const override;\n\n  // Standard order events\n  virtual void onOrderSubmitted(const Order&amp; order) {}\n  virtual void onOrderAccepted(const Order&amp; order) {}\n  virtual void onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty) {}\n  virtual void onOrderFilled(const Order&amp; order) {}\n  virtual void onOrderPendingCancel(const Order&amp; order) {}\n  virtual void onOrderCanceled(const Order&amp; order) {}\n  virtual void onOrderExpired(const Order&amp; order) {}\n  virtual void onOrderRejected(const Order&amp; order, const std::string&amp; reason) {}\n  virtual void onOrderReplaced(const Order&amp; oldOrder, const Order&amp; newOrder) {}\n\n  // Conditional order events\n  virtual void onOrderPendingTrigger(const Order&amp; order) {}\n  virtual void onOrderTriggered(const Order&amp; order) {}\n  virtual void onTrailingStopUpdated(const Order&amp; order, Price newTriggerPrice) {}\n};\n</code></pre>"},{"location":"reference/api/execution/abstract_execution_listener/#purpose","title":"Purpose","text":"<ul> <li>Provide a type-safe listener interface for receiving detailed updates on order status transitions.</li> </ul>"},{"location":"reference/api/execution/abstract_execution_listener/#standard-order-events","title":"Standard Order Events","text":"Method Triggered On <code>onOrderSubmitted</code> Order submitted to venue or simulator. <code>onOrderAccepted</code> Order acknowledged/accepted by the exchange. <code>onOrderPartiallyFilled</code> Partial fill received; includes fill quantity. <code>onOrderFilled</code> Fully filled. <code>onOrderPendingCancel</code> Cancel request sent, waiting for confirmation. <code>onOrderCanceled</code> Canceled by user or system. <code>onOrderExpired</code> Expired due to time-in-force or system conditions. <code>onOrderRejected</code> Rejected by exchange or risk engine (with reason). <code>onOrderReplaced</code> Order was replaced with a new one."},{"location":"reference/api/execution/abstract_execution_listener/#conditional-order-events","title":"Conditional Order Events","text":"Method Triggered On <code>onOrderPendingTrigger</code> Conditional order waiting for trigger condition. <code>onOrderTriggered</code> Trigger condition met, order converted to market/limit. <code>onTrailingStopUpdated</code> Trailing stop trigger price moved."},{"location":"reference/api/execution/abstract_execution_listener/#conditional-order-flow","title":"Conditional Order Flow","text":"<pre><code>flowchart TB\n    Submit[submitOrder STOP_MARKET] --&gt; Submitted[onOrderSubmitted]\n    Submitted --&gt; Accepted[onOrderAccepted]\n    Accepted --&gt; Pending[onOrderPendingTrigger]\n    Pending --&gt;|price crosses trigger| Triggered[onOrderTriggered]\n    Triggered --&gt;|converts to MARKET| Filled[onOrderFilled]</code></pre>"},{"location":"reference/api/execution/abstract_execution_listener/#trailing-stop-flow","title":"Trailing Stop Flow","text":"<pre><code>flowchart TB\n    Submit[submitOrder TRAILING_STOP] --&gt; Pending[onOrderPendingTrigger]\n    Pending --&gt;|price moves favorably| Update1[onTrailingStopUpdated]\n    Update1 --&gt;|price continues| Update2[onTrailingStopUpdated]\n    Update2 -.-&gt;|...| UpdateN[onTrailingStopUpdated]\n    UpdateN --&gt;|price reverses to trigger| Triggered[onOrderTriggered]\n    Triggered --&gt; Filled[onOrderFilled]</code></pre>"},{"location":"reference/api/execution/abstract_execution_listener/#notes","title":"Notes","text":"<ul> <li>Each listener is identified via a stable <code>SubscriberId</code>.</li> <li>Used in tandem with <code>OrderEvent::dispatchTo()</code> to decouple producers from listeners.</li> <li>Implemented by components such as <code>PositionManager</code>, <code>ExecutionTracker</code>, and metrics/reporting modules.</li> <li>All methods have default empty implementations.</li> </ul>"},{"location":"reference/api/execution/abstract_execution_listener/#see-also","title":"See Also","text":"<ul> <li>OrderEvent \u2014 Event structure</li> <li>OrderExecutionBus \u2014 Event bus</li> <li>Order \u2014 Order structure</li> </ul>"},{"location":"reference/api/execution/abstract_executor/","title":"IOrderExecutor","text":"<p><code>IOrderExecutor</code> defines the interface for components responsible for submitting, canceling, and replacing orders. It acts as the execution gateway in both simulated and live environments.</p> <pre><code>struct OCOParams\n{\n  Order order1;\n  Order order2;\n};\n\nclass IOrderExecutor : public ISubsystem {\npublic:\n  virtual ~IOrderExecutor() = default;\n\n  virtual void submitOrder(const Order&amp; order) {}\n  virtual void cancelOrder(OrderId orderId) {}\n  virtual void cancelAllOrders(SymbolId symbol) {}\n  virtual void replaceOrder(OrderId oldOrderId, const Order&amp; newOrder) {}\n\n  // OCO: one-cancels-other\n  virtual void submitOCO(const OCOParams&amp; params) {}\n\n  // Capability discovery\n  virtual ExchangeCapabilities capabilities() const { return ExchangeCapabilities::simulated(); }\n};\n</code></pre>"},{"location":"reference/api/execution/abstract_executor/#purpose","title":"Purpose","text":"<ul> <li>Abstract execution interface used by strategies and internal components to place and manage orders.</li> </ul>"},{"location":"reference/api/execution/abstract_executor/#order-management","title":"Order Management","text":"Method Description <code>submitOrder</code> Sends a new order to the execution venue or simulator. <code>cancelOrder</code> Cancels a previously submitted order by ID. <code>cancelAllOrders</code> Cancels all pending orders for a given symbol. <code>replaceOrder</code> Replaces an existing order with new parameters."},{"location":"reference/api/execution/abstract_executor/#oco-orders","title":"OCO Orders","text":"<pre><code>// Submit two linked orders - when one fills/cancels, the other is auto-canceled\nOCOParams params{\n  .order1 = takeProfitOrder,\n  .order2 = stopLossOrder\n};\nexecutor-&gt;submitOCO(params);\n</code></pre> Method Description <code>submitOCO</code> Submits two linked orders (one-cancels-other)."},{"location":"reference/api/execution/abstract_executor/#capability-discovery","title":"Capability Discovery","text":"<pre><code>auto caps = executor-&gt;capabilities();\nif (caps.supportsOCO()) {\n  executor-&gt;submitOCO(params);\n} else {\n  // Handle OCO manually\n}\n</code></pre> Method Description <code>capabilities</code> Returns <code>ExchangeCapabilities</code> describing what the executor supports. <p>See ExchangeCapabilities for full capability list.</p>"},{"location":"reference/api/execution/abstract_executor/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code>, enabling lifecycle coordination via <code>start()</code> and <code>stop()</code>.</li> <li>Can be backed by mocks, simulators, or real exchange adapters.</li> <li>Actual routing and fill simulation logic resides in concrete subclasses.</li> <li>All methods have default empty implementations for optional overriding.</li> </ul>"},{"location":"reference/api/execution/exchange_capabilities/","title":"ExchangeCapabilities","text":"<p><code>ExchangeCapabilities</code> provides feature discovery for execution venues, allowing strategies to check which order types and features are supported.</p> <pre><code>struct ExchangeCapabilities {\n  uint32_t supportedOrderTypes{0};\n  uint32_t supportedTimeInForce{0};\n  bool supportsReduceOnly{true};\n  bool supportsClosePosition{true};\n  bool supportsOCO{true};\n\n  bool supports(OrderType type) const noexcept;\n  bool supports(TimeInForce tif) const noexcept;\n\n  static ExchangeCapabilities all() noexcept;\n  static ExchangeCapabilities simulated() noexcept;\n};\n</code></pre>"},{"location":"reference/api/execution/exchange_capabilities/#purpose","title":"Purpose","text":"<ul> <li>Enable runtime feature discovery for exchange/executor capabilities.</li> <li>Allow strategies to adapt behavior based on available features.</li> <li>Prevent submission of unsupported order types.</li> </ul>"},{"location":"reference/api/execution/exchange_capabilities/#usage","title":"Usage","text":"<pre><code>// Get capabilities from executor\nauto caps = executor-&gt;capabilities();\n\n// Check order type support\nif (caps.supports(OrderType::TRAILING_STOP)) {\n  emitTrailingStop(symbol, Side::SELL, offset, qty);\n} else {\n  // Fallback to manual trailing logic\n}\n\n// Check time-in-force support\nif (caps.supports(TimeInForce::POST_ONLY)) {\n  emitLimitBuy(symbol, price, qty, TimeInForce::POST_ONLY);\n}\n\n// Check OCO support\nif (caps.supportsOCO) {\n  // Use OCO orders\n}\n</code></pre>"},{"location":"reference/api/execution/exchange_capabilities/#fields","title":"Fields","text":"Field Description supportedOrderTypes Bitmask of supported <code>OrderType</code> values. supportedTimeInForce Bitmask of supported <code>TimeInForce</code> values. supportsReduceOnly Whether reduceOnly flag is supported. supportsClosePosition Whether closePosition flag is supported. supportsOCO Whether OCO (one-cancels-other) orders work."},{"location":"reference/api/execution/exchange_capabilities/#methods","title":"Methods","text":""},{"location":"reference/api/execution/exchange_capabilities/#supportsordertype-type","title":"<code>supports(OrderType type)</code>","text":"<p>Returns <code>true</code> if the given order type is supported.</p> <pre><code>bool canUseStop = caps.supports(OrderType::STOP_MARKET);\n</code></pre>"},{"location":"reference/api/execution/exchange_capabilities/#supportstimeinforce-tif","title":"<code>supports(TimeInForce tif)</code>","text":"<p>Returns <code>true</code> if the given time-in-force policy is supported.</p> <pre><code>bool canUseIOC = caps.supports(TimeInForce::IOC);\n</code></pre>"},{"location":"reference/api/execution/exchange_capabilities/#factory-methods","title":"Factory Methods","text":""},{"location":"reference/api/execution/exchange_capabilities/#exchangecapabilitiesall","title":"<code>ExchangeCapabilities::all()</code>","text":"<p>Returns capabilities with all features enabled. Use for testing.</p>"},{"location":"reference/api/execution/exchange_capabilities/#exchangecapabilitiessimulated","title":"<code>ExchangeCapabilities::simulated()</code>","text":"<p>Returns capabilities for <code>SimulatedExecutor</code>: * All order types supported * All time-in-force policies supported * All flags supported * OCO supported</p>"},{"location":"reference/api/execution/exchange_capabilities/#implementation-notes","title":"Implementation Notes","text":"<p>Order types are stored as a bitmask for efficient checking:</p> <pre><code>bool supports(OrderType type) const noexcept {\n  return (supportedOrderTypes &amp; (1u &lt;&lt; static_cast&lt;uint8_t&gt;(type))) != 0;\n}\n</code></pre>"},{"location":"reference/api/execution/exchange_capabilities/#handling-unsupported-features","title":"Handling Unsupported Features","text":"<p>When a strategy attempts to use an unsupported feature, the executor should reject the order with a clear error:</p> <pre><code>if (!capabilities().supports(order.type)) {\n  OrderEvent ev;\n  ev.status = OrderEventStatus::REJECTED;\n  ev.order = order;\n  ev.rejectReason = \"Order type not supported by exchange\";\n  callback(ev);\n  return;\n}\n</code></pre>"},{"location":"reference/api/execution/exchange_capabilities/#see-also","title":"See Also","text":"<ul> <li>IOrderExecutor \u2014 Executor interface</li> <li>OrderType \u2014 Order types</li> <li>TimeInForce \u2014 Time-in-force policies</li> </ul>"},{"location":"reference/api/execution/execution_tracker_adapter/","title":"ExecutionTrackerAdapter","text":"<p><code>ExecutionTrackerAdapter</code> is a proxy that forwards order execution events to an <code>IExecutionTracker</code>, timestamping each transition with <code>steady_clock::now()</code>.</p> <pre><code>class ExecutionTrackerAdapter : public ISubsystem, public IOrderExecutionListener\n{\npublic:\n  ExecutionTrackerAdapter(SubscriberId id, IExecutionTracker* tracker);\n  // All IOrderExecutionListener methods overridden\nprivate:\n  IExecutionTracker* _tracker = nullptr;\n};\n</code></pre>"},{"location":"reference/api/execution/execution_tracker_adapter/#purpose","title":"Purpose","text":"<ul> <li>Decouple execution tracking logic from the event delivery mechanism by timestamping and delegating events to a metrics recorder.</li> </ul>"},{"location":"reference/api/execution/execution_tracker_adapter/#responsibilities","title":"Responsibilities","text":"Method Delegated To <code>onOrderSubmitted</code> <code>_tracker-&gt;onOrderSubmitted(..., now)</code> <code>onOrderAccepted</code> <code>_tracker-&gt;onOrderAccepted(..., now)</code> <code>onOrderPartiallyFilled</code> <code>_tracker-&gt;onOrderPartiallyFilled(..., now)</code> <code>onOrderFilled</code> <code>_tracker-&gt;onOrderFilled(..., now)</code> <code>onOrderCanceled</code> <code>_tracker-&gt;onOrderCanceled(..., now)</code> <code>onOrderExpired</code> <code>_tracker-&gt;onOrderExpired(..., now)</code> <code>onOrderRejected</code> <code>_tracker-&gt;onOrderRejected(..., now)</code> <code>onOrderReplaced</code> <code>_tracker-&gt;onOrderReplaced(..., now)</code>"},{"location":"reference/api/execution/execution_tracker_adapter/#notes","title":"Notes","text":"<ul> <li>Inherits from both <code>ISubsystem</code> (for lifecycle management) and <code>IOrderExecutionListener</code> (for event handling).</li> <li>Uses <code>std::chrono::steady_clock::now()</code> to consistently timestamp all events.</li> <li>The adapter does not own the <code>IExecutionTracker</code>; it assumes external lifetime management.</li> <li>Enables clean separation of metrics collection from trading logic.</li> </ul>"},{"location":"reference/api/execution/multi_execution_listener/","title":"MultiExecutionListener","text":"<p><code>MultiExecutionListener</code> fans out order lifecycle events to multiple <code>IOrderExecutionListener</code> targets. It acts as a multicast adapter for <code>OrderExecutionBus</code> subscribers.</p> <pre><code>class MultiExecutionListener : public IOrderExecutionListener {\npublic:\n  explicit MultiExecutionListener(SubscriberId id);\n  void addListener(IOrderExecutionListener* listener);\n\n  // All event methods delegate to added listeners\n};\n</code></pre>"},{"location":"reference/api/execution/multi_execution_listener/#purpose","title":"Purpose","text":"<ul> <li>Aggregate multiple execution listeners into a single subscriber to avoid duplicating subscriptions to the <code>OrderExecutionBus</code>.</li> </ul>"},{"location":"reference/api/execution/multi_execution_listener/#responsibilities","title":"Responsibilities","text":"Method Behavior <code>addListener()</code> Registers a new listener (if not already added). Event handlers Forwards all events to each registered listener."},{"location":"reference/api/execution/multi_execution_listener/#notes","title":"Notes","text":"<ul> <li>Listeners are stored as raw pointers; ownership is not transferred.</li> <li>Prevents duplicate listeners using <code>std::ranges::find()</code>.</li> <li>Efficient for use cases like simultaneously tracking PnL, latency, and order audit logs.</li> </ul>"},{"location":"reference/api/execution/order/","title":"Order","text":"<p><code>Order</code> encapsulates all information related to a client-side order, including identifiers, execution parameters, status, timestamps, and advanced order features.</p> <pre><code>struct ExecutionFlags\n{\n  uint8_t reduceOnly : 1 = 0;\n  uint8_t closePosition : 1 = 0;\n  uint8_t postOnly : 1 = 0;\n  uint8_t _reserved : 5 = 0;\n};\n\nstruct Order\n{\n  OrderId id{};\n  Side side{};\n  Price price{};\n  Quantity quantity{};\n  OrderType type{};\n  SymbolId symbol{};\n\n  Quantity filledQuantity{0};\n\n  TimePoint createdAt{};\n  std::optional&lt;TimePoint&gt; lastUpdated{};\n  std::optional&lt;TimePoint&gt; expiresAfter{};\n  std::optional&lt;TimePoint&gt; exchangeTimestamp{};\n\n  // Advanced order fields\n  TimeInForce timeInForce{TimeInForce::GTC};\n  ExecutionFlags flags{};\n  Price triggerPrice{};             // for stop/TP orders\n  Price trailingOffset{};           // for trailing stop (fixed)\n  int32_t trailingCallbackRate{0};  // for trailing stop (bps, 100 = 1%)\n\n  // Metadata\n  uint64_t clientOrderId{0};\n  uint16_t strategyId{0};\n  uint16_t orderTag{0};  // for OCO grouping\n\n  // Iceberg\n  Quantity visibleQuantity{};  // visible size (0 = full)\n};\n</code></pre>"},{"location":"reference/api/execution/order/#purpose","title":"Purpose","text":"<ul> <li>Represent an order's full lifecycle \u2014 from submission to final state \u2014 including fill progress, exchange timestamps, and status.</li> </ul>"},{"location":"reference/api/execution/order/#core-fields","title":"Core Fields","text":"Field Description id Globally unique order identifier. side Buy or sell. price Limit price; ignored for market orders. quantity Total order size in base units. type <code>LIMIT</code>, <code>MARKET</code>, <code>STOP_MARKET</code>, <code>STOP_LIMIT</code>, etc. symbol Compact numeric symbol reference (<code>SymbolId</code>). filledQuantity Accumulated quantity filled so far."},{"location":"reference/api/execution/order/#timestamps","title":"Timestamps","text":"Field Description createdAt Local creation timestamp. lastUpdated Timestamp of last known state transition. expiresAfter Optional expiry deadline (e.g. for IOC/GTD enforcement). exchangeTimestamp When the exchange acknowledged the order (if applicable)."},{"location":"reference/api/execution/order/#advanced-order-fields","title":"Advanced Order Fields","text":"Field Description timeInForce <code>GTC</code>, <code>IOC</code>, <code>FOK</code>, <code>GTD</code> (default: GTC). flags Execution flags (see below). triggerPrice Trigger price for stop/take-profit orders. trailingOffset Fixed offset for trailing stop orders. trailingCallbackRate Trailing stop callback rate in bps (100 = 1%)."},{"location":"reference/api/execution/order/#executionflags","title":"ExecutionFlags","text":"Flag Description reduceOnly Order can only reduce position, not increase. closePosition Order should close entire position. postOnly Order must be maker; rejects if would take."},{"location":"reference/api/execution/order/#metadata","title":"Metadata","text":"Field Description clientOrderId User-defined ID for correlation. strategyId ID of the strategy that created the order. orderTag Tag for order grouping (e.g., OCO pairs)."},{"location":"reference/api/execution/order/#iceberg-orders","title":"Iceberg Orders","text":"Field Description visibleQuantity Visible size in order book (0 = full order)."},{"location":"reference/api/execution/order/#notes","title":"Notes","text":"<ul> <li>Used as the payload in <code>OrderEvent</code> messages.</li> <li>All timestamps are based on <code>steady_clock</code> for monotonic sequencing.</li> <li>Immutable once submitted; all updates produce new events and/or replacement orders.</li> <li>Advanced fields support conditional orders (stop-loss, take-profit, trailing stop).</li> <li><code>orderTag</code> enables OCO (one-cancels-other) order grouping.</li> </ul>"},{"location":"reference/api/execution/order_tracker/","title":"OrderTracker","text":"<p><code>OrderTracker</code> is a thread-safe container for tracking order state throughout the order lifecycle. It provides mutex-protected access to order status, fills, and exchange metadata with unlimited capacity.</p> <pre><code>struct OrderState {\n  Order localOrder;\n  std::string exchangeOrderId;\n  std::string clientOrderId;\n  OrderEventStatus status{OrderEventStatus::NEW};\n  Quantity filled{};\n  TimePoint createdAt{};\n  TimePoint lastUpdate{};\n\n  bool isTerminal() const noexcept;\n};\n\nclass OrderTracker {\npublic:\n  OrderTracker() = default;\n\n  bool onSubmitted(const Order&amp; order, std::string_view exchangeOrderId,\n                   std::string_view clientOrderId = \"\");\n  bool onFilled(OrderId id, Quantity fill);\n  bool onPendingCancel(OrderId id);\n  bool onCanceled(OrderId id);\n  bool onRejected(OrderId id, std::string_view reason);\n  bool onReplaced(OrderId oldId, const Order&amp; newOrder,\n                  std::string_view newExchangeId, std::string_view newClientOrderId = \"\");\n\n  std::optional&lt;OrderState&gt; get(OrderId id) const;\n  bool exists(OrderId id) const;\n  bool isActive(OrderId id) const;\n  std::optional&lt;OrderEventStatus&gt; getStatus(OrderId id) const;\n\n  size_t activeOrderCount() const;\n  size_t totalOrderCount() const;\n  void pruneTerminal();\n};\n</code></pre>"},{"location":"reference/api/execution/order_tracker/#purpose","title":"Purpose","text":"<ul> <li>Track order lifecycle from submission to completion.</li> <li>Provide thread-safe access to order state from multiple components.</li> <li>Map between local <code>OrderId</code>, exchange order IDs, and client order IDs.</li> <li>Handle edge cases gracefully (double cancel, duplicate IDs, etc.).</li> </ul>"},{"location":"reference/api/execution/order_tracker/#methods","title":"Methods","text":"Method Returns Description <code>onSubmitted(order, exchangeId, clientId)</code> <code>bool</code> Record new order. Returns <code>false</code> if OrderId already exists. <code>onFilled(id, fill)</code> <code>bool</code> Update filled quantity. Returns <code>false</code> if order not found or terminal. <code>onPendingCancel(id)</code> <code>bool</code> Mark as pending cancel. Returns <code>false</code> if order not found or terminal. <code>onCanceled(id)</code> <code>bool</code> Mark as canceled. Returns <code>false</code> if already terminal (safe double-cancel). <code>onRejected(id, reason)</code> <code>bool</code> Mark as rejected. Returns <code>false</code> if already terminal. <code>onReplaced(oldId, newOrder, ...)</code> <code>bool</code> Handle order amendment. Marks old as REPLACED, inserts new. <code>get(id)</code> <code>optional&lt;OrderState&gt;</code> Retrieve order state copy (nullopt if not found). <code>exists(id)</code> <code>bool</code> Check if order exists. <code>isActive(id)</code> <code>bool</code> Check if order exists and is not terminal. <code>getStatus(id)</code> <code>optional&lt;Status&gt;</code> Get just the status without copying full state. <code>activeOrderCount()</code> <code>size_t</code> Count of non-terminal orders. <code>totalOrderCount()</code> <code>size_t</code> Total orders in tracker. <code>pruneTerminal()</code> <code>void</code> Remove all terminal orders to free memory."},{"location":"reference/api/execution/order_tracker/#orderstate-fields","title":"OrderState Fields","text":"Field Type Description <code>localOrder</code> <code>Order</code> The original order structure. <code>exchangeOrderId</code> <code>std::string</code> Exchange-assigned order ID. <code>clientOrderId</code> <code>std::string</code> Client-assigned order ID (optional). <code>status</code> <code>OrderEventStatus</code> Current order status. <code>filled</code> <code>Quantity</code> Total quantity filled. <code>createdAt</code> <code>TimePoint</code> When order was submitted. <code>lastUpdate</code> <code>TimePoint</code> Last state update timestamp."},{"location":"reference/api/execution/order_tracker/#terminal-states","title":"Terminal States","text":"<p>An order is considered terminal when status is one of:</p> <ul> <li><code>FILLED</code> \u2014 fully executed</li> <li><code>CANCELED</code> \u2014 canceled by user or system</li> <li><code>REJECTED</code> \u2014 rejected by exchange</li> <li><code>EXPIRED</code> \u2014 time-in-force expired</li> </ul> <p>Terminal orders cannot be modified. Methods return <code>false</code> when attempting to modify terminal orders.</p>"},{"location":"reference/api/execution/order_tracker/#thread-safety","title":"Thread Safety","text":"<ul> <li>All methods are protected by <code>std::mutex</code>.</li> <li>Safe for concurrent access from multiple threads.</li> <li><code>get()</code> returns a copy to avoid holding locks during processing.</li> </ul>"},{"location":"reference/api/execution/order_tracker/#memory-management","title":"Memory Management","text":"<ul> <li>Uses <code>std::unordered_map</code> \u2014 no fixed capacity limit.</li> <li>Call <code>pruneTerminal()</code> periodically to remove completed orders.</li> <li>Recommended: prune after each trading session or when memory is a concern.</li> </ul>"},{"location":"reference/api/execution/order_tracker/#example-usage","title":"Example Usage","text":"<pre><code>OrderTracker tracker;\n\n// Submit order\nOrder order{.id = 1, .symbol = 100, .side = Side::BUY, ...};\nif (!tracker.onSubmitted(order, \"EX123\", \"CLIENT456\")) {\n  // Duplicate order ID - handle error\n}\n\n// Check state\nif (auto state = tracker.get(order.id)) {\n  std::cout &lt;&lt; \"Exchange ID: \" &lt;&lt; state-&gt;exchangeOrderId &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Status: \" &lt;&lt; static_cast&lt;int&gt;(state-&gt;status) &lt;&lt; \"\\n\";\n}\n\n// Safe double-cancel\ntracker.onCanceled(order.id);  // returns true\ntracker.onCanceled(order.id);  // returns false, no error\n\n// Cleanup\ntracker.pruneTerminal();\n</code></pre>"},{"location":"reference/api/execution/order_tracker/#see-also","title":"See Also","text":"<ul> <li>Order \u2014 Order structure definition</li> <li>OrderEvent \u2014 Order event for bus delivery</li> <li>IExecutor \u2014 Executor interface</li> </ul>"},{"location":"reference/api/execution/bus/order_execution_bus/","title":"OrderExecutionBus","text":"<p><code>OrderExecutionBus</code> is a Disruptor-style delivery channel for <code>OrderEvent</code> messages, used to notify downstream components (e.g. PnL trackers, position managers) about order lifecycle events.</p> <pre><code>using OrderExecutionBus = EventBus&lt;OrderEvent&gt;;\n\nstd::unique_ptr&lt;OrderExecutionBus&gt; createOptimalOrderExecutionBus(bool enablePerformanceOptimizations = false);\nbool configureOrderExecutionBusForPerformance(OrderExecutionBus&amp; bus, bool enablePerformanceOptimizations = false);\n</code></pre>"},{"location":"reference/api/execution/bus/order_execution_bus/#purpose","title":"Purpose","text":"<ul> <li>Fan-out dispatch of <code>OrderEvent</code>s to registered execution listeners.</li> </ul>"},{"location":"reference/api/execution/bus/order_execution_bus/#responsibilities","title":"Responsibilities","text":"Aspect Description Payload Transports <code>OrderEvent</code> instances directly (no pooling). Pattern Disruptor-style ring buffer with lock-free sequencing. Usage Used to notify components like <code>PositionManager</code>, <code>PnLTracker</code>, etc."},{"location":"reference/api/execution/bus/order_execution_bus/#factory-functions","title":"Factory Functions","text":"Function Description <code>createOptimalOrderExecutionBus()</code> Creates bus with optimal CPU affinity for execution. <code>configureOrderExecutionBusForPerformance()</code> Configures existing bus for optimal performance."},{"location":"reference/api/execution/bus/order_execution_bus/#notes","title":"Notes","text":"<ul> <li>Uses <code>ComponentType::EXECUTION</code> for CPU affinity configuration.</li> <li>Dispatch is resolved via <code>EventDispatcher&lt;OrderEvent&gt;</code>, which calls <code>dispatchTo(listener)</code>.</li> <li>Supports optional CPU affinity via <code>FLOX_CPU_AFFINITY_ENABLED</code>.</li> </ul>"},{"location":"reference/api/execution/events/order_event/","title":"OrderEvent","text":"<p><code>OrderEvent</code> encapsulates a single order lifecycle transition and delivers it to components via <code>OrderExecutionBus</code>.</p> <pre><code>enum class OrderEventStatus {\n  NEW,\n  SUBMITTED,\n  ACCEPTED,\n  PARTIALLY_FILLED,\n  FILLED,\n  PENDING_CANCEL,\n  CANCELED,\n  EXPIRED,\n  REJECTED,\n  REPLACED,\n  // Conditional order statuses\n  PENDING_TRIGGER,\n  TRIGGERED,\n  TRAILING_UPDATED\n};\n\nstruct OrderEvent {\n  using Listener = IOrderExecutionListener;\n\n  OrderEventStatus status{};\n  Order order{};\n  Order newOrder{};\n  Quantity fillQty{0};\n  std::string rejectReason;\n\n  // For fills and trailing updates\n  Price fillPrice{};\n  Price newTrailingPrice{};\n\n  uint64_t tickSequence{0};\n  uint64_t recvNs{0};\n  uint64_t publishNs{0};\n  int64_t exchangeTsNs{0};\n\n  void dispatchTo(IOrderExecutionListener&amp; listener) const;\n};\n</code></pre>"},{"location":"reference/api/execution/events/order_event/#purpose","title":"Purpose","text":"<ul> <li>Represent and route order state changes (submission, fills, cancelation, etc.) to execution listeners.</li> </ul>"},{"location":"reference/api/execution/events/order_event/#core-fields","title":"Core Fields","text":"Field Description status Event type \u2014 one of the <code>OrderEventStatus</code> values. order The primary order involved in the event. newOrder Used only for <code>REPLACED</code> events. fillQty Quantity filled (used in <code>PARTIALLY_FILLED</code> and <code>FILLED</code>). rejectReason Human-readable rejection reason (for <code>REJECTED</code> events). tickSequence Event ordering marker for sequencing and backtesting."},{"location":"reference/api/execution/events/order_event/#advanced-fields","title":"Advanced Fields","text":"Field Description fillPrice Execution price for filled orders. newTrailingPrice Updated trigger price for <code>TRAILING_UPDATED</code> events. recvNs Receive timestamp (nanoseconds). publishNs Publish timestamp (nanoseconds). exchangeTsNs Exchange timestamp (nanoseconds)."},{"location":"reference/api/execution/events/order_event/#ordereventstatus","title":"OrderEventStatus","text":"Status Description <code>NEW</code> Order created but not yet submitted. <code>SUBMITTED</code> Order sent to exchange. <code>ACCEPTED</code> Exchange acknowledged the order. <code>PARTIALLY_FILLED</code> Order partially executed. <code>FILLED</code> Order fully executed. <code>PENDING_CANCEL</code> Cancel request sent. <code>CANCELED</code> Order canceled. <code>EXPIRED</code> Order expired (GTD/IOC). <code>REJECTED</code> Order rejected by exchange. <code>REPLACED</code> Order modified (price/quantity change). <code>PENDING_TRIGGER</code> Conditional order waiting for trigger condition. <code>TRIGGERED</code> Conditional order trigger condition met. <code>TRAILING_UPDATED</code> Trailing stop trigger price updated."},{"location":"reference/api/execution/events/order_event/#dispatch-logic","title":"Dispatch Logic","text":"<pre><code>void dispatchTo(IOrderExecutionListener&amp; listener) const;\n</code></pre> <p>Routes the event to the appropriate method:</p> Status Dispatched Method <code>SUBMITTED</code> <code>onOrderSubmitted(order)</code> <code>ACCEPTED</code> <code>onOrderAccepted(order)</code> <code>PARTIALLY_FILLED</code> <code>onOrderPartiallyFilled(order, fillQty)</code> <code>FILLED</code> <code>onOrderFilled(order)</code> <code>PENDING_CANCEL</code> <code>onOrderPendingCancel(order)</code> <code>CANCELED</code> <code>onOrderCanceled(order)</code> <code>EXPIRED</code> <code>onOrderExpired(order)</code> <code>REJECTED</code> <code>onOrderRejected(order, rejectReason)</code> <code>REPLACED</code> <code>onOrderReplaced(order, newOrder)</code> <code>PENDING_TRIGGER</code> <code>onOrderPendingTrigger(order)</code> <code>TRIGGERED</code> <code>onOrderTriggered(order)</code> <code>TRAILING_UPDATED</code> <code>onTrailingStopUpdated(order, newTrailingPrice)</code>"},{"location":"reference/api/execution/events/order_event/#notes","title":"Notes","text":"<ul> <li>Dispatch is type-safe and static \u2014 no RTTI or dynamic casts.</li> <li><code>tickSequence</code> ensures global ordering consistency across mixed event streams.</li> <li>Used by <code>EventBus&lt;OrderEvent, *&gt;</code> and delivered to <code>IOrderExecutionListener</code> implementations.</li> <li>Conditional order statuses (<code>PENDING_TRIGGER</code>, <code>TRIGGERED</code>, <code>TRAILING_UPDATED</code>) are emitted by <code>SimulatedExecutor</code> during backtest.</li> </ul>"},{"location":"reference/api/execution/events/order_event/#see-also","title":"See Also","text":"<ul> <li>Order \u2014 Order structure</li> <li>IOrderExecutionListener \u2014 Event listener interface</li> <li>OrderExecutionBus \u2014 Event bus</li> </ul>"},{"location":"reference/api/killswitch/abstract_killswitch/","title":"IKillSwitch","text":"<p><code>IKillSwitch</code> defines the interface for components that enforce emergency shutdown conditions in the trading system, typically in response to loss limits, excessive order flow, or abnormal conditions.</p> <pre><code>class IKillSwitch : public ISubsystem {\npublic:\n  virtual ~IKillSwitch() = default;\n\n  virtual void check(const Order&amp; order) = 0;\n  virtual void trigger(const std::string&amp; reason) = 0;\n  virtual bool isTriggered() const = 0;\n  virtual std::string reason() const = 0;\n};\n</code></pre>"},{"location":"reference/api/killswitch/abstract_killswitch/#purpose","title":"Purpose","text":"<ul> <li>Provide runtime protection against runaway strategies, loss accumulation, or systemic failures by halting all trading activity.</li> </ul>"},{"location":"reference/api/killswitch/abstract_killswitch/#responsibilities","title":"Responsibilities","text":"Method Description <code>check(order)</code> Evaluates the incoming order against risk limits. <code>trigger()</code> Manually activates the kill switch with a reason string. <code>isTriggered()</code> Returns whether the kill switch is currently active. <code>reason()</code> Returns the human-readable cause of activation."},{"location":"reference/api/killswitch/abstract_killswitch/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code>, allowing coordinated startup and reset across engine lifecycle.</li> <li>Can be wired into strategy layer, order executor, or global event loop.</li> <li>Once triggered, downstream components are expected to halt order submission and processing.</li> </ul>"},{"location":"reference/api/log/abstract_logger/","title":"Logger","text":"<p>The <code>ILogger</code> interface defines a minimal, abstract logging API for internal and external use.</p> <p>It provides a consistent way to report messages of varying severity and supports multiple logging strategies, including console, file, and shared-memory loggers.</p>"},{"location":"reference/api/log/abstract_logger/#interface","title":"Interface","text":"<pre><code>enum class LogLevel {\n  Info,\n  Warn,\n  Error\n};\n\nenum class OverflowPolicy {\n  Drop,      // Silently drop new messages when buffer is full\n  Overwrite  // Overwrite oldest messages\n};\n\nstruct ILogger {\n  virtual ~ILogger() = default;\n\n  virtual void info(std::string_view msg) = 0;\n  virtual void warn(std::string_view msg) = 0;\n  virtual void error(std::string_view msg) = 0;\n};\n</code></pre>"},{"location":"reference/api/log/abstract_logger/#usage","title":"Usage","text":"<p>You can implement <code>ILogger</code> to customize how logs are handled. For example:</p> <ul> <li>Writing to <code>stdout</code> or <code>stderr</code></li> <li>Writing to rotating log files</li> <li>Logging to <code>/dev/shm</code> for high-speed shared memory logging</li> <li>Filtering messages based on <code>LogLevel</code></li> <li>Batching or compressing logs for network transmission</li> </ul> <p>Example implementation for stdout:</p> <pre><code>struct StdoutLogger : public ILogger {\n  void info(std::string_view msg) override {\n    std::cout &lt;&lt; \"[INFO] \" &lt;&lt; msg &lt;&lt; std::endl;\n  }\n  void warn(std::string_view msg) override {\n    std::cout &lt;&lt; \"[WARN] \" &lt;&lt; msg &lt;&lt; std::endl;\n  }\n  void error(std::string_view msg) override {\n    std::cerr &lt;&lt; \"[ERROR] \" &lt;&lt; msg &lt;&lt; std::endl;\n  }\n};\n</code></pre>"},{"location":"reference/api/log/abstract_logger/#overflow-policy","title":"Overflow Policy","text":"<p>When used in conjunction with buffered or lock-free logging systems, <code>OverflowPolicy</code> governs what happens when the log buffer is full:</p> <ul> <li><code>Drop</code>: new incoming messages are discarded.</li> <li><code>Overwrite</code>: older messages are overwritten to make space.</li> </ul> <p>This allows you to trade off between completeness and real-time guarantees.</p>"},{"location":"reference/api/log/abstract_logger/#best-practices","title":"Best Practices","text":"<ul> <li>Do not use logging in latency-critical paths (e.g. market data callbacks) unless the logger is designed for low-latency (e.g. lock-free).</li> <li>Prefer shared-memory or file-backed logging for persistency.</li> <li>Use <code>LogLevel</code> filtering to avoid excessive log volume in production.</li> </ul>"},{"location":"reference/api/log/abstract_logger/#related","title":"Related","text":"<ul> <li><code>AtomicLogger</code>: ultra-low-latency lock-free logger implementation in FLOX</li> <li><code>LogLevel</code>: enumeration for severity control</li> <li><code>OverflowPolicy</code>: controls log buffering behavior</li> </ul>"},{"location":"reference/api/log/atomic_logger/","title":"AtomicLogger","text":"<p><code>AtomicLogger</code> is a low-latency, lock-free logger implementation designed for high-performance environments. It supports log-level filtering, auto-rotation by time or size, and writes to shared memory by default (<code>/dev/shm</code>).</p>"},{"location":"reference/api/log/atomic_logger/#purpose","title":"Purpose","text":"<ul> <li>Avoid allocations and locks on the hot path (<code>info</code>, <code>warn</code>, <code>error</code>)</li> <li>Defer I/O to a background thread</li> <li>Support size/time-based log rotation</li> <li>Enable high-throughput logging in performance-critical systems</li> </ul>"},{"location":"reference/api/log/atomic_logger/#construction","title":"Construction","text":"<pre><code>AtomicLoggerOptions opts;\nopts.levelThreshold = LogLevel::Warn;\nopts.basename = \"flox.log\";\nopts.directory = \"/var/log/flox\";\nopts.maxFileSize = 10 * 1024 * 1024;\nopts.rotateInterval = std::chrono::minutes(30);\n\nauto logger = std::make_unique&lt;AtomicLogger&gt;(opts);\n</code></pre>"},{"location":"reference/api/log/atomic_logger/#options","title":"Options","text":"Field Description <code>overflow</code> <code>Drop</code> or <code>Overwrite</code> when buffer is full <code>levelThreshold</code> Minimum <code>LogLevel</code> to log <code>basename</code> Log file base name (e.g. <code>flox.log</code>) <code>directory</code> Directory for log output (e.g. <code>/dev/shm</code>) <code>maxFileSize</code> Maximum size before rotation <code>rotateInterval</code> Time-based rotation window <code>flushImmediately</code> If <code>true</code>, flush immediately after each message"},{"location":"reference/api/log/atomic_logger/#implementation-details","title":"Implementation Details","text":"<ul> <li>Ring buffer of fixed-size entries (1024)</li> <li>Each entry stores: timestamp, level, message (max 256 bytes)</li> <li>A background thread reads the buffer and writes to file</li> <li>Rotation occurs when file size exceeds <code>maxFileSize</code> or interval passes</li> </ul>"},{"location":"reference/api/log/atomic_logger/#threading-model","title":"Threading Model","text":"<ul> <li>Writers: lock-free, use atomic <code>_writeIndex</code></li> <li>Flusher: single thread consumes entries using <code>_readIndex</code></li> <li>Coordination: via condition variable (new entries or periodic wake-up)</li> </ul>"},{"location":"reference/api/log/atomic_logger/#sample-usage","title":"Sample Usage","text":"<pre><code>AtomicLogger logger;\nlogger.info(\"Engine started\");\nlogger.warn(\"Price feed delayed\");\nlogger.error(\"Order failed: rejected by risk\");\n</code></pre>"},{"location":"reference/api/log/atomic_logger/#format","title":"Format","text":"<p>Log entries are printed with timestamp and level prefix:</p> <pre><code>2025-07-14T08:42:03Z [INFO] Engine started\n2025-07-14T08:42:04Z [WARN] Order queue near capacity\n2025-07-14T08:42:05Z [ERROR] RiskManager::allow rejected order\n</code></pre>"},{"location":"reference/api/log/atomic_logger/#notes","title":"Notes","text":"<ul> <li>Buffer overflow behavior depends on <code>OverflowPolicy</code></li> <li>Log rotation renames the file with a timestamp suffix</li> <li>Avoid writing long messages: max message size is 256 bytes</li> <li>Log flushing is done in a separate thread to reduce latency</li> </ul>"},{"location":"reference/api/log/atomic_logger/#related","title":"Related","text":"<ul> <li><code>ILogger</code>: base interface</li> <li><code>OverflowPolicy</code>: defines handling strategy when buffer is full</li> <li><code>LogLevel</code>: defines filtering threshold</li> </ul>"},{"location":"reference/api/log/console_logger/","title":"ConsoleLogger","text":"<p><code>ConsoleLogger</code> is a simple <code>ILogger</code> implementation that writes log messages directly to standard output.</p>"},{"location":"reference/api/log/console_logger/#purpose","title":"Purpose","text":"<ul> <li>Provide a minimal, zero-setup logger for testing and development</li> <li>Print log messages to console (<code>stdout</code>)</li> <li>Filter messages based on severity level</li> </ul>"},{"location":"reference/api/log/console_logger/#construction","title":"Construction","text":"<pre><code>ConsoleLogger logger(LogLevel::Warn);\nlogger.info(\"This will be filtered out\");\nlogger.warn(\"This will be printed\");\n</code></pre> <p>The constructor accepts a <code>LogLevel</code> threshold. Messages below the threshold are ignored.</p>"},{"location":"reference/api/log/console_logger/#methods","title":"Methods","text":"Method Description <code>info(msg)</code> Logs a message with <code>LogLevel::Info</code> <code>warn(msg)</code> Logs a message with <code>LogLevel::Warn</code> <code>error(msg)</code> Logs a message with <code>LogLevel::Error</code> <code>log(level, msg)</code> Logs a message at specified level (manual use)"},{"location":"reference/api/log/console_logger/#output-format","title":"Output Format","text":"<p>The logger prepends each message with a fixed label, e.g.:</p> <pre><code>[INFO]  Engine started\n[WARN]  Config missing field 'symbol'\n[ERROR] Order rejected by validator\n</code></pre>"},{"location":"reference/api/log/console_logger/#filtering","title":"Filtering","text":"<p>Only messages with a level greater than or equal to the configured <code>LogLevel</code> are printed:</p> <pre><code>ConsoleLogger logger(LogLevel::Warn);\nlogger.info(\"Ignored\");\nlogger.warn(\"Printed\");\n</code></pre>"},{"location":"reference/api/log/console_logger/#notes","title":"Notes","text":"<ul> <li><code>ConsoleLogger</code> is not thread-safe</li> <li>Suitable only for testing, not recommended for production</li> <li>Use <code>AtomicLogger</code> for performance-critical logging</li> </ul>"},{"location":"reference/api/log/console_logger/#related","title":"Related","text":"<ul> <li><code>ILogger</code>: base interface</li> <li><code>LogLevel</code>: severity levels used for filtering</li> </ul>"},{"location":"reference/api/log/log/","title":"Logging Macros","text":"<p>FLOX provides a set of lightweight logging macros with compile-time and runtime control. These macros wrap <code>LogStream</code> for structured message building and support selective log-level filtering.</p>"},{"location":"reference/api/log/log/#macros-overview","title":"Macros Overview","text":"Macro Description <code>FLOX_LOG(...)</code> Logs message at <code>Info</code> level <code>FLOX_LOG_INFO(...)</code> Shortcut for <code>Info</code> level <code>FLOX_LOG_WARN(...)</code> Shortcut for <code>Warn</code> level <code>FLOX_LOG_ERROR(...)</code> Shortcut for <code>Error</code> level <code>FLOX_LOG_LEVEL(lvl, ...)</code> Logs at custom level (<code>LogLevel</code>) <code>FLOX_LOG_ON()</code> Enable runtime logging <code>FLOX_LOG_OFF()</code> Disable runtime logging"},{"location":"reference/api/log/log/#logstream-integration","title":"LogStream Integration","text":"<p>All macros internally use <code>LogStream</code>, a RAII-style helper that sends the log message when it goes out of scope.</p> <p>Example:</p> <pre><code>FLOX_LOG(\"Book update: bid=\" &lt;&lt; update.bestBidPrice());\nFLOX_LOG_WARN(\"Rejecting order due to risk check failure\");\n</code></pre> <p>This is equivalent to:</p> <pre><code>if (isLoggingEnabled())\n  LogStream(LogLevel::Warn) &lt;&lt; \"Rejecting order due to risk check failure\";\n</code></pre> <p>The benefit is a clean, familiar <code>operator&lt;&lt;</code> syntax and delayed message formatting, only evaluated if logging is enabled.</p>"},{"location":"reference/api/log/log/#compile-time-disable","title":"Compile-Time Disable","text":"<p>If <code>FLOX_DISABLE_LOGGING</code> is defined at compile time, all logging macros become no-ops:</p> <pre><code>#define FLOX_DISABLE_LOGGING\n</code></pre> <p>This is useful for benchmark builds or environments where logging must be completely stripped out.</p>"},{"location":"reference/api/log/log/#thread-safety","title":"Thread Safety","text":"<ul> <li>Logging macros are thread-safe if the selected logger (e.g. <code>AtomicLogger</code>) is thread-safe.</li> <li>Overhead is minimal: each macro checks a global atomic <code>loggingEnabled</code> flag before constructing a <code>LogStream</code>.</li> </ul>"},{"location":"reference/api/log/log/#notes","title":"Notes","text":"<ul> <li>No log message will be emitted if <code>FLOX_LOG_OFF()</code> was called or logging was disabled at runtime.</li> <li>Message formatting is deferred until <code>LogStream</code> destructor runs.</li> <li>Logs can be redirected by configuring a global logger (<code>ILogger</code> implementation).</li> </ul>"},{"location":"reference/api/metrics/abstract_execution_tracker/","title":"IExecutionTracker","text":"<p><code>IExecutionTracker</code> defines an interface for tracking order lifecycle events with precise timestamps. It is typically used for latency analysis, logging, and performance metrics.</p> <pre><code>class IExecutionTracker : public ISubsystem {\npublic:\n  virtual ~IExecutionTracker() = default;\n\n  virtual void onOrderSubmitted(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderAccepted(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty, TimePoint ts) = 0;\n  virtual void onOrderFilled(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderCanceled(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderExpired(const Order&amp; order, TimePoint ts) = 0;\n  virtual void onOrderRejected(const Order&amp; order, const std::string&amp; reason, TimePoint ts) = 0;\n  virtual void onOrderReplaced(const Order&amp; oldOrder, const Order&amp; newOrder, TimePoint ts) = 0;\n};\n</code></pre>"},{"location":"reference/api/metrics/abstract_execution_tracker/#purpose","title":"Purpose","text":"<ul> <li>Capture precise timing of each order state transition for performance diagnostics and post-trade analysis.</li> </ul>"},{"location":"reference/api/metrics/abstract_execution_tracker/#responsibilities","title":"Responsibilities","text":"Method Captures <code>onOrderSubmitted</code> Time of initial submission. <code>onOrderAccepted</code> Time acknowledged by exchange or venue. <code>onOrderPartiallyFilled</code> Time of partial fill, including filled quantity. <code>onOrderFilled</code> Time of full fill. <code>onOrderCanceled</code> Time of cancel confirmation. <code>onOrderExpired</code> Time the order was marked as expired. <code>onOrderRejected</code> Time of rejection, including optional reason. <code>onOrderReplaced</code> Time of order replacement, with reference to both old and new."},{"location":"reference/api/metrics/abstract_execution_tracker/#notes","title":"Notes","text":"<ul> <li>All timestamps are provided externally (usually by <code>ExecutionTrackerAdapter</code>) to ensure consistency.</li> <li>Used in simulations and live systems for detailed latency tracking and event sequencing.</li> <li>Inherits from <code>ISubsystem</code> for lifecycle integration with the engine.</li> <li>Does not track conditional order events (<code>onOrderPendingCancel</code>, <code>onOrderPendingTrigger</code>, <code>onOrderTriggered</code>, <code>onTrailingStopUpdated</code>). Use IOrderExecutionListener for full order lifecycle tracking.</li> </ul>"},{"location":"reference/api/metrics/abstract_execution_tracker/#see-also","title":"See Also","text":"<ul> <li>IOrderExecutionListener \u2014 Full order lifecycle listener</li> <li>ExecutionTrackerAdapter \u2014 Bridges listener to tracker</li> </ul>"},{"location":"reference/api/metrics/abstract_pnl_tracker/","title":"IPnLTracker","text":"<p><code>IPnLTracker</code> defines a minimal interface for tracking realized and unrealized profit and loss (PnL) based on filled orders.</p> <pre><code>class IPnLTracker : public ISubsystem {\npublic:\n  virtual ~IPnLTracker() = default;\n  virtual void onOrderFilled(const Order&amp; order) = 0;\n};\n</code></pre>"},{"location":"reference/api/metrics/abstract_pnl_tracker/#purpose","title":"Purpose","text":"<ul> <li>Record and update PnL metrics in response to order fill events.</li> </ul>"},{"location":"reference/api/metrics/abstract_pnl_tracker/#responsibilities","title":"Responsibilities","text":"Method Description <code>onOrderFilled</code> Called when an order is fully filled; updates PnL."},{"location":"reference/api/metrics/abstract_pnl_tracker/#notes","title":"Notes","text":"<ul> <li>Invoked only on complete fills \u2014 partial fills should be handled at a higher level if needed.</li> <li>Used in both real-time and simulation modes to compute performance metrics.</li> <li>Inherits from <code>ISubsystem</code> for coordinated lifecycle management.</li> </ul>"},{"location":"reference/api/net/abstract_transport/","title":"ITransport","text":"<p><code>ITransport</code> defines an abstract interface for sending asynchronous HTTP POST requests, allowing components to perform remote communication with external services.</p> <pre><code>class ITransport {\npublic:\n  virtual ~ITransport() = default;\n\n  virtual void post(\n    std::string_view url,\n    std::string_view body,\n    const std::vector&lt;std::pair&lt;std::string_view, std::string_view&gt;&gt;&amp; headers,\n    MoveOnlyFunction&lt;void(std::string_view)&gt; onSuccess,\n    MoveOnlyFunction&lt;void(std::string_view)&gt; onError) = 0;\n};\n</code></pre>"},{"location":"reference/api/net/abstract_transport/#purpose","title":"Purpose","text":"<ul> <li>Provide a generic mechanism to send HTTP POST requests without coupling to a specific transport library or implementation.</li> <li>Enable integration with APIs, webhooks, or external risk/configuration services.</li> </ul>"},{"location":"reference/api/net/abstract_transport/#responsibilities","title":"Responsibilities","text":"Method Description <code>post()</code> Sends a POST request to the specified URL with custom headers and body. Invokes success or error callback based on result."},{"location":"reference/api/net/abstract_websocket_client/","title":"IWebSocketClient","text":"<p><code>IWebSocketClient</code> defines a minimal interface for managing WebSocket connections, including lifecycle control and message handling via callbacks.</p> <pre><code>class IWebSocketClient : public ISubsystem {\npublic:\n  virtual ~IWebSocketClient() = default;\n\n  virtual void onOpen(MoveOnlyFunction&lt;void()&gt; cb) = 0;\n  virtual void onMessage(MoveOnlyFunction&lt;void(std::string_view)&gt; cb) = 0;\n  virtual void onClose(MoveOnlyFunction&lt;void(int, std::string_view)&gt; cb) = 0;\n\n  virtual void send(const std::string&amp; data) = 0;\n};\n</code></pre>"},{"location":"reference/api/net/abstract_websocket_client/#purpose","title":"Purpose","text":"<ul> <li>Provide an abstraction for WebSocket communication used by exchange connectors and other components.</li> <li>Enable pluggable transport implementations with consistent interface.</li> </ul>"},{"location":"reference/api/net/abstract_websocket_client/#responsibilities","title":"Responsibilities","text":"Method Description <code>onOpen()</code> Registers a callback to be invoked when the connection is successfully opened. <code>onMessage()</code> Registers a callback for receiving incoming text messages. <code>onClose()</code> Registers a callback to handle disconnection events with code and reason. <code>send()</code> Sends a text message over the active WebSocket connection. <code>start()</code> Initiates the WebSocket connection and starts event processing (inherited from ISubsystem) <code>stop()</code> Gracefully closes the connection and stops background processing (inherited from ISubsystem)"},{"location":"reference/api/position/abstract_position_manager/","title":"IPositionManager","text":"<p><code>IPositionManager</code> maintains real-time position tracking per symbol and reacts to all order execution events. It is a core component for portfolio state management in both live trading and simulation.</p> <pre><code>class IPositionManager : public ISubsystem, public IOrderExecutionListener {\npublic:\n  explicit IPositionManager(SubscriberId id);\n  virtual ~IPositionManager() = default;\n\n  virtual Quantity getPosition(SymbolId symbol) const = 0;\n};\n</code></pre>"},{"location":"reference/api/position/abstract_position_manager/#purpose","title":"Purpose","text":"<ul> <li>Track and expose current position sizes for all traded instruments in response to order events.</li> </ul>"},{"location":"reference/api/position/abstract_position_manager/#responsibilities","title":"Responsibilities","text":"Method Description <code>getPosition()</code> Returns net position (long/short/flat) for a given <code>SymbolId</code>. Execution events Inherited from <code>IOrderExecutionListener</code> \u2014 updates position on <code>FILLED</code>, <code>REPLACED</code>, etc."},{"location":"reference/api/position/abstract_position_manager/#notes","title":"Notes","text":"<ul> <li>Acts as a persistent state store for strategies, risk systems, and reporting.</li> <li>Must be registered with <code>OrderExecutionBus</code> to receive fill and cancel notifications.</li> <li>Can optionally implement position limits or exposure constraints internally.</li> </ul>"},{"location":"reference/api/position/abstract_position_manager/#implementation","title":"Implementation","text":"<p>Use <code>PositionTracker</code> for a full-featured implementation with:</p> <ul> <li>FIFO, LIFO, and AVERAGE cost basis methods</li> <li>Realized PnL calculation</li> <li>Average entry price tracking</li> </ul> <p>See PositionTracker for details.</p>"},{"location":"reference/api/position/abstract_position_manager/#see-also","title":"See Also","text":"<ul> <li>PositionTracker - Full implementation with cost basis methods</li> </ul>"},{"location":"reference/api/position/position_tracker/","title":"PositionTracker","text":"<p><code>PositionTracker</code> implements <code>IPositionManager</code> with full support for FIFO, LIFO, and Average cost basis methods. This is critical for compliance and accurate PnL reporting.</p> <pre><code>enum class CostBasisMethod { FIFO, LIFO, AVERAGE };\n\nclass PositionTracker : public IPositionManager\n{\npublic:\n  PositionTracker(SubscriberId id, CostBasisMethod method = CostBasisMethod::FIFO);\n};\n</code></pre>"},{"location":"reference/api/position/position_tracker/#purpose","title":"Purpose","text":"<ul> <li>Track positions across all symbols</li> <li>Calculate realized PnL using configurable cost basis method</li> <li>Provide average entry price for position sizing and risk management</li> <li>Thread-safe access from multiple components</li> </ul>"},{"location":"reference/api/position/position_tracker/#cost-basis-methods","title":"Cost Basis Methods","text":""},{"location":"reference/api/position/position_tracker/#fifo-first-in-first-out","title":"FIFO (First In, First Out)","text":"<p>Oldest lots are closed first. Default method, required by many tax jurisdictions.</p> <pre><code>Buy 10 @ $100\nBuy 10 @ $110\nSell 15 @ $120\n\nRealized PnL:\n- Close 10 @ $100: ($120 - $100) * 10 = $200\n- Close 5 @ $110: ($120 - $110) * 5 = $50\nTotal: $250\n\nRemaining: 5 @ $110\n</code></pre>"},{"location":"reference/api/position/position_tracker/#lifo-last-in-first-out","title":"LIFO (Last In, First Out)","text":"<p>Newest lots are closed first.</p> <pre><code>Buy 10 @ $100\nBuy 10 @ $110\nSell 15 @ $120\n\nRealized PnL:\n- Close 10 @ $110: ($120 - $110) * 10 = $100\n- Close 5 @ $100: ($120 - $100) * 5 = $100\nTotal: $200\n\nRemaining: 5 @ $100\n</code></pre>"},{"location":"reference/api/position/position_tracker/#average-volume-weighted-average","title":"AVERAGE (Volume-Weighted Average)","text":"<p>All lots consolidated into single VWAP position.</p> <pre><code>Buy 10 @ $100\nBuy 10 @ $110\nAvg price: (10*100 + 10*110) / 20 = $105\n\nSell 15 @ $120\nRealized PnL: ($120 - $105) * 15 = $225\n\nRemaining: 5 @ $105\n</code></pre>"},{"location":"reference/api/position/position_tracker/#api","title":"API","text":""},{"location":"reference/api/position/position_tracker/#constructor","title":"Constructor","text":"<pre><code>PositionTracker(SubscriberId id, CostBasisMethod method = CostBasisMethod::FIFO);\n</code></pre>"},{"location":"reference/api/position/position_tracker/#position-queries","title":"Position Queries","text":"<pre><code>Quantity getPosition(SymbolId symbol) const override;\nPrice getAvgEntryPrice(SymbolId symbol) const;\nPrice getRealizedPnl(SymbolId symbol) const;\nPrice getTotalRealizedPnl() const;\nCostBasisMethod method() const;\n</code></pre>"},{"location":"reference/api/position/position_tracker/#order-event-handlers","title":"Order Event Handlers","text":"<p>Inherited from <code>IOrderExecutionListener</code>:</p> <pre><code>void onOrderFilled(const Order&amp; order) override;\nvoid onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty) override;\n</code></pre>"},{"location":"reference/api/position/position_tracker/#example-usage","title":"Example Usage","text":""},{"location":"reference/api/position/position_tracker/#backtest-integration","title":"Backtest Integration","text":"<pre><code>BacktestConfig config;\nconfig.initialCapital = 10000.0;\nconfig.feeRate = 0.0004;\n\nBacktestRunner runner(config);\n\n// Create strategy\nMyStrategy strategy(1, symbol);\nrunner.setStrategy(&amp;strategy);\n\n// Add position tracker\nPositionTracker positions(2, CostBasisMethod::FIFO);\nrunner.addExecutionListener(&amp;positions);\n\n// Run backtest\nauto result = runner.run(*reader);\n\n// Check results\nstd::cout &lt;&lt; \"Position: \" &lt;&lt; positions.getPosition(symbol).toDouble() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Avg entry: \" &lt;&lt; positions.getAvgEntryPrice(symbol).toDouble() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Realized PnL: \" &lt;&lt; positions.getRealizedPnl(symbol).toDouble() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/position/position_tracker/#multiple-symbols","title":"Multiple Symbols","text":"<pre><code>PositionTracker tracker(1, CostBasisMethod::LIFO);\n\n// Track fills from executor\nexecutor.addExecutionListener(&amp;tracker);\n\n// Query per-symbol\nfor (SymbolId sym : symbols)\n{\n  std::cout &lt;&lt; \"Symbol \" &lt;&lt; sym &lt;&lt; \": \"\n            &lt;&lt; tracker.getPosition(sym).toDouble() &lt;&lt; \" @ \"\n            &lt;&lt; tracker.getAvgEntryPrice(sym).toDouble() &lt;&lt; \"\\n\";\n}\n\n// Total across all symbols\nstd::cout &lt;&lt; \"Total realized PnL: \" &lt;&lt; tracker.getTotalRealizedPnl().toDouble() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/position/position_tracker/#internal-structure","title":"Internal Structure","text":""},{"location":"reference/api/position/position_tracker/#lot-based-tracking","title":"Lot-Based Tracking","text":"<pre><code>struct Lot\n{\n  Quantity quantity;  // Signed: positive=long, negative=short\n  Price price;        // Entry price (fixed-point)\n};\n\nstruct PositionState\n{\n  std::deque&lt;Lot&gt; lots;   // Open lots\n  Price realizedPnl{};    // Accumulated realized PnL (fixed-point)\n\n  Quantity position() const;    // Sum of lot quantities\n  Price avgEntryPrice() const;  // VWAP of open lots\n};\n</code></pre>"},{"location":"reference/api/position/position_tracker/#position-updates","title":"Position Updates","text":"<ol> <li>Opening trade: Add new lot to deque</li> <li>Closing trade: Remove lots per cost basis method, calculate realized PnL</li> <li>Flipping trade (long to short): Close all, then open opposite</li> </ol> <p>For AVERAGE method, lots are consolidated into single VWAP lot.</p>"},{"location":"reference/api/position/position_tracker/#thread-safety","title":"Thread Safety","text":"<p>All public methods are protected by <code>std::mutex</code>: - Safe for concurrent access from multiple threads - Position queries can be called while fills are being processed - Uses <code>SymbolStateMap</code> for O(1) per-symbol access</p>"},{"location":"reference/api/position/position_tracker/#fixed-point-arithmetic","title":"Fixed-Point Arithmetic","text":"<p>All calculations use <code>Price</code> and <code>Quantity</code> fixed-point types: - No floating-point precision issues - Portable across all platforms (no <code>__int128</code>) - Intermediate calculations use <code>double</code> then convert back</p>"},{"location":"reference/api/position/position_tracker/#compliance-notes","title":"Compliance Notes","text":"<ul> <li>FIFO is required by IRS for tax reporting (US)</li> <li>LIFO may be preferred for tax optimization (where allowed)</li> <li>AVERAGE is common for mutual funds and some jurisdictions</li> <li>All methods track exact lot-level PnL for audit trails</li> </ul>"},{"location":"reference/api/position/position_tracker/#migration-notes","title":"Migration Notes","text":"<p><code>getRealizedPnl()</code> and <code>getTotalRealizedPnl()</code> now return <code>Price</code> instead of <code>double</code>:</p> <pre><code>// Old API\ndouble pnl = tracker.getRealizedPnl(symbol);\n\n// New API\nPrice pnl = tracker.getRealizedPnl(symbol);\ndouble pnlDouble = pnl.toDouble();  // If double needed\n</code></pre>"},{"location":"reference/api/position/position_tracker/#see-also","title":"See Also","text":"<ul> <li>IPositionManager - Interface definition</li> <li>Strategy - Strategy base class</li> <li>BacktestRunner - Backtesting framework</li> </ul>"},{"location":"reference/api/replay/binary_format/","title":"Binary Log Format (v1)","text":"<p>The replay system uses a compact binary format optimized for sequential reads and fast seeks. All multi-byte values are little-endian. Structures are aligned for direct memory mapping.</p>"},{"location":"reference/api/replay/binary_format/#file-structure","title":"File Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          SegmentHeader (64B)         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            Frame 0                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502     FrameHeader (12B)          \u2502  \u2502\n\u2502  \u2502     Record (variable)          \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            Frame 1                   \u2502\n\u2502              ...                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502            Frame N                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      SegmentIndex (optional)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/api/replay/binary_format/#segmentheader-64-bytes","title":"SegmentHeader (64 bytes)","text":"Offset Size Field Description 0 4 magic <code>0x584F4C46</code> (\"FLOX\") 4 2 version Format version (currently 1) 6 1 flags Bit flags (see below) 7 1 exchange_id Exchange identifier 8 8 created_ns Segment creation timestamp (ns) 16 8 first_event_ns First event timestamp (ns) 24 8 last_event_ns Last event timestamp (ns) 32 4 event_count Total events in segment 36 4 symbol_count Unique symbols in segment 40 8 index_offset Byte offset to index (0 if none) 48 1 compression Compression type (0=none, 1=LZ4) 49 15 reserved Reserved for future use"},{"location":"reference/api/replay/binary_format/#segment-flags","title":"Segment Flags","text":"Bit Name Description 0 HasIndex Segment contains seek index 1 Compressed Data is LZ4 compressed 2 Encrypted Data is encrypted (reserved)"},{"location":"reference/api/replay/binary_format/#frameheader-12-bytes","title":"FrameHeader (12 bytes)","text":"<p>Each event is wrapped in a frame for integrity checking:</p> Offset Size Field Description 0 4 size Payload size (excluding header) 4 4 crc32 CRC32 of payload 8 1 type Event type (1=Trade, 2=Book, 3=Delta) 9 1 rec_version Record format version 10 2 flags Reserved"},{"location":"reference/api/replay/binary_format/#traderecord-48-bytes","title":"TradeRecord (48 bytes)","text":"Offset Size Field Description 0 8 exchange_ts_ns Exchange timestamp (ns) 8 8 recv_ts_ns Local receive timestamp (ns) 16 8 price_raw Price (fixed-point, 8 decimals) 24 8 qty_raw Quantity (fixed-point) 32 8 trade_id Exchange trade ID 40 4 symbol_id Symbol registry ID 44 1 side 0=sell, 1=buy 45 1 instrument Instrument type 46 2 exchange_id Exchange identifier"},{"location":"reference/api/replay/binary_format/#bookrecordheader-40-bytes","title":"BookRecordHeader (40 bytes)","text":"Offset Size Field Description 0 8 exchange_ts_ns Exchange timestamp (ns) 8 8 recv_ts_ns Local receive timestamp (ns) 16 8 seq Sequence number 24 4 symbol_id Symbol registry ID 28 2 bid_count Number of bid levels 30 2 ask_count Number of ask levels 32 1 type 0=snapshot, 1=delta 33 1 instrument Instrument type 34 2 exchange_id Exchange identifier 36 4 _pad Alignment padding <p>Immediately following the header are <code>bid_count + ask_count</code> BookLevel entries.</p>"},{"location":"reference/api/replay/binary_format/#booklevel-16-bytes","title":"BookLevel (16 bytes)","text":"Offset Size Field Description 0 8 price_raw Price (fixed-point, 9 decimals) 8 8 qty_raw Quantity (fixed-point)"},{"location":"reference/api/replay/binary_format/#compressed-block-format","title":"Compressed Block Format","text":"<p>When compression is enabled, events are grouped into blocks:</p>"},{"location":"reference/api/replay/binary_format/#compressedblockheader-16-bytes","title":"CompressedBlockHeader (16 bytes)","text":"Offset Size Field Description 0 4 magic <code>0x4B4C4246</code> (\"FBLK\") 4 4 compressed_size Size after compression 8 4 original_size Size before compression 12 2 event_count Events in this block 14 2 flags Reserved"},{"location":"reference/api/replay/binary_format/#segment-index","title":"Segment Index","text":"<p>An optional index enables fast timestamp-based seeking:</p>"},{"location":"reference/api/replay/binary_format/#segmentindexheader-32-bytes","title":"SegmentIndexHeader (32 bytes)","text":"Offset Size Field Description 0 4 magic <code>0x58444E49</code> (\"INDX\") 4 2 version Index version (currently 1) 6 2 interval Events between index entries 8 4 entry_count Number of index entries 12 4 crc32 CRC32 of index entries 16 8 first_ts_ns First indexed timestamp 24 8 last_ts_ns Last indexed timestamp"},{"location":"reference/api/replay/binary_format/#indexentry-16-bytes","title":"IndexEntry (16 bytes)","text":"Offset Size Field Description 0 8 timestamp_ns Event timestamp 8 8 file_offset Byte offset in segment file"},{"location":"reference/api/replay/binary_format/#global-index","title":"Global Index","text":"<p>A manifest file tracks all segments in a data directory:</p>"},{"location":"reference/api/replay/binary_format/#globalindexheader-64-bytes","title":"GlobalIndexHeader (64 bytes)","text":"Offset Size Field Description 0 4 magic <code>0x58444947</code> (\"GIDX\") 4 2 version Version (currently 1) 6 2 flags Reserved 8 8 created_ns Index creation timestamp 16 8 first_event_ns Earliest event across segments 24 8 last_event_ns Latest event across segments 32 4 segment_count Number of segments 36 4 crc32 CRC32 of segment entries 40 8 total_events Total events across all segments 48 8 string_table_offset Offset to filename strings 56 8 reserved Reserved"},{"location":"reference/api/replay/binary_format/#globalindexsegment-48-bytes","title":"GlobalIndexSegment (48 bytes)","text":"Offset Size Field Description 0 8 first_event_ns First event in segment 8 8 last_event_ns Last event in segment 16 4 event_count Events in segment 20 4 flags Segment flags 24 8 file_size Segment file size 32 8 filename_offset Offset into string table 40 8 _reserved Reserved"},{"location":"reference/api/replay/binary_format/#crc32","title":"CRC32","text":"<p>All CRC32 values use the standard polynomial <code>0xEDB88320</code> (IEEE 802.3).</p>"},{"location":"reference/api/replay/binary_log_reader/","title":"BinaryLogReader","text":"<p><code>BinaryLogReader</code> provides sequential access to market data stored in the binary log format. It handles segment discovery, time filtering, symbol filtering, and CRC verification.</p> <pre><code>struct ReaderConfig\n{\n  std::filesystem::path data_dir;\n  std::optional&lt;int64_t&gt; from_ns;\n  std::optional&lt;int64_t&gt; to_ns;\n  std::set&lt;uint32_t&gt; symbols;\n  bool verify_crc{true};\n};\n\nclass BinaryLogReader\n{\npublic:\n  explicit BinaryLogReader(ReaderConfig config);\n\n  // Static inspection (no event reading)\n  static DatasetSummary inspect(const std::filesystem::path&amp; data_dir);\n  static DatasetSummary inspectWithSymbols(const std::filesystem::path&amp; data_dir);\n\n  // Instance methods\n  DatasetSummary summary();\n  uint64_t count();\n  std::set&lt;uint32_t&gt; availableSymbols();\n\n  // Iteration\n  using EventCallback = std::function&lt;bool(const ReplayEvent&amp;)&gt;;\n  bool forEach(EventCallback callback);\n  bool forEachFrom(int64_t start_ts_ns, EventCallback callback);\n\n  // Metadata\n  std::optional&lt;std::pair&lt;int64_t, int64_t&gt;&gt; timeRange() const;\n  ReaderStats stats() const;\n  std::vector&lt;std::filesystem::path&gt; segmentFiles() const;\n  const std::vector&lt;SegmentInfo&gt;&amp; segments() const;\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#purpose","title":"Purpose","text":"<ul> <li>Read market data from binary log segments in chronological order.</li> <li>Filter events by time range and symbol set.</li> <li>Support both full scans and timestamp-based seeks.</li> </ul>"},{"location":"reference/api/replay/binary_log_reader/#configuration","title":"Configuration","text":"Field Type Description data_dir <code>filesystem::path</code> Directory containing <code>.floxlog</code> files from_ns <code>optional&lt;int64_t&gt;</code> Start timestamp filter (inclusive) to_ns <code>optional&lt;int64_t&gt;</code> End timestamp filter (inclusive) symbols <code>set&lt;uint32_t&gt;</code> Symbol IDs to include (empty = all) verify_crc <code>bool</code> Verify CRC32 checksums (default: true)"},{"location":"reference/api/replay/binary_log_reader/#core-methods","title":"Core Methods","text":"Method Description <code>inspect()</code> Static scan of directory, returns metadata without reading events <code>inspectWithSymbols()</code> Like <code>inspect()</code> but also collects symbol IDs <code>summary()</code> Returns dataset metadata after scanning <code>count()</code> Returns total event count across all segments <code>forEach()</code> Iterate all events matching filters <code>forEachFrom()</code> Iterate events starting from a timestamp <code>timeRange()</code> Returns (first_event_ns, last_event_ns) pair <code>stats()</code> Returns read statistics (events, bytes, errors) <code>segmentFiles()</code> Returns list of segment file paths <code>segments()</code> Returns detailed segment information"},{"location":"reference/api/replay/binary_log_reader/#data-structures","title":"Data Structures","text":""},{"location":"reference/api/replay/binary_log_reader/#datasetsummary","title":"DatasetSummary","text":"<pre><code>struct DatasetSummary\n{\n  std::filesystem::path data_dir;\n\n  int64_t first_event_ns{0};\n  int64_t last_event_ns{0};\n\n  uint64_t total_events{0};\n  uint32_t segment_count{0};\n  uint64_t total_bytes{0};\n\n  std::set&lt;uint32_t&gt; symbols;\n\n  uint32_t segments_with_index{0};\n  uint32_t segments_without_index{0};\n\n  // Helper methods\n  bool empty() const;\n  std::chrono::nanoseconds duration() const;\n  double durationSeconds() const;\n  double durationMinutes() const;\n  double durationHours() const;\n  bool fullyIndexed() const;\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#replayevent","title":"ReplayEvent","text":"<pre><code>struct ReplayEvent\n{\n  EventType type;           // Trade, BookSnapshot, or BookDelta\n  int64_t timestamp_ns;     // Event timestamp\n\n  TradeRecord trade;        // Populated for Trade events\n\n  BookRecordHeader book_header;  // Populated for Book events\n  std::vector&lt;BookLevel&gt; bids;\n  std::vector&lt;BookLevel&gt; asks;\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#readerstats","title":"ReaderStats","text":"<pre><code>struct ReaderStats\n{\n  uint64_t files_read{0};\n  uint64_t events_read{0};\n  uint64_t trades_read{0};\n  uint64_t book_updates_read{0};\n  uint64_t bytes_read{0};\n  uint64_t crc_errors{0};\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#segmentinfo","title":"SegmentInfo","text":"<pre><code>struct SegmentInfo\n{\n  std::filesystem::path path;\n  int64_t first_event_ns{0};\n  int64_t last_event_ns{0};\n  uint32_t event_count{0};\n  bool has_index{false};\n  uint64_t index_offset{0};\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#usage","title":"Usage","text":"<pre><code>replay::ReaderConfig config{\n    .data_dir = \"/data/market\",\n    .from_ns = start_timestamp,\n    .to_ns = end_timestamp,\n    .symbols = {1, 2, 3}\n};\n\nreplay::BinaryLogReader reader(config);\n\nreader.forEach([](const replay::ReplayEvent&amp; event) {\n    if (event.type == replay::EventType::Trade) {\n        // Process trade\n    } else {\n        // Process book update\n    }\n    return true;  // Continue iteration\n});\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#time-utilities","title":"Time Utilities","text":"<p>The <code>time_utils</code> namespace provides helper functions:</p> <pre><code>namespace replay::time_utils\n{\n  int64_t toNanos(std::chrono::system_clock::time_point tp);\n  std::chrono::system_clock::time_point fromNanos(int64_t ns);\n  int64_t nowNanos();\n  int64_t secondsToNanos(int64_t seconds);\n  int64_t millisToNanos(int64_t millis);\n  int64_t microsToNanos(int64_t micros);\n  double nanosToSeconds(int64_t ns);\n}\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#binarylogiterator","title":"BinaryLogIterator","text":"<p>Low-level iterator for reading a single segment file:</p> <pre><code>class BinaryLogIterator\n{\npublic:\n  explicit BinaryLogIterator(const std::filesystem::path&amp; segment_path);\n\n  bool next(ReplayEvent&amp; out);\n  bool seekToTimestamp(int64_t target_ts_ns);\n  bool loadIndex();\n\n  const SegmentHeader&amp; header() const;\n  bool isValid() const;\n  bool isCompressed() const;\n  bool hasIndex() const;\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_reader/#notes","title":"Notes","text":"<ul> <li>Segments are automatically discovered and sorted by timestamp.</li> <li>Compressed segments (LZ4) are transparently decompressed.</li> <li>Seeking uses segment indexes when available for O(log n) lookup.</li> <li>The callback returning <code>false</code> stops iteration early.</li> <li>File extension is <code>.floxlog</code>.</li> </ul>"},{"location":"reference/api/replay/binary_log_writer/","title":"BinaryLogWriter","text":"<p><code>BinaryLogWriter</code> writes market data to binary log segments. It handles segment rotation, compression, indexing, and CRC checksums.</p> <pre><code>// Callback for custom segment naming on rotation\nusing RotationCallback = std::filesystem::path (*)(\n    void* user_data,\n    const std::filesystem::path&amp; output_dir,\n    uint32_t segment_number);\n\nstruct WriterConfig {\n  std::filesystem::path output_dir;\n  std::string output_filename;              // Optional: first segment name\n  uint64_t max_segment_bytes{256ull &lt;&lt; 20}; // 256 MB default\n  uint64_t buffer_size{64ull &lt;&lt; 10};        // 64 KB buffer\n  uint8_t exchange_id{0};\n  bool sync_on_rotate{true};\n  bool create_index{true};\n  uint16_t index_interval{1000};            // Events per index entry\n  CompressionType compression{CompressionType::None};\n  RotationCallback rotation_callback{nullptr};  // Custom naming on rotation\n  void* rotation_user_data{nullptr};            // User data for callback\n};\n\nclass BinaryLogWriter {\npublic:\n  explicit BinaryLogWriter(WriterConfig config);\n  ~BinaryLogWriter();\n\n  bool writeTrade(const TradeRecord&amp; trade);\n  bool writeBook(const BookRecordHeader&amp; header,\n                 std::span&lt;const BookLevel&gt; bids,\n                 std::span&lt;const BookLevel&gt; asks);\n\n  void flush();\n  void close();\n\n  WriterStats stats() const;\n  std::filesystem::path currentSegmentPath() const;\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_writer/#purpose","title":"Purpose","text":"<ul> <li>Write market data (trades and book updates) to compact binary segments.</li> <li>Support automatic segment rotation, compression, and indexing.</li> <li>Provide high-throughput, low-latency recording for live market data.</li> </ul>"},{"location":"reference/api/replay/binary_log_writer/#configuration","title":"Configuration","text":"Field Default Description <code>output_dir</code> - Directory for segment files. <code>output_filename</code> - Optional filename for first segment. <code>max_segment_bytes</code> 256 MB Maximum segment size before rotation. <code>buffer_size</code> 64 KB Internal write buffer size. <code>exchange_id</code> 0 Exchange identifier in segment header. <code>sync_on_rotate</code> true Sync to disk on segment rotation. <code>create_index</code> true Build seek index in segments. <code>index_interval</code> 1000 Events between index entries. <code>compression</code> None Compression type (<code>None</code> or <code>LZ4</code>). <code>rotation_callback</code> nullptr Custom callback for segment naming on rotation. <code>rotation_user_data</code> nullptr User data passed to rotation callback."},{"location":"reference/api/replay/binary_log_writer/#methods","title":"Methods","text":"Method Description <code>writeTrade(trade)</code> Write a trade record. Returns <code>true</code> on success. <code>writeBook(header, bids, asks)</code> Write a book update. Returns <code>true</code> on success. <code>flush()</code> Flush internal buffers to disk. <code>close()</code> Close current segment, write index and header. <code>stats()</code> Returns write statistics. <code>currentSegmentPath()</code> Returns path to current segment file."},{"location":"reference/api/replay/binary_log_writer/#statistics","title":"Statistics","text":"<pre><code>struct WriterStats {\n  uint64_t bytes_written{0};\n  uint64_t events_written{0};\n  uint64_t segments_created{0};\n  uint64_t trades_written{0};\n  uint64_t book_updates_written{0};\n  uint64_t blocks_written{0};        // For compressed mode\n  uint64_t uncompressed_bytes{0};\n  uint64_t compressed_bytes{0};\n};\n</code></pre>"},{"location":"reference/api/replay/binary_log_writer/#usage","title":"Usage","text":"<pre><code>replay::WriterConfig config{\n  .output_dir = \"/data/market\",\n  .max_segment_bytes = 512ull &lt;&lt; 20,  // 512 MB segments\n  .create_index = true,\n  .compression = replay::CompressionType::LZ4\n};\n\nreplay::BinaryLogWriter writer(config);\n\n// Write trades\nreplay::TradeRecord trade{...};\nwriter.writeTrade(trade);\n\n// Write book updates\nreplay::BookRecordHeader header{...};\nstd::vector&lt;replay::BookLevel&gt; bids{...}, asks{...};\nwriter.writeBook(header, bids, asks);\n\n// Periodic flush\nwriter.flush();\n\n// Close cleanly\nwriter.close();\n</code></pre>"},{"location":"reference/api/replay/binary_log_writer/#custom-rotation-callback","title":"Custom Rotation Callback","text":"<p>By default, rotated segments use timestamp-based names. To customize naming:</p> <pre><code>// Context for the callback\nstruct MyContext {\n  std::string prefix;\n  int sequence{1};\n};\n\n// Callback function (must be a plain function, not a lambda with captures)\nstd::filesystem::path my_rotation_cb(\n    void* user_data,\n    const std::filesystem::path&amp; output_dir,\n    uint32_t segment_number)\n{\n  auto* ctx = static_cast&lt;MyContext*&gt;(user_data);\n  std::ostringstream fname;\n  fname &lt;&lt; ctx-&gt;prefix &lt;&lt; \"_\" &lt;&lt; std::setfill('0') &lt;&lt; std::setw(3)\n        &lt;&lt; (ctx-&gt;sequence + segment_number - 1) &lt;&lt; \".floxlog\";\n  return output_dir / fname.str();\n}\n\n// Usage\nMyContext ctx{\"2025-01-15\", 1};\n\nreplay::WriterConfig config{\n  .output_dir = \"/data/market\",\n  .output_filename = \"2025-01-15_001.floxlog\",  // First segment\n  .max_segment_bytes = 256ull &lt;&lt; 20,\n  .rotation_callback = my_rotation_cb,\n  .rotation_user_data = &amp;ctx,  // Must outlive writer!\n};\n\nreplay::BinaryLogWriter writer(config);\n// When segment rotates, callback generates \"2025-01-15_002.floxlog\", etc.\n</code></pre> <p>Important: The <code>rotation_user_data</code> pointer must remain valid for the lifetime of the writer.</p>"},{"location":"reference/api/replay/binary_log_writer/#notes","title":"Notes","text":"<ul> <li>Thread-safe via internal mutex.</li> <li>Segments are automatically rotated when <code>max_segment_bytes</code> is reached.</li> <li>Index enables fast timestamp-based seeking during replay.</li> <li>Compression reduces storage but adds CPU overhead.</li> <li>Call <code>close()</code> before destruction to ensure index is written.</li> </ul>"},{"location":"reference/api/replay/binary_log_writer/#see-also","title":"See Also","text":"<ul> <li>Binary Format \u2014 File format specification</li> <li>BinaryLogReader \u2014 Reading segments</li> <li>MarketDataRecorder \u2014 High-level recording interface</li> </ul>"},{"location":"reference/api/replay/market_data_recorder/","title":"MarketDataRecorder","text":"<p><code>MarketDataRecorder</code> is a high-level component that subscribes to market data buses and records events to binary log files. It implements <code>IMarketDataSubscriber</code> for seamless integration with the engine.</p> <pre><code>struct MarketDataRecorderConfig {\n  std::filesystem::path output_dir;\n  uint64_t max_segment_bytes{256ull &lt;&lt; 20};  // 256 MB\n  uint8_t exchange_id{0};\n};\n\nclass MarketDataRecorder : public IMarketDataRecorder {\npublic:\n  explicit MarketDataRecorder(MarketDataRecorderConfig config);\n  ~MarketDataRecorder() override;\n\n  // ISubsystem\n  void start() override;\n  void stop() override;\n\n  // IMarketDataSubscriber\n  SubscriberId id() const override;\n  void onBookUpdate(const BookUpdateEvent&amp; event) override;\n  void onTrade(const TradeEvent&amp; event) override;\n  void onBar(const BarEvent&amp; event) override;\n\n  // IMarketDataRecorder\n  void setOutputDir(const std::filesystem::path&amp; dir) override;\n  void flush() override;\n  RecorderStats stats() const override;\n  bool isRecording() const override;\n};\n</code></pre>"},{"location":"reference/api/replay/market_data_recorder/#purpose","title":"Purpose","text":"<ul> <li>Provide a ready-to-use market data recording solution.</li> <li>Subscribe to <code>TradeBus</code>, <code>BookUpdateBus</code>, and <code>BarBus</code> for automatic recording.</li> <li>Abstract away low-level binary format details.</li> </ul>"},{"location":"reference/api/replay/market_data_recorder/#configuration","title":"Configuration","text":"Field Default Description <code>output_dir</code> - Directory for recorded segments. <code>max_segment_bytes</code> 256 MB Maximum segment size before rotation. <code>exchange_id</code> 0 Exchange identifier in segment headers."},{"location":"reference/api/replay/market_data_recorder/#methods","title":"Methods","text":"Method Description <code>start()</code> Begin recording (creates initial segment). <code>stop()</code> Stop recording and close current segment. <code>onBookUpdate(event)</code> Record a book update event. <code>onTrade(event)</code> Record a trade event. <code>onBar(event)</code> Record a bar event (currently no-op). <code>setOutputDir(dir)</code> Change output directory (takes effect on next rotation). <code>flush()</code> Flush buffers to disk. <code>stats()</code> Returns recording statistics. <code>isRecording()</code> Returns <code>true</code> if actively recording."},{"location":"reference/api/replay/market_data_recorder/#usage","title":"Usage","text":"<pre><code>// Configure recorder\nMarketDataRecorderConfig config{\n  .output_dir = \"/data/market/btcusdt\",\n  .max_segment_bytes = 512ull &lt;&lt; 20,\n  .exchange_id = 1\n};\n\n// Create recorder\nauto recorder = std::make_shared&lt;MarketDataRecorder&gt;(config);\n\n// Subscribe to buses\ntradeBus.subscribe(recorder.get());\nbookBus.subscribe(recorder.get());\n\n// Start recording\nrecorder-&gt;start();\n\n// ... market data flows through buses ...\n\n// Stop and flush\nrecorder-&gt;stop();\n</code></pre>"},{"location":"reference/api/replay/market_data_recorder/#integration-with-engine","title":"Integration with Engine","text":"<pre><code>// In your builder\nauto recorder = std::make_shared&lt;MarketDataRecorder&gt;(recorderConfig);\n\n// Add as subsystem for lifecycle management\nsubsystems.push_back(recorder);\n\n// Subscribe to market data buses\ntradeBus-&gt;subscribe(recorder.get());\nbookUpdateBus-&gt;subscribe(recorder.get());\n\n// Engine will call start()/stop() automatically\n</code></pre>"},{"location":"reference/api/replay/market_data_recorder/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code> for automatic lifecycle management.</li> <li>Thread-safe for concurrent event delivery.</li> <li>Internally uses <code>BinaryLogWriter</code> for actual file operations.</li> <li>Call <code>flush()</code> periodically for durability guarantees.</li> <li>Segments are automatically rotated based on size.</li> </ul>"},{"location":"reference/api/replay/market_data_recorder/#see-also","title":"See Also","text":"<ul> <li>BinaryLogWriter \u2014 Low-level writer</li> <li>BinaryLogReader \u2014 Reading recorded data</li> <li>Recording Data Tutorial \u2014 Step-by-step guide</li> <li>IMarketDataSubscriber \u2014 Subscriber interface</li> </ul>"},{"location":"reference/api/replay/mmap_reader/","title":"MmapReader","text":"<p><code>MmapReader</code> provides memory-mapped access to binary log segments for zero-copy reads. Cross-platform implementation supports both POSIX (Linux/macOS) and Windows.</p> <pre><code>class MmapSegmentReader\n{\npublic:\n  explicit MmapSegmentReader(const std::filesystem::path&amp; segment_path);\n  ~MmapSegmentReader();\n\n  MmapSegmentReader(MmapSegmentReader&amp;&amp;) noexcept;\n  MmapSegmentReader&amp; operator=(MmapSegmentReader&amp;&amp;) noexcept;\n\n  bool isValid() const;\n  bool isCompressed() const;\n  bool hasIndex() const;\n\n  const SegmentHeader&amp; header() const;\n\n  const std::byte* data() const;\n  size_t dataSize() const;\n  size_t totalSize() const;\n\n  bool next(ReplayEvent&amp; out);\n  void reset();\n  bool seekToTimestamp(int64_t target_ts_ns);\n  size_t position() const;\n\n  const FrameHeader* currentFrame() const;\n  bool advanceFrame();\n\n  bool loadIndex();\n  const std::vector&lt;IndexEntry&gt;&amp; indexEntries() const;\n};\n</code></pre>"},{"location":"reference/api/replay/mmap_reader/#purpose","title":"Purpose","text":"<ul> <li>Provide zero-copy access to segment data via memory mapping.</li> <li>Enable direct pointer access to event records without buffer copying.</li> <li>Support fast timestamp-based seeking using segment indexes.</li> </ul>"},{"location":"reference/api/replay/mmap_reader/#mmapreader-multi-segment","title":"MmapReader (Multi-Segment)","text":"<pre><code>class MmapReader\n{\npublic:\n  struct Config\n  {\n    std::filesystem::path data_dir;\n    bool preload_index{true};\n    bool prefault_pages{false};\n    std::optional&lt;int64_t&gt; from_ns;\n    std::optional&lt;int64_t&gt; to_ns;\n    std::set&lt;uint32_t&gt; symbols;\n  };\n\n  explicit MmapReader(const Config&amp; config);\n\n  using EventCallback = std::function&lt;bool(const ReplayEvent&amp;)&gt;;\n  uint64_t forEach(EventCallback callback);\n  uint64_t forEachFrom(int64_t start_ts_ns, EventCallback callback);\n\n  using RawTradeCallback = std::function&lt;bool(const TradeRecord*)&gt;;\n  uint64_t forEachRawTrade(RawTradeCallback callback);\n\n  MmapReaderStats stats() const;\n  const std::vector&lt;SegmentInfo&gt;&amp; segments() const;\n  uint64_t totalEvents() const;\n};\n</code></pre>"},{"location":"reference/api/replay/mmap_reader/#configuration","title":"Configuration","text":"Field Type Description data_dir <code>filesystem::path</code> Directory containing segments preload_index <code>bool</code> Load indexes on construction prefault_pages <code>bool</code> Touch pages to prefault into memory from_ns <code>optional&lt;int64_t&gt;</code> Start timestamp filter to_ns <code>optional&lt;int64_t&gt;</code> End timestamp filter symbols <code>set&lt;uint32_t&gt;</code> Symbol IDs to include"},{"location":"reference/api/replay/mmap_reader/#statistics","title":"Statistics","text":"<pre><code>struct MmapReaderStats\n{\n  uint64_t segments_mapped;\n  uint64_t bytes_mapped;\n  uint64_t events_read;\n  uint64_t page_faults;\n};\n</code></pre>"},{"location":"reference/api/replay/mmap_reader/#usage","title":"Usage","text":"<pre><code>replay::MmapReader::Config config{\n    .data_dir = \"/data/market\",\n    .preload_index = true\n};\n\nreplay::MmapReader reader(config);\n\nreader.forEach([](const replay::ReplayEvent&amp; event) {\n    // Process event\n    return true;\n});\n\n// Direct access to raw trade records (zero-copy)\nreader.forEachRawTrade([](const replay::TradeRecord* trade) {\n    // Access trade fields directly from mapped memory\n    return true;\n});\n</code></pre>"},{"location":"reference/api/replay/mmap_reader/#quick-count","title":"Quick Count","text":"<pre><code>uint64_t count = replay::mmapCount(\"/data/market\");\n</code></pre>"},{"location":"reference/api/replay/mmap_reader/#platform-support","title":"Platform Support","text":"Platform Implementation Linux <code>mmap()</code> / <code>munmap()</code> / <code>madvise()</code> macOS <code>mmap()</code> / <code>munmap()</code> / <code>madvise()</code> Windows <code>CreateFileMapping()</code> / <code>MapViewOfFile()</code>"},{"location":"reference/api/replay/mmap_reader/#notes","title":"Notes","text":"<ul> <li>Memory-mapped I/O avoids kernel-to-userspace copies.</li> <li>Segments remain mapped until the reader is destroyed.</li> <li><code>prefault_pages</code> can improve first-access latency at the cost of startup time.</li> <li>Does not support compressed segments (use <code>BinaryLogReader</code> for those).</li> </ul>"},{"location":"reference/api/replay/parallel_reader/","title":"ParallelReader","text":"<p><code>ParallelReader</code> processes multiple segments concurrently using a thread pool, merging results into timestamp-sorted order for delivery.</p> <pre><code>struct ParallelReaderConfig\n{\n  std::filesystem::path data_dir;\n  uint32_t num_threads{0};            // 0 = auto-detect\n  size_t prefetch_segments{2};\n  size_t event_buffer_size{10000};\n  std::optional&lt;int64_t&gt; from_ns;\n  std::optional&lt;int64_t&gt; to_ns;\n  std::set&lt;uint32_t&gt; symbols;\n  bool verify_crc{true};\n  bool sort_output{true};\n};\n\nclass ParallelReader\n{\npublic:\n  explicit ParallelReader(ParallelReaderConfig config);\n\n  using EventCallback = std::function&lt;bool(const ReplayEvent&amp;)&gt;;\n  uint64_t forEach(EventCallback callback);\n\n  using BatchCallback = std::function&lt;bool(const std::vector&lt;ReplayEvent&gt;&amp;)&gt;;\n  uint64_t forEachBatch(BatchCallback callback);\n\n  template &lt;typename Result&gt;\n  using SegmentProcessor = std::function&lt;Result(const std::vector&lt;ReplayEvent&gt;&amp;,\n                                                  const SegmentInfo&amp;)&gt;;\n\n  template &lt;typename Result&gt;\n  std::vector&lt;Result&gt; mapSegments(SegmentProcessor&lt;Result&gt; processor);\n\n  ParallelReaderStats stats() const;\n  const std::vector&lt;SegmentInfo&gt;&amp; segments() const;\n  uint32_t numThreads() const;\n};\n</code></pre>"},{"location":"reference/api/replay/parallel_reader/#purpose","title":"Purpose","text":"<ul> <li>Maximize throughput by reading multiple segments in parallel.</li> <li>Merge events from different segments into correct timestamp order.</li> <li>Enable map-reduce style processing over segments.</li> </ul>"},{"location":"reference/api/replay/parallel_reader/#configuration","title":"Configuration","text":"Field Type Description data_dir <code>filesystem::path</code> Directory containing segments num_threads <code>uint32_t</code> Thread count (0 = hardware threads) prefetch_segments <code>size_t</code> Segments to prefetch ahead event_buffer_size <code>size_t</code> Events per segment buffer from_ns <code>optional&lt;int64_t&gt;</code> Start timestamp filter to_ns <code>optional&lt;int64_t&gt;</code> End timestamp filter symbols <code>set&lt;uint32_t&gt;</code> Symbol IDs to include verify_crc <code>bool</code> Verify CRC32 checksums sort_output <code>bool</code> Merge to timestamp order"},{"location":"reference/api/replay/parallel_reader/#statistics","title":"Statistics","text":"<pre><code>struct ParallelReaderStats\n{\n  uint64_t segments_processed;\n  uint64_t events_read;\n  uint64_t trades_read;\n  uint64_t book_updates_read;\n  uint64_t bytes_read;\n  uint64_t crc_errors;\n  int64_t start_time_ns;\n  int64_t end_time_ns;\n\n  double eventsPerSecond() const;\n  double throughputMBps() const;\n};\n</code></pre>"},{"location":"reference/api/replay/parallel_reader/#usage","title":"Usage","text":""},{"location":"reference/api/replay/parallel_reader/#basic-iteration","title":"Basic Iteration","text":"<pre><code>replay::ParallelReaderConfig config{\n    .data_dir = \"/data/market\",\n    .num_threads = 4\n};\n\nreplay::ParallelReader reader(config);\n\nreader.forEach([](const replay::ReplayEvent&amp; event) {\n    // Events arrive in timestamp order\n    return true;\n});\n\nauto stats = reader.stats();\nstd::cout &lt;&lt; \"Throughput: \" &lt;&lt; stats.eventsPerSecond() &lt;&lt; \" events/sec\\n\";\n</code></pre>"},{"location":"reference/api/replay/parallel_reader/#batch-processing","title":"Batch Processing","text":"<pre><code>reader.forEachBatch([](const std::vector&lt;replay::ReplayEvent&gt;&amp; batch) {\n    // Process entire segment at once\n    return true;\n});\n</code></pre>"},{"location":"reference/api/replay/parallel_reader/#map-reduce-pattern","title":"Map-Reduce Pattern","text":"<pre><code>struct SegmentStats {\n    uint64_t trades;\n    uint64_t books;\n    double volume;\n};\n\nauto results = reader.mapSegments&lt;SegmentStats&gt;(\n    [](const std::vector&lt;replay::ReplayEvent&gt;&amp; events, const replay::SegmentInfo&amp; info) {\n        SegmentStats stats{};\n        for (const auto&amp; e : events) {\n            if (e.type == replay::EventType::Trade) {\n                stats.trades++;\n                stats.volume += e.trade.qty_raw / 1e9;\n            } else {\n                stats.books++;\n            }\n        }\n        return stats;\n    });\n</code></pre>"},{"location":"reference/api/replay/parallel_reader/#convenience-functions","title":"Convenience Functions","text":"<pre><code>// Simple parallel iteration\nuint64_t count = replay::parallelForEach(\"/data/market\", callback, 4);\n\n// Parallel event count\nuint64_t total = replay::parallelCount(\"/data/market\");\n</code></pre>"},{"location":"reference/api/replay/parallel_reader/#architecture","title":"Architecture","text":"<pre><code>flowchart TB\n    subgraph ParallelReader\n        subgraph Workers\n            direction LR\n            W0[Worker 0&lt;br/&gt;Seg 0]\n            W1[Worker 1&lt;br/&gt;Seg 1]\n            WN[Worker N&lt;br/&gt;Seg N]\n        end\n\n        Workers --&gt; MQ[Merge Queue&lt;br/&gt;k-way merge]\n        MQ --&gt; CB[Callback&lt;br/&gt;timestamp order]\n    end</code></pre>"},{"location":"reference/api/replay/parallel_reader/#notes","title":"Notes","text":"<ul> <li>Workers read segments independently and buffer events in memory.</li> <li>K-way merge produces globally sorted output when <code>sort_output=true</code>.</li> <li>Thread count defaults to <code>std::thread::hardware_concurrency()</code>.</li> <li>Best for bulk processing where I/O bandwidth is the bottleneck.</li> </ul>"},{"location":"reference/api/replay/replay_connector/","title":"ReplayConnector","text":"<p><code>ReplayConnector</code> implements <code>IReplaySource</code> to replay recorded market data through the standard connector interface. It supports variable playback speed, seeking, and deterministic backtesting.</p> <pre><code>struct ReplayConnectorConfig\n{\n  std::filesystem::path data_dir;\n  ReplaySpeed speed{ReplaySpeed::max()};\n  std::optional&lt;int64_t&gt; from_ns;\n  std::optional&lt;int64_t&gt; to_ns;\n  std::set&lt;uint32_t&gt; symbols;\n};\n\nclass ReplayConnector : public IReplaySource\n{\npublic:\n  explicit ReplayConnector(ReplayConnectorConfig config);\n\n  void start() override;\n  void stop() override;\n\n  std::string exchangeId() const override { return \"replay\"; }\n\n  std::optional&lt;TimeRange&gt; dataRange() const override;\n  void setSpeed(ReplaySpeed speed) override;\n  bool seekTo(int64_t timestamp_ns) override;\n  bool isFinished() const override;\n  int64_t currentPosition() const override;\n};\n</code></pre>"},{"location":"reference/api/replay/replay_connector/#purpose","title":"Purpose","text":"<ul> <li>Provide a drop-in replacement for live connectors during backtesting.</li> <li>Emit <code>BookUpdateEvent</code> and <code>TradeEvent</code> through the standard connector interface.</li> <li>Support deterministic, reproducible replays at maximum speed.</li> </ul>"},{"location":"reference/api/replay/replay_connector/#replayspeed","title":"ReplaySpeed","text":"<pre><code>struct ReplaySpeed\n{\n  double multiplier{0.0};\n\n  static ReplaySpeed realtime() { return {1.0}; }\n  static ReplaySpeed fast(double x) { return {x}; }\n  static ReplaySpeed max() { return {0.0}; }\n\n  bool isMax() const { return multiplier &lt;= 0.0; }\n  bool isRealtime() const { return multiplier == 1.0; }\n};\n</code></pre> Mode Multiplier Behavior <code>max()</code> 0.0 No delays, process as fast as possible <code>realtime()</code> 1.0 Wall-clock timing matches event timestamps <code>fast(x)</code> x &gt; 0 x times faster than realtime"},{"location":"reference/api/replay/replay_connector/#configuration","title":"Configuration","text":"Field Type Description data_dir <code>filesystem::path</code> Directory containing recorded segments speed <code>ReplaySpeed</code> Playback speed control from_ns <code>optional&lt;int64_t&gt;</code> Start timestamp filter to_ns <code>optional&lt;int64_t&gt;</code> End timestamp filter symbols <code>set&lt;uint32_t&gt;</code> Symbol IDs to replay"},{"location":"reference/api/replay/replay_connector/#ireplaysource-interface","title":"IReplaySource Interface","text":"Method Description <code>start()</code> Begin replay in background thread <code>stop()</code> Stop replay and join thread <code>dataRange()</code> Returns time range of available data <code>setSpeed()</code> Change playback speed during replay <code>seekTo()</code> Jump to a specific timestamp <code>isFinished()</code> Returns true when all events have been emitted <code>currentPosition()</code> Returns current replay timestamp"},{"location":"reference/api/replay/replay_connector/#usage","title":"Usage","text":"<pre><code>ReplayConnectorConfig config{\n    .data_dir = \"/data/market\",\n    .speed = ReplaySpeed::max()  // Fastest for backtesting\n};\n\nauto connector = std::make_shared&lt;ReplayConnector&gt;(config);\n\nconnector-&gt;setCallbacks(\n    [](const BookUpdateEvent&amp; ev) { /* handle book */ },\n    [](const TradeEvent&amp; ev) { /* handle trade */ }\n);\n\nconnector-&gt;start();\n\n// Wait for replay to complete\nwhile (!connector-&gt;isFinished()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n}\n\nconnector-&gt;stop();\n</code></pre>"},{"location":"reference/api/replay/replay_connector/#with-engine-integration","title":"With Engine Integration","text":"<pre><code>Engine engine(config);\n\nauto replay = std::make_shared&lt;ReplayConnector&gt;(replay_config);\nengine.addConnector(replay);\n\nengine.start();\n// Events flow through the standard connector pipeline\n</code></pre>"},{"location":"reference/api/replay/replay_connector/#speed-control","title":"Speed Control","text":"<pre><code>// Start at realtime speed\nconnector-&gt;setSpeed(ReplaySpeed::realtime());\n\n// Speed up 10x\nconnector-&gt;setSpeed(ReplaySpeed::fast(10.0));\n\n// Switch to max speed\nconnector-&gt;setSpeed(ReplaySpeed::max());\n</code></pre>"},{"location":"reference/api/replay/replay_connector/#seeking","title":"Seeking","text":"<pre><code>// Jump to specific timestamp\nconnector-&gt;seekTo(target_timestamp_ns);\n\n// Get current position\nint64_t pos = connector-&gt;currentPosition();\n</code></pre>"},{"location":"reference/api/replay/replay_connector/#notes","title":"Notes","text":"<ul> <li>At <code>max()</code> speed, events are emitted without any wall-clock delays.</li> <li>The replay thread runs independently; events are emitted via callbacks.</li> <li>Seeking creates a new reader instance positioned at the target timestamp.</li> <li><code>isFinished()</code> returns true only after all matching events are emitted.</li> <li>Deterministic: same input data always produces same event sequence.</li> </ul>"},{"location":"reference/api/replay/segment_ops/","title":"SegmentOps","text":"<p><code>SegmentOps</code> provides utilities for manipulating binary log segments: merging, splitting, exporting, filtering, and recompressing.</p> <pre><code>class SegmentOps\n{\npublic:\n  using ProgressCallback = std::function&lt;void(uint64_t current, uint64_t total)&gt;;\n\n  // Merge\n  static MergeResult merge(const std::vector&lt;std::filesystem::path&gt;&amp; input_paths,\n                           const MergeConfig&amp; config);\n  static MergeResult merge(const std::vector&lt;std::filesystem::path&gt;&amp; input_paths,\n                           const MergeConfig&amp; config, ProgressCallback progress);\n  static MergeResult mergeDirectory(const std::filesystem::path&amp; input_dir,\n                                    const MergeConfig&amp; config);\n\n  // Split\n  static SplitResult split(const std::filesystem::path&amp; input_path,\n                           const SplitConfig&amp; config);\n  static SplitResult split(const std::filesystem::path&amp; input_path,\n                           const SplitConfig&amp; config, ProgressCallback progress);\n  static SplitResult splitDirectory(const std::filesystem::path&amp; input_dir,\n                                    const SplitConfig&amp; config);\n\n  // Export\n  static ExportResult exportData(const std::filesystem::path&amp; input_path,\n                                 const ExportConfig&amp; config);\n  static ExportResult exportData(const std::filesystem::path&amp; input_path,\n                                 const ExportConfig&amp; config, ProgressCallback progress);\n  static ExportResult exportDirectory(const std::filesystem::path&amp; input_dir,\n                                      const ExportConfig&amp; config);\n\n  // Other operations\n  static bool recompress(const std::filesystem::path&amp; input_path,\n                         const std::filesystem::path&amp; output_path,\n                         CompressionType new_compression);\n\n  static uint64_t filter(const std::filesystem::path&amp; input_path,\n                         const std::filesystem::path&amp; output_path,\n                         const std::function&lt;bool(const ReplayEvent&amp;)&gt;&amp; predicate,\n                         const WriterConfig&amp; output_config);\n\n  static uint64_t extractSymbols(const std::filesystem::path&amp; input_path,\n                                 const std::filesystem::path&amp; output_path,\n                                 const std::set&lt;uint32_t&gt;&amp; symbols,\n                                 const WriterConfig&amp; config);\n\n  static uint64_t extractTimeRange(const std::filesystem::path&amp; input_path,\n                                   const std::filesystem::path&amp; output_path,\n                                   int64_t from_ns, int64_t to_ns,\n                                   const WriterConfig&amp; config);\n};\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#merge","title":"Merge","text":"<p>Combines multiple segments into a single file, optionally sorting by timestamp.</p> <pre><code>struct MergeConfig\n{\n  std::filesystem::path output_dir;\n  std::string output_name;\n  bool create_index{true};\n  uint16_t index_interval{kDefaultIndexInterval};  // 1000\n  CompressionType compression{CompressionType::None};\n  bool preserve_timestamps{true};\n  bool sort_by_timestamp{true};\n  uint64_t max_output_size{0};  // 0 = no limit\n};\n\nstruct MergeResult\n{\n  bool success{false};\n  std::filesystem::path output_path;\n  uint32_t segments_merged{0};\n  uint64_t events_written{0};\n  uint64_t bytes_written{0};\n  std::vector&lt;std::string&gt; errors;\n};\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#usage","title":"Usage","text":"<pre><code>MergeConfig config{\n    .output_dir = \"/data/merged\",\n    .output_name = \"combined\",\n    .compression = CompressionType::LZ4\n};\n\nauto result = SegmentOps::mergeDirectory(\"/data/segments\", config);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#split","title":"Split","text":"<p>Divides a segment into multiple files by time, event count, size, or symbol.</p> <pre><code>enum class SplitMode\n{\n  ByTime,        // Split at time boundaries\n  ByEventCount,  // Split after N events\n  BySize,        // Split at size threshold\n  BySymbol,      // One file per symbol\n};\n\nstruct SplitConfig\n{\n  std::filesystem::path output_dir;\n  SplitMode mode{SplitMode::ByTime};\n\n  int64_t time_interval_ns{3600LL * 1000000000LL};  // 1 hour\n  uint64_t events_per_file{1000000};\n  uint64_t bytes_per_file{256ull &lt;&lt; 20};            // 256 MB\n\n  bool create_index{true};\n  uint16_t index_interval{kDefaultIndexInterval};   // 1000\n  CompressionType compression{CompressionType::None};\n};\n\nstruct SplitResult\n{\n  bool success{false};\n  std::vector&lt;std::filesystem::path&gt; output_paths;\n  uint32_t segments_created{0};\n  uint64_t events_written{0};\n  std::vector&lt;std::string&gt; errors;\n};\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#usage_1","title":"Usage","text":"<pre><code>SplitConfig config{\n    .output_dir = \"/data/hourly\",\n    .mode = SplitMode::ByTime,\n    .time_interval_ns = 3600LL * 1000000000LL\n};\n\nauto result = SegmentOps::split(\"/data/large.floxlog\", config);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#export","title":"Export","text":"<p>Converts binary logs to human-readable formats.</p> <pre><code>enum class ExportFormat\n{\n  CSV,\n  JSON,\n  JSONLines,\n  Binary,  // Copy with optional filtering\n};\n\nstruct ExportConfig\n{\n  std::filesystem::path output_path;\n  ExportFormat format{ExportFormat::CSV};\n\n  // Filtering\n  std::optional&lt;int64_t&gt; from_ts;\n  std::optional&lt;int64_t&gt; to_ts;\n  std::set&lt;uint32_t&gt; symbols;\n  bool trades_only{false};\n  bool books_only{false};\n\n  // CSV options\n  char delimiter{','};\n  bool include_header{true};\n\n  // JSON options\n  bool pretty_print{false};\n  int indent{2};\n\n  // Binary format options (for ExportFormat::Binary)\n  CompressionType compression{CompressionType::None};\n  bool create_index{true};\n  uint16_t index_interval{kDefaultIndexInterval};  // 1000\n};\n\nstruct ExportResult\n{\n  bool success{false};\n  std::filesystem::path output_path;\n  uint64_t events_exported{0};\n  uint64_t bytes_written{0};\n  std::vector&lt;std::string&gt; errors;\n};\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#usage_2","title":"Usage","text":"<pre><code>ExportConfig config{\n    .output_path = \"/data/trades.csv\",\n    .format = ExportFormat::CSV,\n    .trades_only = true\n};\n\nauto result = SegmentOps::exportData(\"/data/market.floxlog\", config);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#other-operations","title":"Other Operations","text":""},{"location":"reference/api/replay/segment_ops/#recompress","title":"Recompress","text":"<p>Change compression of an existing segment:</p> <pre><code>SegmentOps::recompress(\"/data/uncompressed.floxlog\",\n                       \"/data/compressed.floxlog\",\n                       CompressionType::LZ4);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#filter","title":"Filter","text":"<p>Apply custom predicate to filter events:</p> <pre><code>WriterConfig writer_config{.output_dir = \"/data/filtered\"};\n\nauto count = SegmentOps::filter(\n    \"/data/input.floxlog\",\n    \"/data/filtered/trades.floxlog\",\n    [](const ReplayEvent&amp; e) { return e.type == EventType::Trade; },\n    writer_config);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#extract-symbols","title":"Extract Symbols","text":"<p>Extract events for specific symbol IDs:</p> <pre><code>WriterConfig writer_config{.output_dir = \"/data/extracted\"};\n\nauto count = SegmentOps::extractSymbols(\n    \"/data/input.floxlog\",\n    \"/data/extracted/btc_eth.floxlog\",\n    {1, 2},  // Symbol IDs\n    writer_config);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#extract-time-range","title":"Extract Time Range","text":"<p>Extract events within a time window:</p> <pre><code>WriterConfig writer_config{.output_dir = \"/data/extracted\"};\n\nauto count = SegmentOps::extractTimeRange(\n    \"/data/input.floxlog\",\n    \"/data/extracted/morning.floxlog\",\n    start_ns, end_ns,\n    writer_config);\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#convenience-functions","title":"Convenience Functions","text":"<pre><code>// Quick merge all segments in directory\nauto result = replay::quickMerge(\"/data/segments\", \"/data/merged\");\n\n// Quick export to CSV\nauto result = replay::quickExportCSV(\"/data/market.floxlog\", \"/data/market.csv\");\n\n// Split by hour\nauto result = replay::quickSplitByHour(\"/data/day.floxlog\", \"/data/hourly\");\n</code></pre>"},{"location":"reference/api/replay/segment_ops/#notes","title":"Notes","text":"<ul> <li>All operations support progress callbacks for monitoring long-running tasks.</li> <li>Merge with <code>sort_by_timestamp=true</code> performs k-way merge sort.</li> <li>Export formats support filtering by time, symbols, and event type.</li> <li>Compression can be changed during any operation.</li> <li><code>SplitMode::BySymbol</code> creates exactly one output file per unique symbol ID.</li> </ul>"},{"location":"reference/api/replay/validator/","title":"Validator","text":"<p><code>SegmentValidator</code> and <code>DatasetValidator</code> verify integrity of binary log files, detecting corruption, CRC mismatches, timestamp anomalies, and structural issues.</p> <pre><code>struct ValidatorConfig\n{\n  bool verify_crc{true};\n  bool verify_timestamps{true};\n  bool verify_index{true};\n  bool scan_all_events{true};\n  bool stop_on_first_error{false};\n  int64_t max_timestamp_jump_ns{3600LL * 1000000000LL};  // 1 hour\n};\n\nclass SegmentValidator\n{\npublic:\n  explicit SegmentValidator(ValidatorConfig config = {});\n\n  SegmentValidationResult validate(const std::filesystem::path&amp; segment_path);\n\n  using ProgressCallback = std::function&lt;void(uint64_t bytes_processed,\n                                               uint64_t total_bytes)&gt;;\n  SegmentValidationResult validate(const std::filesystem::path&amp; segment_path,\n                                   ProgressCallback progress);\n};\n\nclass DatasetValidator\n{\npublic:\n  explicit DatasetValidator(ValidatorConfig config = {});\n\n  DatasetValidationResult validate(const std::filesystem::path&amp; data_dir);\n\n  using ProgressCallback = std::function&lt;void(uint32_t segment_index,\n                                               uint32_t total_segments,\n                                               const std::filesystem::path&amp; current_file)&gt;;\n  DatasetValidationResult validate(const std::filesystem::path&amp; data_dir,\n                                   ProgressCallback progress);\n};\n</code></pre>"},{"location":"reference/api/replay/validator/#issue-types","title":"Issue Types","text":"Type Description <code>InvalidMagic</code> File magic number doesn't match <code>InvalidVersion</code> Unsupported format version <code>HeaderCorrupted</code> Segment header unreadable <code>FrameCrcMismatch</code> Frame CRC32 check failed <code>FrameSizeTooLarge</code> Frame size exceeds limits <code>FrameTypeUnknown</code> Unknown event type <code>FrameTruncated</code> Incomplete frame data <code>BlockMagicInvalid</code> Compressed block magic mismatch <code>BlockDecompressionFailed</code> LZ4 decompression error <code>IndexCrcMismatch</code> Index CRC32 check failed <code>IndexNotSorted</code> Index entries not in order <code>TimestampOutOfOrder</code> Events not chronologically sorted <code>TimestampJumpTooLarge</code> Suspicious timestamp gap <code>EventCountMismatch</code> Header count doesn't match actual <code>FileTruncated</code> File ends unexpectedly"},{"location":"reference/api/replay/validator/#severity-levels","title":"Severity Levels","text":"Level Meaning <code>Info</code> Informational, not a problem <code>Warning</code> Potential issue, data still readable <code>Error</code> Definite problem, some data may be lost <code>Critical</code> File unusable"},{"location":"reference/api/replay/validator/#validation-results","title":"Validation Results","text":""},{"location":"reference/api/replay/validator/#segmentvalidationresult","title":"SegmentValidationResult","text":"<pre><code>struct SegmentValidationResult\n{\n  std::filesystem::path path;\n  bool valid;\n  std::vector&lt;ValidationIssue&gt; issues;\n\n  bool header_valid;\n  uint32_t reported_event_count;\n  int64_t reported_first_ts;\n  int64_t reported_last_ts;\n  bool is_compressed;\n  CompressionType compression_type;\n\n  uint32_t actual_event_count;\n  int64_t actual_first_ts;\n  int64_t actual_last_ts;\n  uint64_t bytes_scanned;\n\n  bool has_index;\n  bool index_valid;\n  uint32_t index_entry_count;\n\n  uint32_t trades_found;\n  uint32_t book_updates_found;\n  uint32_t crc_errors;\n  uint32_t timestamp_anomalies;\n\n  bool hasErrors() const;\n  bool hasCritical() const;\n};\n</code></pre>"},{"location":"reference/api/replay/validator/#datasetvalidationresult","title":"DatasetValidationResult","text":"<pre><code>struct DatasetValidationResult\n{\n  std::filesystem::path data_dir;\n  bool valid;\n  std::vector&lt;SegmentValidationResult&gt; segments;\n\n  uint32_t total_segments;\n  uint32_t valid_segments;\n  uint32_t corrupted_segments;\n  uint64_t total_events;\n  uint64_t total_bytes;\n\n  int64_t first_timestamp;\n  int64_t last_timestamp;\n\n  uint32_t total_errors;\n  uint32_t total_warnings;\n};\n</code></pre>"},{"location":"reference/api/replay/validator/#usage","title":"Usage","text":""},{"location":"reference/api/replay/validator/#single-segment","title":"Single Segment","text":"<pre><code>SegmentValidator validator;\nauto result = validator.validate(\"/data/market.floxlog\");\n\nif (result.hasErrors()) {\n    for (const auto&amp; issue : result.issues) {\n        std::cerr &lt;&lt; \"Issue at offset \" &lt;&lt; issue.file_offset\n                  &lt;&lt; \": \" &lt;&lt; issue.message &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"reference/api/replay/validator/#entire-dataset","title":"Entire Dataset","text":"<pre><code>DatasetValidator validator;\nauto result = validator.validate(\"/data/market\");\n\nstd::cout &lt;&lt; \"Valid: \" &lt;&lt; result.valid_segments\n          &lt;&lt; \"/\" &lt;&lt; result.total_segments &lt;&lt; \" segments\\n\";\nstd::cout &lt;&lt; \"Events: \" &lt;&lt; result.total_events &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Errors: \" &lt;&lt; result.total_errors &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"reference/api/replay/validator/#with-progress","title":"With Progress","text":"<pre><code>DatasetValidator validator;\nauto result = validator.validate(\"/data/market\",\n    [](uint32_t current, uint32_t total, const auto&amp; path) {\n        std::cout &lt;&lt; \"Validating \" &lt;&lt; current &lt;&lt; \"/\" &lt;&lt; total\n                  &lt;&lt; \": \" &lt;&lt; path.filename() &lt;&lt; \"\\n\";\n    });\n</code></pre>"},{"location":"reference/api/replay/validator/#repair","title":"Repair","text":"<p><code>SegmentRepairer</code> can fix common issues in corrupted segments.</p> <pre><code>struct RepairConfig\n{\n  bool backup_before_repair{true};\n  std::string backup_suffix{\".backup\"};\n  bool fix_header_timestamps{true};\n  bool fix_event_count{true};\n  bool rebuild_index{true};\n  bool remove_corrupted_frames{false};\n  bool truncate_at_corruption{false};\n};\n\nclass SegmentRepairer\n{\npublic:\n  explicit SegmentRepairer(RepairConfig config = {});\n\n  RepairResult repair(const std::filesystem::path&amp; segment_path);\n  RepairResult repair(const std::filesystem::path&amp; segment_path,\n                      const SegmentValidationResult&amp; validation);\n};\n</code></pre>"},{"location":"reference/api/replay/validator/#repair-usage","title":"Repair Usage","text":"<pre><code>SegmentValidator validator;\nauto validation = validator.validate(\"/data/corrupted.floxlog\");\n\nif (validation.hasErrors()) {\n    SegmentRepairer repairer;\n    auto repair = repairer.repair(\"/data/corrupted.floxlog\", validation);\n\n    if (repair.success) {\n        for (const auto&amp; action : repair.actions_taken) {\n            std::cout &lt;&lt; \"Fixed: \" &lt;&lt; action &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>"},{"location":"reference/api/replay/validator/#convenience-functions","title":"Convenience Functions","text":"<pre><code>// Quick validation\nbool ok = replay::isValidSegment(\"/data/market.floxlog\");\nbool ok = replay::isValidDataset(\"/data/market\");\n</code></pre>"},{"location":"reference/api/replay/validator/#notes","title":"Notes","text":"<ul> <li>Validation scans entire file by default for complete integrity check.</li> <li>CRC verification can be disabled for faster validation.</li> <li>Timestamp jump detection catches clock sync issues in recorded data.</li> <li>Repair always creates backups unless explicitly disabled.</li> </ul>"},{"location":"reference/api/risk/abstract_risk_manager/","title":"IRiskManager","text":"<p><code>IRiskManager</code> defines an interface for validating whether a given order complies with system-defined risk constraints before it is submitted.</p> <pre><code>class IRiskManager : public ISubsystem {\npublic:\n  virtual ~IRiskManager() = default;\n  virtual bool allow(const Order&amp; order) const = 0;\n};\n</code></pre>"},{"location":"reference/api/risk/abstract_risk_manager/#purpose","title":"Purpose","text":"<ul> <li>Enforce pre-trade risk checks such as size limits, leverage rules, or order throttling.</li> </ul>"},{"location":"reference/api/risk/abstract_risk_manager/#responsibilities","title":"Responsibilities","text":"Method Description <code>allow()</code> Returns <code>true</code> if the order is permitted to proceed."},{"location":"reference/api/risk/abstract_risk_manager/#notes","title":"Notes","text":"<ul> <li>Called by strategy or execution layer before submitting an order.</li> <li>Stateless implementations may rely solely on order parameters; stateful variants may track recent flow.</li> <li>Integrated into the engine via <code>ISubsystem</code> for unified startup and reset behavior.</li> </ul>"},{"location":"reference/api/sink/abstract_storage_sink/","title":"IStorageSink","text":"<p><code>IStorageSink</code> defines the interface for persisting executed orders and related trading data. It abstracts away the underlying storage mechanism (e.g. MongoDB, binary log, cloud).</p> <pre><code>class IStorageSink : public ISubsystem {\npublic:\n  virtual ~IStorageSink() = default;\n  virtual void store(const Order&amp; order) = 0;\n};\n</code></pre>"},{"location":"reference/api/sink/abstract_storage_sink/#purpose","title":"Purpose","text":"<ul> <li>Persist orders for post-trade audit, reconciliation, analytics, or compliance.</li> </ul>"},{"location":"reference/api/sink/abstract_storage_sink/#responsibilities","title":"Responsibilities","text":"Method Description <code>store</code> Persists the provided <code>Order</code> object."},{"location":"reference/api/sink/abstract_storage_sink/#notes","title":"Notes","text":"<ul> <li>Called when orders are filled, canceled, or otherwise finalized.</li> <li>Backends may include MongoDB, file-based logs, or in-memory mirrors.</li> <li>Integrated via <code>ISubsystem</code> for lifecycle control and flush handling.</li> </ul>"},{"location":"reference/api/strategy/abstract_strategy/","title":"IStrategy","text":"<p><code>IStrategy</code> defines the interface for all trading strategies. It combines market data subscription and subsystem lifecycle control.</p> <pre><code>class IStrategy : public ISubsystem, public IMarketDataSubscriber {\npublic:\n  virtual ~IStrategy() = default;\n};\n</code></pre>"},{"location":"reference/api/strategy/abstract_strategy/#purpose","title":"Purpose","text":"<ul> <li>Define the contract for trading strategies that react to market data and emit order signals.</li> </ul>"},{"location":"reference/api/strategy/abstract_strategy/#composition","title":"Composition","text":"Inherits From Responsibilities <code>IMarketDataSubscriber</code> Receives <code>TradeEvent</code>, <code>BookUpdateEvent</code>, <code>BarEvent</code>. <code>ISubsystem</code> Enables coordinated <code>start()</code> / <code>stop()</code> during engine run."},{"location":"reference/api/strategy/abstract_strategy/#implementation","title":"Implementation","text":"<p>Use the <code>Strategy</code> base class which provides:</p> <ul> <li>Per-symbol context management (<code>SymbolContext</code>)</li> <li>Automatic order book maintenance</li> <li>Event routing to symbol-specific handlers</li> <li>Signal emission helpers</li> </ul> <p>See Strategy for the recommended implementation pattern.</p>"},{"location":"reference/api/strategy/abstract_strategy/#see-also","title":"See Also","text":"<ul> <li>Strategy - Unified strategy base class</li> <li>SymbolContext - Per-symbol state</li> </ul>"},{"location":"reference/api/strategy/signal_strategy/","title":"SignalStrategy","text":"<p><code>SignalStrategy</code> is a base class for strategies that emit trading signals instead of calling executor directly.</p>"},{"location":"reference/api/strategy/signal_strategy/#signal","title":"Signal","text":"<pre><code>enum class SignalType : uint8_t\n{\n  Market,\n  Limit,\n  Cancel,\n  CancelAll\n};\n\nstruct Signal\n{\n  SignalType type;\n  SymbolId symbol;\n  Side side;\n  Price price;\n  Quantity quantity;\n  OrderId orderId;\n\n  static Signal marketBuy(SymbolId sym, Quantity qty);\n  static Signal marketSell(SymbolId sym, Quantity qty);\n  static Signal limitBuy(SymbolId sym, Price px, Quantity qty);\n  static Signal limitSell(SymbolId sym, Price px, Quantity qty);\n  static Signal cancel(OrderId id);\n  static Signal cancelAll(SymbolId sym);\n};\n</code></pre>"},{"location":"reference/api/strategy/signal_strategy/#signalstrategy_1","title":"SignalStrategy","text":"<pre><code>class SignalStrategy : public IStrategy\n{\npublic:\n  void setSignalHandler(ISignalHandler* handler) noexcept;\n\nprotected:\n  void emit(const Signal&amp; signal);\n\n  void emitMarketBuy(SymbolId symbol, Quantity qty);\n  void emitMarketSell(SymbolId symbol, Quantity qty);\n  void emitLimitBuy(SymbolId symbol, Price price, Quantity qty);\n  void emitLimitSell(SymbolId symbol, Price price, Quantity qty);\n  void emitCancel(OrderId orderId);\n  void emitCancelAll(SymbolId symbol);\n};\n</code></pre>"},{"location":"reference/api/strategy/signal_strategy/#isignalhandler","title":"ISignalHandler","text":"<pre><code>class ISignalHandler\n{\npublic:\n  virtual void onSignal(const Signal&amp; signal) = 0;\n};\n</code></pre> <p><code>BacktestRunner</code> implements <code>ISignalHandler</code> and converts signals to orders.</p>"},{"location":"reference/api/strategy/signal_strategy/#usage","title":"Usage","text":"<pre><code>class MyStrategy : public SignalStrategy\n{\npublic:\n  SubscriberId id() const override { return 1; }\n  void start() override { _running = true; }\n  void stop() override { _running = false; }\n\n  void onTrade(const TradeEvent&amp; ev) override\n  {\n    if (!_running) return;\n\n    // Strategy logic\n    if (shouldBuy())\n      emitMarketBuy(ev.trade.symbol, Quantity::fromDouble(1.0));\n    else if (shouldSell())\n      emitMarketSell(ev.trade.symbol, Quantity::fromDouble(1.0));\n  }\n\nprivate:\n  bool _running{false};\n};\n\n// With BacktestRunner\nBacktestRunner runner(config);\nMyStrategy strategy;\nrunner.setSignalStrategy(&amp;strategy);  // auto-connects handler\n</code></pre>"},{"location":"reference/api/strategy/signal_strategy/#why-signals","title":"Why Signals","text":"Direct Executor Signals <code>_executor.submitOrder(order)</code> <code>emitMarketBuy(symbol, qty)</code> Strategy knows about executor Strategy decoupled from execution Harder to test Easy to mock signal handler No interception point Risk management can intercept"},{"location":"reference/api/strategy/strategy/","title":"Strategy","text":"<p><code>Strategy</code> is the unified base class for implementing trading strategies. It supports both single-symbol and multi-symbol strategies through a single, consistent API.</p> <pre><code>class Strategy : public IStrategy\n{\npublic:\n  // Multi-symbol constructor\n  Strategy(SubscriberId id, std::vector&lt;SymbolId&gt; symbols,\n           const SymbolRegistry&amp; registry);\n\n  // Single-symbol convenience constructor\n  Strategy(SubscriberId id, SymbolId symbol,\n           const SymbolRegistry&amp; registry);\n};\n</code></pre> <p>The strategy requires a <code>SymbolRegistry</code> reference to look up per-symbol metadata (tick size, instrument type, etc.).</p>"},{"location":"reference/api/strategy/strategy/#purpose","title":"Purpose","text":"<ul> <li>Provide a base class for all trading strategies</li> <li>Automatically manage per-symbol state (order books, positions, prices)</li> <li>Route market data events to symbol-specific handlers</li> <li>Emit trading signals to an executor</li> </ul>"},{"location":"reference/api/strategy/strategy/#per-symbol-context","title":"Per-Symbol Context","text":"<p>Each symbol has a <code>SymbolContext</code> that aggregates all relevant state:</p> <pre><code>struct SymbolContext\n{\n  NLevelOrderBook&lt;512&gt; book;     // Order book\n  Quantity position{};           // Net position\n  Price avgEntryPrice{};         // VWAP entry price\n  Price lastTradePrice{};        // Last trade price\n  int64_t lastUpdateNs{0};       // Last update timestamp\n  SymbolId symbolId{0};          // Symbol identifier\n\n  std::optional&lt;Price&gt; mid() const noexcept;      // Mid price\n  std::optional&lt;Price&gt; bookSpread() const noexcept; // Bid-ask spread\n  double unrealizedPnl(Price markPrice) const noexcept;\n  double unrealizedPnl() const noexcept;          // Uses mid()\n\n  bool isLong() const noexcept;\n  bool isShort() const noexcept;\n  bool isFlat() const noexcept;\n};\n</code></pre>"},{"location":"reference/api/strategy/strategy/#event-handlers","title":"Event Handlers","text":"<p>Override these methods to receive per-symbol market data:</p> <pre><code>protected:\n  // Called on trade events for subscribed symbols\n  virtual void onSymbolTrade(SymbolContext&amp; ctx, const TradeEvent&amp; ev) {}\n\n  // Called on book updates for subscribed symbols\n  virtual void onSymbolBook(SymbolContext&amp; ctx, const BookUpdateEvent&amp; ev) {}\n</code></pre> <p>The base class automatically: 1. Filters events by subscription 2. Updates <code>SymbolContext</code> (book, prices, timestamps) 3. Dispatches to the appropriate handler</p>"},{"location":"reference/api/strategy/strategy/#context-access","title":"Context Access","text":"<pre><code>protected:\n  // Access context by symbol ID\n  SymbolContext&amp; ctx(SymbolId sym) noexcept;\n  const SymbolContext&amp; ctx(SymbolId sym) const noexcept;\n\n  // Single-symbol convenience (returns first symbol's context)\n  SymbolContext&amp; ctx() noexcept;\n  const SymbolContext&amp; ctx() const noexcept;\n\n  // Get primary symbol ID (for single-symbol strategies)\n  SymbolId symbol() const noexcept;\n\n  // All subscribed symbols\n  const std::vector&lt;SymbolId&gt;&amp; symbols() const noexcept;\n\n  // Check if symbol is subscribed\n  bool isSubscribed(SymbolId sym) const noexcept;\n</code></pre>"},{"location":"reference/api/strategy/strategy/#signal-emission","title":"Signal Emission","text":"<p>All order methods return an <code>OrderId</code> for tracking:</p> <pre><code>protected:\n  void emit(const Signal&amp; signal);\n\n  // Market orders\n  OrderId emitMarketBuy(SymbolId symbol, Quantity qty);\n  OrderId emitMarketSell(SymbolId symbol, Quantity qty);\n\n  // Limit orders\n  OrderId emitLimitBuy(SymbolId symbol, Price price, Quantity qty);\n  OrderId emitLimitSell(SymbolId symbol, Price price, Quantity qty);\n  OrderId emitLimitBuy(SymbolId symbol, Price price, Quantity qty, TimeInForce tif);\n  OrderId emitLimitSell(SymbolId symbol, Price price, Quantity qty, TimeInForce tif);\n\n  // Order management\n  void emitCancel(OrderId orderId);\n  void emitCancelAll(SymbolId symbol);\n  void emitModify(OrderId orderId, Price newPrice, Quantity newQty);\n\n  // Stop orders\n  OrderId emitStopMarket(SymbolId symbol, Side side, Price triggerPrice, Quantity qty);\n  OrderId emitStopLimit(SymbolId symbol, Side side, Price triggerPrice, Price limitPrice, Quantity qty);\n\n  // Take profit orders\n  OrderId emitTakeProfitMarket(SymbolId symbol, Side side, Price triggerPrice, Quantity qty);\n  OrderId emitTakeProfitLimit(SymbolId symbol, Side side, Price triggerPrice, Price limitPrice, Quantity qty);\n\n  // Trailing stop\n  OrderId emitTrailingStop(SymbolId symbol, Side side, Price offset, Quantity qty);\n  OrderId emitTrailingStopPercent(SymbolId symbol, Side side, int32_t callbackBps, Quantity qty);\n\n  // Close position (reduce-only market order)\n  OrderId emitClosePosition(SymbolId symbol);\n</code></pre>"},{"location":"reference/api/strategy/strategy/#conditional-order-examples","title":"Conditional Order Examples","text":"<pre><code>// Stop-loss: sell when price drops to 95\nemitStopMarket(symbol, Side::SELL, Price::fromDouble(95.0), qty);\n\n// Take-profit: sell when price rises to 110\nemitTakeProfitMarket(symbol, Side::SELL, Price::fromDouble(110.0), qty);\n\n// Trailing stop: sell if price drops 2% from peak\nemitTrailingStopPercent(symbol, Side::SELL, 200, qty);  // 200 bps = 2%\n\n// Close entire position\nemitClosePosition(symbol);\n\n// IOC limit order\nemitLimitBuy(symbol, price, qty, TimeInForce::IOC);\n</code></pre>"},{"location":"reference/api/strategy/strategy/#order-and-position-tracking","title":"Order and Position Tracking","text":"<p>Query order status and positions (requires <code>setOrderTracker</code> / <code>setPositionManager</code>):</p> <pre><code>protected:\n  // Position queries\n  Quantity position(SymbolId sym) const;  // Net position for symbol\n  Quantity position() const;              // Primary symbol position\n\n  // Order status queries\n  std::optional&lt;OrderEventStatus&gt; getOrderStatus(OrderId orderId) const;\n  std::optional&lt;OrderState&gt; getOrder(OrderId orderId) const;\n</code></pre> <p>Connect trackers:</p> <pre><code>strategy.setOrderTracker(&amp;orderTracker);\nstrategy.setPositionManager(&amp;positionTracker);\n</code></pre>"},{"location":"reference/api/strategy/strategy/#cross-symbol-helpers","title":"Cross-Symbol Helpers","text":"<p>Free functions in <code>symbol_context.h</code> for multi-symbol strategies:</p> <pre><code>// Price spread between two symbols\nstd::optional&lt;Price&gt; spread(const SymbolContext&amp; a, const SymbolContext&amp; b);\n\n// Price ratio between two symbols\nstd::optional&lt;double&gt; ratio(const SymbolContext&amp; a, const SymbolContext&amp; b);\n</code></pre>"},{"location":"reference/api/strategy/strategy/#examples","title":"Examples","text":""},{"location":"reference/api/strategy/strategy/#single-symbol-strategy","title":"Single-Symbol Strategy","text":"<pre><code>class MomentumStrategy : public Strategy\n{\npublic:\n  MomentumStrategy(SymbolId sym, const SymbolRegistry&amp; registry)\n    : Strategy(1, sym, registry) {}\n\n  void start() override { _running = true; }\n  void stop() override { _running = false; }\n\nprotected:\n  void onSymbolTrade(SymbolContext&amp; c, const TradeEvent&amp; ev) override\n  {\n    if (!_running) return;\n\n    // Access order book\n    auto bid = c.book.bestBid();\n    auto ask = c.book.bestAsk();\n    if (!bid || !ask) return;\n\n    // Check position via tracker\n    if (position().isZero() &amp;&amp; shouldBuy(ev.trade.price))\n    {\n      // Returns OrderId for tracking\n      OrderId id = emitMarketBuy(c.symbolId, Quantity::fromDouble(1.0));\n      _pendingOrder = id;\n    }\n\n    // Check order status\n    if (_pendingOrder)\n    {\n      auto status = getOrderStatus(*_pendingOrder);\n      if (status &amp;&amp; *status == OrderEventStatus::FILLED)\n      {\n        _pendingOrder = std::nullopt;\n      }\n    }\n  }\n\nprivate:\n  bool _running{false};\n  std::optional&lt;OrderId&gt; _pendingOrder;\n};\n</code></pre>"},{"location":"reference/api/strategy/strategy/#multi-symbol-pairs-strategy","title":"Multi-Symbol Pairs Strategy","text":"<pre><code>class PairsStrategy : public Strategy\n{\npublic:\n  PairsStrategy(SymbolId leg1, SymbolId leg2, const SymbolRegistry&amp; registry)\n    : Strategy(1, {leg1, leg2}, registry), _leg1(leg1), _leg2(leg2) {}\n\n  void start() override {}\n  void stop() override {}\n\nprotected:\n  void onSymbolBook(SymbolContext&amp; c, const BookUpdateEvent&amp; ev) override\n  {\n    // Check spread between legs\n    auto spreadOpt = spread(ctx(_leg1), ctx(_leg2));\n    if (!spreadOpt) return;\n\n    double z = zscore(*spreadOpt);\n\n    if (ctx(_leg1).isFlat() &amp;&amp; std::abs(z) &gt; 2.0)\n    {\n      // Open spread position\n      if (z &gt; 0)\n      {\n        emitMarketSell(_leg1, _size);\n        emitMarketBuy(_leg2, _size);\n      }\n      else\n      {\n        emitMarketBuy(_leg1, _size);\n        emitMarketSell(_leg2, _size);\n      }\n    }\n  }\n\nprivate:\n  SymbolId _leg1, _leg2;\n  Quantity _size{Quantity::fromDouble(1.0)};\n};\n</code></pre>"},{"location":"reference/api/strategy/strategy/#integration","title":"Integration","text":"<p>Connect strategy to backtest or live execution:</p> <pre><code>// Create registry\nSymbolRegistry registry;\nSymbolInfo info;\ninfo.exchange = \"BINANCE\";\ninfo.symbol = \"BTCUSDT\";\ninfo.tickSize = Price::fromDouble(0.01);\nSymbolId symbolId = registry.registerSymbol(info);\n\n// Backtest\nBacktestRunner runner(config);\nMyStrategy strategy(symbolId, registry);\nrunner.setStrategy(&amp;strategy);\nauto result = runner.run(*reader);\n\n// Live (with signal handler)\nstrategy.setSignalHandler(&amp;executor);\nengine.addSubscriber(&amp;strategy);\nengine.start();\n</code></pre>"},{"location":"reference/api/strategy/strategy/#see-also","title":"See Also","text":"<ul> <li>PositionTracker - Track realized PnL with FIFO/LIFO/AVERAGE</li> <li>SymbolContext - Per-symbol state details</li> <li>BacktestRunner - Backtesting framework</li> </ul>"},{"location":"reference/api/strategy/symbol_context/","title":"SymbolContext","text":"<p><code>SymbolContext</code> aggregates all per-symbol state needed by trading strategies: order book, position, prices, and timestamps.</p> <pre><code>struct SymbolContext\n{\n  static constexpr size_t kDefaultBookLevels = 512;\n\n  NLevelOrderBook&lt;kDefaultBookLevels&gt; book;\n  Quantity position{};\n  Price avgEntryPrice{};\n  Price lastTradePrice{};\n  int64_t lastUpdateNs{0};\n  SymbolId symbolId{0};\n};\n</code></pre>"},{"location":"reference/api/strategy/symbol_context/#purpose","title":"Purpose","text":"<ul> <li>Consolidate all per-symbol data in a cache-friendly structure</li> <li>Provide computed properties (mid price, spread, PnL)</li> <li>Support multi-symbol strategies with O(1) state access</li> </ul>"},{"location":"reference/api/strategy/symbol_context/#fields","title":"Fields","text":"Field Type Description <code>book</code> <code>NLevelOrderBook&lt;512&gt;</code> Order book with 512 price levels <code>position</code> <code>Quantity</code> Net position (positive=long, negative=short) <code>avgEntryPrice</code> <code>Price</code> Volume-weighted average entry price <code>lastTradePrice</code> <code>Price</code> Most recent trade price <code>lastUpdateNs</code> <code>int64_t</code> Last update timestamp (nanoseconds) <code>symbolId</code> <code>SymbolId</code> Symbol identifier"},{"location":"reference/api/strategy/symbol_context/#computed-properties","title":"Computed Properties","text":""},{"location":"reference/api/strategy/symbol_context/#mid-price","title":"Mid Price","text":"<pre><code>std::optional&lt;Price&gt; mid() const noexcept;\n</code></pre> <p>Returns midpoint between best bid and ask. Returns <code>nullopt</code> if either side is missing.</p>"},{"location":"reference/api/strategy/symbol_context/#book-spread","title":"Book Spread","text":"<pre><code>std::optional&lt;Price&gt; bookSpread() const noexcept;\n</code></pre> <p>Returns bid-ask spread. Returns <code>nullopt</code> if book is one-sided.</p>"},{"location":"reference/api/strategy/symbol_context/#unrealized-pnl","title":"Unrealized PnL","text":"<pre><code>double unrealizedPnl(Price markPrice) const noexcept;\ndouble unrealizedPnl() const noexcept;  // Uses mid() as mark\n</code></pre> <p>Calculates unrealized PnL based on current position and mark price.</p>"},{"location":"reference/api/strategy/symbol_context/#position-state","title":"Position State","text":"<pre><code>bool isLong() const noexcept;   // position &gt; 0\nbool isShort() const noexcept;  // position &lt; 0\nbool isFlat() const noexcept;   // position == 0\n</code></pre>"},{"location":"reference/api/strategy/symbol_context/#reset","title":"Reset","text":"<pre><code>void reset() noexcept;\n</code></pre> <p>Clears all state: book, position, prices, timestamps.</p>"},{"location":"reference/api/strategy/symbol_context/#cross-symbol-helpers","title":"Cross-Symbol Helpers","text":"<p>Free functions for multi-symbol analysis:</p> <pre><code>// Price spread: midA - midB\nstd::optional&lt;Price&gt; spread(const SymbolContext&amp; a, const SymbolContext&amp; b);\n\n// Price ratio: midA / midB\nstd::optional&lt;double&gt; ratio(const SymbolContext&amp; a, const SymbolContext&amp; b);\n</code></pre>"},{"location":"reference/api/strategy/symbol_context/#example","title":"Example","text":"<pre><code>class SpreadStrategy : public Strategy\n{\npublic:\n  SpreadStrategy(SymbolId front, SymbolId back, const SymbolRegistry&amp; registry)\n    : Strategy(1, {front, back}, registry), _front(front), _back(back) {}\n\nprotected:\n  void onSymbolBook(SymbolContext&amp; c, const BookUpdateEvent&amp; ev) override\n  {\n    // Get spread between front and back month\n    auto spreadOpt = spread(ctx(_front), ctx(_back));\n    if (!spreadOpt) return;\n\n    double spreadValue = spreadOpt-&gt;toDouble();\n\n    // Check unrealized PnL\n    double pnl = ctx(_front).unrealizedPnl() + ctx(_back).unrealizedPnl();\n\n    // Check position state\n    if (ctx(_front).isLong() &amp;&amp; pnl &gt; _target)\n    {\n      closePosition();\n    }\n  }\n\nprivate:\n  SymbolId _front, _back;\n  double _target{100.0};\n};\n</code></pre>"},{"location":"reference/api/strategy/symbol_context/#memory-layout","title":"Memory Layout","text":"<p><code>SymbolContext</code> is designed for cache efficiency:</p> <ul> <li>~4KB per symbol (512-level book dominates)</li> <li>All fields in single contiguous struct</li> <li>Access via <code>SymbolStateMap</code> provides O(1) lookup</li> </ul>"},{"location":"reference/api/strategy/symbol_context/#see-also","title":"See Also","text":"<ul> <li>Strategy - Strategy base class</li> <li>NLevelOrderBook - Order book implementation</li> <li>SymbolStateMap - O(1) container for per-symbol state</li> </ul>"},{"location":"reference/api/strategy/symbol_state_map/","title":"SymbolStateMap","text":"<p><code>SymbolStateMap</code> is a high-performance O(1) container for per-symbol state, optimized for trading systems.</p> <pre><code>template &lt;typename State, size_t MaxSymbols = 256&gt;\nclass SymbolStateMap;\n</code></pre>"},{"location":"reference/api/strategy/symbol_state_map/#purpose","title":"Purpose","text":"<ul> <li>Provide O(1) access to per-symbol state</li> <li>Optimize for the common case (symbol IDs &lt; 256)</li> <li>Handle overflow gracefully for large symbol counts</li> <li>Cache-line aligned for optimal memory access</li> </ul>"},{"location":"reference/api/strategy/symbol_state_map/#design","title":"Design","text":"<p>The container uses a two-tier approach:</p> <ol> <li>Flat array (symbols 0-255): Direct O(1) access, cache-line aligned</li> <li>Overflow vector (symbols &gt;= 256): Linear search, rare case</li> </ol> <pre><code>alignas(64) std::array&lt;State, MaxSymbols&gt; _flat{};\nstd::array&lt;bool, MaxSymbols&gt; _initialized{};\nstd::vector&lt;std::pair&lt;SymbolId, State&gt;&gt; _overflow;\n</code></pre>"},{"location":"reference/api/strategy/symbol_state_map/#api","title":"API","text":""},{"location":"reference/api/strategy/symbol_state_map/#access","title":"Access","text":"<pre><code>// Get or create state for symbol (O(1) for sym &lt; 256)\nState&amp; operator[](SymbolId symbol) noexcept;\nconst State&amp; operator[](SymbolId symbol) const noexcept;\n\n// Get pointer if exists, nullptr otherwise\nState* tryGet(SymbolId symbol) noexcept;\nconst State* tryGet(SymbolId symbol) const noexcept;\n\n// Check if symbol has state\nbool contains(SymbolId symbol) const noexcept;\n</code></pre>"},{"location":"reference/api/strategy/symbol_state_map/#iteration","title":"Iteration","text":"<pre><code>// Iterate over all initialized symbols\ntemplate &lt;typename Func&gt;\nvoid forEach(Func&amp;&amp; fn);\n\n// Func signature: void(SymbolId, State&amp;)\n</code></pre>"},{"location":"reference/api/strategy/symbol_state_map/#utilities","title":"Utilities","text":"<pre><code>void clear() noexcept;          // Clear all state\nsize_t size() const noexcept;   // Count of initialized symbols\n</code></pre>"},{"location":"reference/api/strategy/symbol_state_map/#example","title":"Example","text":"<pre><code>// Per-symbol position tracking\nstruct PositionState\n{\n  double quantity{0.0};\n  double avgPrice{0.0};\n  double realizedPnl{0.0};\n};\n\nSymbolStateMap&lt;PositionState&gt; positions;\n\n// Update position\npositions[btcSymbol].quantity += 10.0;\npositions[btcSymbol].avgPrice = 50000.0;\n\n// Check if tracked\nif (positions.contains(ethSymbol))\n{\n  auto&amp; state = positions[ethSymbol];\n  // ...\n}\n\n// Iterate all positions\npositions.forEach([](SymbolId sym, PositionState&amp; pos) {\n  std::cout &lt;&lt; \"Symbol \" &lt;&lt; sym &lt;&lt; \": \" &lt;&lt; pos.quantity &lt;&lt; \"\\n\";\n});\n\n// Accumulate total PnL\ndouble totalPnl = 0.0;\npositions.forEach([&amp;totalPnl](SymbolId, const PositionState&amp; pos) {\n  totalPnl += pos.realizedPnl;\n});\n</code></pre>"},{"location":"reference/api/strategy/symbol_state_map/#performance","title":"Performance","text":"Operation Complexity (sym &lt; 256) Complexity (sym &gt;= 256) <code>operator[]</code> O(1) O(n) overflow search <code>contains</code> O(1) O(n) overflow search <code>tryGet</code> O(1) O(n) overflow search <code>forEach</code> O(MaxSymbols) O(MaxSymbols + n) <p>For most trading systems with &lt; 256 symbols, all operations are O(1).</p>"},{"location":"reference/api/strategy/symbol_state_map/#memory","title":"Memory","text":"<ul> <li>Flat array: <code>MaxSymbols * sizeof(State)</code> bytes (64-byte aligned)</li> <li>Initialized flags: <code>MaxSymbols</code> bytes</li> <li>Overflow: dynamic allocation only when needed</li> </ul> <p>Default with <code>SymbolContext</code>: ~1MB for 256 symbols (4KB per symbol due to order book).</p>"},{"location":"reference/api/strategy/symbol_state_map/#template-parameters","title":"Template Parameters","text":"<pre><code>template &lt;typename State, size_t MaxSymbols = 256&gt;\n</code></pre> Parameter Default Description <code>State</code> - Per-symbol state type <code>MaxSymbols</code> 256 Flat array size, symbols &gt;= this go to overflow"},{"location":"reference/api/strategy/symbol_state_map/#see-also","title":"See Also","text":"<ul> <li>SymbolContext - Per-symbol state struct</li> <li>Strategy - Uses SymbolStateMap internally</li> </ul>"},{"location":"reference/api/util/rate_limiter/","title":"RateLimiter","text":"<p>Thread-safe token bucket rate limiter for controlling request/operation frequency.</p>"},{"location":"reference/api/util/rate_limiter/#quick-start","title":"Quick Start","text":"<pre><code>#include \"flox/util/rate_limiter.h\"\n\n// 10 requests per second\nRateLimiter limiter({.capacity = 10, .refillRate = 10});\n\nif (limiter.tryAcquire()) {\n  sendRequest();\n} else {\n  // Rate limit exceeded\n}\n</code></pre>"},{"location":"reference/api/util/rate_limiter/#use-cases","title":"Use Cases","text":"<ul> <li>API rate limiting \u2014 prevent exchange bans</li> <li>Log throttling \u2014 avoid log spam</li> <li>Alert throttling \u2014 limit notification frequency</li> <li>Order frequency \u2014 cap orders per second</li> </ul>"},{"location":"reference/api/util/rate_limiter/#api","title":"API","text":""},{"location":"reference/api/util/rate_limiter/#constructor","title":"Constructor","text":"<pre><code>RateLimiter(Config config);\n\nstruct Config {\n  uint32_t capacity;    // Maximum tokens in bucket\n  uint32_t refillRate;  // Tokens added per second\n};\n</code></pre>"},{"location":"reference/api/util/rate_limiter/#methods","title":"Methods","text":"Method Description <code>tryAcquire(n)</code> Try to consume n tokens. Returns true if successful. <code>timeUntilAvailable(n)</code> Duration until n tokens will be available. <code>available()</code> Current token count. <code>reset()</code> Reset to full capacity. <code>capacity()</code> Maximum tokens. <code>refillRate()</code> Tokens per second."},{"location":"reference/api/util/rate_limiter/#examples","title":"Examples","text":""},{"location":"reference/api/util/rate_limiter/#exchange-connector","title":"Exchange Connector","text":"<pre><code>class BybitOrderExecutor : public IOrderExecutor {\npublic:\n  BybitOrderExecutor()\n    : _orderLimiter({.capacity = 10, .refillRate = 10})  // 10 orders/sec\n  {}\n\n  void submit(const Order&amp; order) override {\n    if (!_orderLimiter.tryAcquire()) {\n      reject(order, \"rate limit exceeded\");\n      return;\n    }\n    sendToExchange(order);\n  }\n\nprivate:\n  RateLimiter _orderLimiter;\n};\n</code></pre>"},{"location":"reference/api/util/rate_limiter/#wait-for-availability","title":"Wait for Availability","text":"<pre><code>if (!limiter.tryAcquire()) {\n  auto wait = limiter.timeUntilAvailable();\n  std::this_thread::sleep_for(wait);\n  limiter.tryAcquire();  // Should succeed now\n}\n</code></pre>"},{"location":"reference/api/util/rate_limiter/#multiple-token-operations","title":"Multiple Token Operations","text":"<pre><code>// Batch request costs 5 tokens\nif (limiter.tryAcquire(5)) {\n  sendBatchRequest();\n}\n</code></pre>"},{"location":"reference/api/util/rate_limiter/#log-throttling","title":"Log Throttling","text":"<pre><code>class ThrottledLogger {\npublic:\n  ThrottledLogger() : _limiter({.capacity = 10, .refillRate = 1}) {}  // 1/sec burst 10\n\n  void warn(const std::string&amp; msg) {\n    if (_limiter.tryAcquire()) {\n      std::cerr &lt;&lt; \"[WARN] \" &lt;&lt; msg &lt;&lt; \"\\n\";\n    }\n  }\n\nprivate:\n  RateLimiter _limiter;\n};\n</code></pre>"},{"location":"reference/api/util/rate_limiter/#algorithm","title":"Algorithm","text":"<p>Token bucket with continuous refill:</p> <ol> <li>Tokens accumulate at <code>refillRate</code> per second</li> <li>Bucket holds maximum <code>capacity</code> tokens</li> <li><code>tryAcquire(n)</code> consumes n tokens if available</li> <li>Lock-free implementation using atomics</li> </ol>"},{"location":"reference/api/util/rate_limiter/#thread-safety","title":"Thread Safety","text":"<p>All methods are thread-safe and lock-free. Safe for concurrent use from multiple threads.</p>"},{"location":"reference/api/util/rate_limiter/#see-also","title":"See Also","text":"<ul> <li>IKillSwitch \u2014 emergency shutdown</li> </ul>"},{"location":"reference/api/util/base/decimal/","title":"Decimal","text":"<p><code>Decimal</code> is a fixed-point arithmetic wrapper designed for performance-critical environments such as HFT. It provides type-safe arithmetic on scaled integers with configurable tick precision and compile-time guarantees.</p> <pre><code>template &lt;typename Tag, int Scale, int64_t TickSize = 1&gt;\nclass Decimal {\n  // ...\n};\n</code></pre>"},{"location":"reference/api/util/base/decimal/#purpose","title":"Purpose","text":"<ul> <li>Avoid floating-point rounding errors by using integer math with fixed scaling.</li> <li>Provide clean, zero-cost abstractions for price/quantity units with compile-time type safety.</li> </ul>"},{"location":"reference/api/util/base/decimal/#parameters","title":"Parameters","text":"Template Param Description <code>Tag</code> Phantom type used to disambiguate unit domains (e.g. <code>Price</code>, <code>Qty</code>). <code>Scale</code> Number of sub-units per whole unit (e.g. 1000 = 3 decimal places). <code>TickSize</code> Granularity for tick-based rounding."},{"location":"reference/api/util/base/decimal/#key-features","title":"Key Features","text":"Function Description <code>fromDouble(double)</code> Converts a floating-point value to scaled integer with rounding. <code>toDouble()</code> Converts internal <code>_raw</code> value to <code>double</code> for logging/debugging. <code>raw()</code> Returns raw internal <code>int64_t</code> value. <code>roundToTick()</code> Rounds to the nearest multiple of <code>TickSize</code>. <code>isZero()</code> True if <code>_raw == 0</code>. Arithmetic / Comparison Ops Full suite of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, etc. on same-type values."},{"location":"reference/api/util/base/decimal/#notes","title":"Notes","text":"<ul> <li>Scale is enforced at compile time \u2014 <code>Decimal&lt;PriceTag, 1000&gt;</code> is a distinct type from <code>Decimal&lt;QuantityTag, 1000&gt;</code>.</li> <li>No virtual overhead, heap allocation, or runtime type checks.</li> <li>Supports tick-based alignment and arithmetic directly without conversions.</li> <li>Used throughout FLOX for price, quantity, and other numeric domains.</li> </ul>"},{"location":"reference/api/util/concurrency/spsc_queue/","title":"SPSCQueue","text":"<p><code>SPSCQueue</code> is a lock-free, bounded-size single-producer/single-consumer queue optimized for HFT workloads. It supports in-place construction, zero allocations, and cache-line isolation.</p> <pre><code>template &lt;typename T, size_t Capacity&gt;\nclass SPSCQueue;\n</code></pre>"},{"location":"reference/api/util/concurrency/spsc_queue/#purpose","title":"Purpose","text":"<ul> <li>Provide low-latency, zero-contention messaging between one writer and one reader.</li> </ul>"},{"location":"reference/api/util/concurrency/spsc_queue/#requirements","title":"Requirements","text":"<ul> <li><code>Capacity</code> must be a power of two.</li> <li><code>T</code> must be nothrow-destructible.</li> <li>Only one producer and one consumer may operate concurrently.</li> </ul>"},{"location":"reference/api/util/concurrency/spsc_queue/#key-features","title":"Key Features","text":"Method Description <code>push(const T&amp;)</code> Enqueues a copy of an object. <code>emplace(T&amp;&amp;)</code> Enqueues an rvalue object (move). <code>try_emplace(...)</code> Constructs object in-place with arguments. <code>pop(T&amp;)</code> Pops and moves the front element into <code>out</code>. <code>try_pop()</code> Returns a pointer to the front element, or <code>nullptr</code> if empty. <code>try_pop_ref()</code> Returns <code>std::optional&lt;std::reference_wrapper&lt;T&gt;&gt;</code> for inline access. <code>empty()</code> / <code>full()</code> Check queue state. <code>clear()</code> Destroys and drains all pending elements. <code>size()</code> Returns current number of elements."},{"location":"reference/api/util/concurrency/spsc_queue/#internal-design","title":"Internal Design","text":"<ul> <li>Ring buffer implementation with <code>Capacity</code> entries, using modulo <code>MASK = Capacity - 1</code>.</li> <li><code>_head</code> and <code>_tail</code> are <code>std::atomic&lt;size_t&gt;</code> and are false-shared-safe via <code>alignas(64)</code>.</li> <li>Uses placement <code>new</code> for in-place construction, avoids heap entirely.</li> </ul>"},{"location":"reference/api/util/concurrency/spsc_queue/#notes","title":"Notes","text":"<ul> <li>Optimized for predictable, sub-microsecond latency in tight loops.</li> <li>No memory reclamation or ABA protection \u2014 not suitable for multi-producer/multi-consumer setups.</li> <li>All methods use <code>memory_order_acquire/release</code> to ensure visibility across cores.</li> <li>Destruction ensures safe draining of remaining elements via <code>~T()</code> call.</li> </ul>"},{"location":"reference/api/util/eventing/event_bus/","title":"EventBus","text":"<p><code>EventBus</code> is a high-performance Disruptor-style ring buffer for broadcasting typed events to multiple consumers. It uses lock-free sequencing with busy-spin waiting for minimal latency.</p> <pre><code>template &lt;typename Event,\n          size_t CapacityPow2 = config::DEFAULT_EVENTBUS_CAPACITY,\n          size_t MaxConsumers = config::DEFAULT_EVENTBUS_MAX_CONSUMERS&gt;\nclass EventBus : public ISubsystem;\n</code></pre>"},{"location":"reference/api/util/eventing/event_bus/#purpose","title":"Purpose","text":"<ul> <li>Deliver high-frequency events (market data, orders, etc.) to multiple subscribers with minimal latency and zero allocations on the hot path.</li> <li>Support CPU affinity and real-time thread priority for latency-critical components.</li> <li>Provide backpressure handling via timeout-based publishing.</li> </ul>"},{"location":"reference/api/util/eventing/event_bus/#key-methods","title":"Key Methods","text":"Method Description <code>subscribe(listener, required)</code> Registers a consumer. <code>required=true</code> (default) gates publishing. Returns <code>bool</code>. <code>publish(event)</code> Publishes event to ring buffer, returns sequence number (-1 if stopped). <code>tryPublish(event, timeout)</code> Publishes with timeout. Returns <code>{PublishResult, seq}</code>. <code>start()</code> / <code>stop()</code> Starts or stops all consumer threads. <code>waitConsumed(seq)</code> Blocks until all required consumers have processed up to <code>seq</code>. <code>flush()</code> Waits until all published events are consumed by required consumers. <code>consumerCount()</code> Returns number of registered consumers. <code>enableDrainOnStop()</code> Ensures remaining events are dispatched before shutdown."},{"location":"reference/api/util/eventing/event_bus/#publishresult","title":"PublishResult","text":"<pre><code>enum class PublishResult\n{\n  SUCCESS,   // Event published successfully\n  TIMEOUT,   // Buffer full, timeout expired\n  STOPPED    // Bus not running\n};\n</code></pre>"},{"location":"reference/api/util/eventing/event_bus/#backpressure-handling","title":"Backpressure Handling","text":"<p>When the ring buffer is full (consumers too slow), <code>publish()</code> blocks until space is available. Use <code>tryPublish()</code> with a timeout to handle backpressure:</p> <pre><code>auto [result, seq] = bus.tryPublish(event, std::chrono::microseconds{1000});\nif (result == Bus::PublishResult::TIMEOUT) {\n  // Handle backpressure: drop event, log warning, etc.\n}\n</code></pre>"},{"location":"reference/api/util/eventing/event_bus/#cpu-affinity-when-flox_cpu_affinity_enabled","title":"CPU Affinity (when <code>FLOX_CPU_AFFINITY_ENABLED</code>)","text":"<pre><code>enum class ComponentType\n{\n  MARKET_DATA,\n  EXECUTION,\n  STRATEGY,\n  RISK,\n  GENERAL\n};\n\nstruct AffinityConfig\n{\n  ComponentType componentType = ComponentType::GENERAL;\n  bool enableRealTimePriority = true;\n  int realTimePriority = config::DEFAULT_REALTIME_PRIORITY;\n  bool enableNumaAwareness = true;\n  bool preferIsolatedCores = true;\n};\n</code></pre> Method Description <code>setAffinityConfig(cfg)</code> Configure CPU affinity and RT priority. <code>setCoreAssignment(assign)</code> Manually set core assignment. <code>setupOptimalConfiguration()</code> Auto-configure for component type. <code>verifyIsolatedCoreConfig()</code> Verify isolated core setup. <p>Consumer threads are distributed across available cores using round-robin assignment.</p>"},{"location":"reference/api/util/eventing/event_bus/#design-highlights","title":"Design Highlights","text":"<ul> <li>Disruptor Pattern: Single producer, multiple consumers with sequence-based coordination.</li> <li>Ring Buffer: Fixed-size power-of-2 capacity with wrap-around.</li> <li>Busy-Spin Waiting: Uses <code>BusyBackoff</code> for low-latency polling.</li> <li>Gating Sequence: Publishers wait for slowest required consumer before overwriting.</li> <li>Per-Consumer Threads: Each consumer runs in dedicated <code>std::jthread</code>.</li> <li>Zero Allocations: Events stored directly in pre-allocated ring buffer slots.</li> <li>Tick Sequencing: <code>tickSequence</code> field is automatically set if present on event.</li> <li>In-Place Construction: Events constructed via placement new, destructed on reclaim.</li> <li>Thread-Safe Subscribe: <code>subscribe()</code> returns false if called after <code>start()</code>.</li> <li>Overflow Protection: Sequence counter overflow is detected and handled.</li> </ul>"},{"location":"reference/api/util/eventing/event_bus/#internal-types","title":"Internal Types","text":"Name Description <code>ConsumerSlot</code> Per-consumer state: listener, sequence, thread, required, coreIndex. <code>Listener</code> Inferred from <code>Event::Listener</code> via <code>ListenerType</code> trait. <code>PublishResult</code> Enum for publish outcome (SUCCESS, TIMEOUT, STOPPED)."},{"location":"reference/api/util/eventing/event_bus/#template-parameters","title":"Template Parameters","text":"Parameter Default Description <code>Event</code> - Event type to broadcast. <code>CapacityPow2</code> <code>config::DEFAULT_EVENTBUS_CAPACITY</code> (4096) Ring buffer size (power of 2). <code>MaxConsumers</code> <code>config::DEFAULT_EVENTBUS_MAX_CONSUMERS</code> (128) Maximum consumer count."},{"location":"reference/api/util/eventing/event_bus/#example-usage","title":"Example Usage","text":"<pre><code>using BookBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;&gt;;\n\nBookBus bus;\n\n// subscribe() returns bool - check for success\nif (!bus.subscribe(&amp;bookHandler)) {\n  // Handle error: null listener, bus running, or at capacity\n}\n\n#if FLOX_CPU_AFFINITY_ENABLED\nbus.setupOptimalConfiguration(BookBus::ComponentType::MARKET_DATA);\n#endif\n\nbus.start();\n\n// Standard publish (blocks on backpressure)\nauto seq = bus.publish(std::move(bookUpdateHandle));\n\n// Publish with timeout (non-blocking backpressure handling)\nauto [result, seq2] = bus.tryPublish(event, std::chrono::microseconds{500});\nif (result == BookBus::PublishResult::TIMEOUT) {\n  LOG_WARN(\"Backpressure detected, event dropped\");\n}\n\nbus.flush();\nbus.stop();\n</code></pre>"},{"location":"reference/api/util/eventing/event_bus/#required-vs-optional-consumers","title":"Required vs Optional Consumers","text":"<p>Consumers can be registered as required (default) or optional:</p> <pre><code>bus.subscribe(&amp;criticalHandler, true);   // required (default)\nbus.subscribe(&amp;loggingHandler, false);   // optional\n</code></pre>"},{"location":"reference/api/util/eventing/event_bus/#behavior-differences","title":"Behavior differences","text":"Aspect Required Consumer Optional Consumer Gating Blocks <code>waitConsumed()</code> and <code>flush()</code> Does not block these methods Backpressure Can cause publisher to wait Never causes backpressure Event delivery Always receives all events Always receives all events Reclaim Events reclaimed after processing Events reclaimed after all consumers process"},{"location":"reference/api/util/eventing/event_bus/#key-guarantee","title":"Key guarantee","text":"<p>All consumers (required and optional) are guaranteed to receive every event, even during ring buffer wrap-around. The bus ensures events are not destroyed until all consumers have processed them.</p>"},{"location":"reference/api/util/eventing/event_bus/#use-cases","title":"Use cases","text":"<ul> <li>Required: Strategy handlers, risk managers, order routers - anything that must process every event</li> <li>Optional: Logging, metrics, debugging tools - where occasional delays shouldn't block the main flow</li> </ul>"},{"location":"reference/api/util/eventing/event_bus/#notes","title":"Notes","text":"<ul> <li>Capacity must be a power of 2 for efficient masking.</li> <li>Optional consumers don't block <code>waitConsumed()</code> or <code>flush()</code>, but still receive all events.</li> <li><code>subscribe()</code> must be called before <code>start()</code> - returns false otherwise.</li> <li><code>enableDrainOnStop()</code> should be called before <code>start()</code> if drain behavior is needed.</li> <li>CPU affinity features require <code>FLOX_CPU_AFFINITY_ENABLED</code> compile flag.</li> <li><code>publish()</code> returns -1 if the bus is not running.</li> </ul>"},{"location":"reference/api/util/eventing/event_bus/#benchmarking","title":"Benchmarking","text":"<p>Run <code>event_bus_benchmark</code> to measure performance on your hardware:</p> <pre><code>cmake -DFLOX_ENABLE_BENCHMARKS=ON ..\nmake event_bus_benchmark\n./benchmarks/event_bus_benchmark\n</code></pre> <p>Example results on Intel i5-1135G7 @ 2.40GHz (4 cores / 8 threads):</p> Benchmark Time Throughput PublishLatency 50 ns 20 M/s SingleConsumerThroughput 61 \u00b5s/1000 16 M/s MultiConsumer (4) 195 \u00b5s/1000 5 M/s TryPublishLatency 110 ns 9 M/s EndToEndLatency 200 ns 5 M/s"},{"location":"reference/api/util/memory/pool/","title":"Pool &amp; Handle","text":"<p>This module implements a lock-free, reference-counted object pool for zero-allocation reuse of high-frequency data structures. It is optimized for HFT workloads with strict latency and memory control requirements.</p>"},{"location":"reference/api/util/memory/pool/#poolpoolt-capacity","title":"<code>pool::Pool&lt;T, Capacity&gt;</code>","text":"<p>A statically sized memory pool for pre-allocating <code>T</code> objects that conform to the <code>Poolable</code> concept.</p> <pre><code>Pool&lt;BookUpdateEvent, 8192&gt; bookPool;\nauto handle = bookPool.acquire(); // returns optional&lt;Handle&lt;T&gt;&gt;\n</code></pre>"},{"location":"reference/api/util/memory/pool/#purpose","title":"Purpose","text":"<ul> <li>Eliminate runtime allocations in performance-critical paths.</li> <li>Efficiently recycle reusable objects like events or buffers.</li> </ul>"},{"location":"reference/api/util/memory/pool/#responsibilities","title":"Responsibilities","text":"Feature Description Allocation Constructs objects in-place using <code>std::pmr</code> memory resource. Recycling Returns objects to the pool via <code>releaseToPool()</code>. Ref-counting Uses intrusive reference counting (<code>retain</code>, <code>release</code>). Lifecycle Calls <code>clear()</code> and <code>resetRefCount()</code> on reuse."},{"location":"reference/api/util/memory/pool/#poolhandlet","title":"<code>pool::Handle&lt;T&gt;</code>","text":"<p>A move-only, reference-counted smart pointer for objects allocated from the pool.</p> <pre><code>Handle&lt;BookUpdateEvent&gt; h = pool.acquire().value();\nh-&gt;tickSequence = 123;\n</code></pre>"},{"location":"reference/api/util/memory/pool/#purpose_1","title":"Purpose","text":"<ul> <li>Safely manage lifetime of pooled objects without heap allocations.</li> </ul>"},{"location":"reference/api/util/memory/pool/#features","title":"Features","text":"Feature Description Move-only Copy retains reference; assignment is deleted. Auto-release Returns to pool when last reference is destroyed. Type-safe cast <code>upcast&lt;U&gt;()</code> supports safe widening conversions."},{"location":"reference/api/util/memory/pool/#type-requirements","title":"Type Requirements","text":"<p><code>T</code> must:</p> <ul> <li>Inherit from <code>RefCountable</code> and <code>PoolableBase&lt;T&gt;</code></li> <li> <p>Implement:</p> </li> <li> <p><code>clear()</code></p> </li> <li><code>setPool(void*)</code></li> <li><code>releaseToPool()</code></li> </ul>"},{"location":"reference/api/util/memory/pool/#internal-design","title":"Internal Design","text":"<ul> <li><code>Pool&lt;T&gt;</code> uses <code>std::aligned_storage</code> for static placement.</li> <li>Objects are returned to the pool via an <code>SPSCQueue&lt;T*&gt;</code>.</li> <li>Backed by a <code>monotonic_buffer_resource</code> and <code>unsynchronized_pool_resource</code> for internal vector-like allocations.</li> </ul>"},{"location":"reference/api/util/memory/pool/#exhaustion-handling","title":"Exhaustion Handling","text":"<p>The pool provides callbacks and statistics for monitoring pool usage:</p> <pre><code>pool.setExhaustionCallback([](size_t capacity, size_t inUse) {\n  LOG_WARN(\"Pool exhausted: capacity={}, inUse={}\", capacity, inUse);\n});\n</code></pre> Method Description <code>capacity()</code> Returns the pool's maximum capacity. <code>inUse()</code> Returns the number of currently acquired objects. <code>exhaustionCount()</code> Returns how many times <code>acquire()</code> failed. <code>acquireCount()</code> Returns total number of successful acquisitions. <code>releaseCount()</code> Returns total number of releases back to pool. <p>The exhaustion callback is invoked each time <code>acquire()</code> returns <code>nullopt</code> due to pool exhaustion.</p>"},{"location":"reference/api/util/memory/pool/#sizing-guidelines","title":"Sizing Guidelines","text":"<p>When using pools with <code>EventBus</code>, the pool capacity must be greater than the EventBus capacity:</p> <pre><code>// Correct: pool capacity (8191) &gt; bus capacity (4096)\nPool&lt;BookUpdateEvent, 8191&gt; pool;\nEventBus&lt;Handle&lt;BookUpdateEvent&gt;, 4096&gt; bus;\n\n// Incorrect: will cause pool exhaustion\nPool&lt;BookUpdateEvent, 4096&gt; pool;  // Same as bus = will exhaust!\nEventBus&lt;Handle&lt;BookUpdateEvent&gt;, 4096&gt; bus;\n</code></pre> <p>Why? EventBus only reclaims events when the ring buffer wraps around. If pool capacity \u2264 bus capacity, all pool slots will be in-flight before any can be returned.</p> <p>The default <code>config::DEFAULT_CONNECTOR_POOL_CAPACITY</code> (8191) is sized for this reason when used with <code>DEFAULT_EVENTBUS_CAPACITY</code> (4096).</p>"},{"location":"reference/api/util/memory/pool/#notes","title":"Notes","text":"<ul> <li>Zero allocations in steady-state operation.</li> <li>Thread-safe for single-producer, single-consumer usage.</li> <li>All objects are destructed in-place on shutdown.</li> <li>Used extensively for <code>BookUpdateEvent</code>, <code>TradeEvent</code>, and other high-volume types.</li> </ul>"},{"location":"reference/api/util/memory/ref_countable/","title":"RefCountable","text":"<p><code>RefCountable</code> is a low-overhead, intrusive reference counting base class. It enables manual control of object lifetime without dynamic memory management and is used as the foundation for pooled, shared objects in FLOX.</p> <pre><code>class RefCountable {\npublic:\n  void retain() noexcept;\n  bool release() noexcept;\n  void resetRefCount(uint32_t value = 0) noexcept;\n  uint32_t refCount() const noexcept;\n};\n</code></pre>"},{"location":"reference/api/util/memory/ref_countable/#purpose","title":"Purpose","text":"<ul> <li>Provide deterministic, allocation-free lifetime tracking for objects managed in pools or event buses.</li> </ul>"},{"location":"reference/api/util/memory/ref_countable/#responsibilities","title":"Responsibilities","text":"Method Description <code>retain()</code> Increments reference count (non-atomic relaxed). <code>release()</code> Decrements reference count; returns <code>true</code> if last ref. <code>resetRefCount()</code> Resets ref count to 0 or specified value. <code>refCount()</code> Returns current ref count for debug/inspection."},{"location":"reference/api/util/memory/ref_countable/#behavior","title":"Behavior","text":"<ul> <li>When <code>release()</code> returns <code>true</code>, the object is no longer in use and may be recycled.</li> <li>Incorrect calls (e.g. <code>release()</code> on <code>0</code>) are fatal in debug builds and abort in release.</li> </ul>"},{"location":"reference/api/util/memory/ref_countable/#design-notes","title":"Design Notes","text":"<ul> <li>Uses <code>std::atomic&lt;uint32_t&gt;</code> with relaxed memory ordering for performance.</li> <li>Thread-safe under the assumption that retain/release are called from valid ownership contexts.</li> <li>Not designed for multi-owner concurrent access \u2014 intended for single-threaded or externally synchronized lifecycles.</li> </ul>"},{"location":"reference/api/util/memory/ref_countable/#concept","title":"Concept","text":"<pre><code>template &lt;typename T&gt;\nconcept RefCountable = requires(T obj) {\n  { obj.retain() } -&gt; std::same_as&lt;void&gt;;\n  { obj.release() } -&gt; std::same_as&lt;bool&gt;;\n  { obj.resetRefCount() } -&gt; std::same_as&lt;void&gt;;\n};\n</code></pre> <p>This concept ensures compile-time validation for use in pooled or handle-managed objects.</p>"},{"location":"reference/api/util/performance/core_assignment/","title":"CoreAssignmentManager","text":"<p><code>CoreAssignmentManager</code> is responsible for assigning CPU cores to critical components in the FLOX Engine to optimize performance, minimize contention, and leverage CPU topology such as isolated cores and NUMA awareness.</p>"},{"location":"reference/api/util/performance/core_assignment/#overview","title":"Overview","text":"<p>FLOX supports assigning cores to the following critical components:</p> <ul> <li><code>marketData</code> \u2014 Market data collection and processing</li> <li><code>execution</code> \u2014 Order routing and order execution</li> <li><code>strategy</code> \u2014 Strategy computation and signal generation</li> <li><code>risk</code> \u2014 Risk validation and rejection filtering</li> </ul> <p>These components can be pinned to isolated or shared cores based on a configurable policy.</p>"},{"location":"reference/api/util/performance/core_assignment/#configuration-criticalcomponentconfig","title":"Configuration: CriticalComponentConfig","text":"<p>This config defines how isolated and shared cores are assigned:</p> <pre><code>struct CriticalComponentConfig\n{\n  bool preferIsolatedCores;       // Prefer isolated cores if available\n  bool exclusiveIsolatedCores;    // Use isolated cores exclusively (no sharing)\n  bool allowSharedCriticalCores;  // Allow components to share cores\n  int minIsolatedForCritical;     // Minimum isolated cores required\n  std::map&lt;std::string, int&gt; componentPriority; // Lower value = higher priority\n};\n</code></pre> <p>Default priority:</p> Component Priority <code>marketData</code> 0 <code>execution</code> 1 <code>strategy</code> 2 <code>risk</code> 3"},{"location":"reference/api/util/performance/core_assignment/#coreassignment-result","title":"CoreAssignment Result","text":"<p>After assignment, <code>CoreAssignment</code> structure contains:</p> <ul> <li><code>.marketDataCores</code>, <code>.executionCores</code>, <code>.strategyCores</code>, <code>.riskCores</code></li> <li><code>.generalCores</code> \u2014 fallback cores for non-critical components</li> <li><code>.hasIsolatedCores</code> \u2014 whether isolated cores were used</li> <li><code>.criticalCores</code> \u2014 union of all critical components' cores</li> </ul>"},{"location":"reference/api/util/performance/core_assignment/#assignment-strategies","title":"Assignment Strategies","text":"Method Description <code>getRecommendedCoreAssignment()</code> Chooses optimal strategy based on config <code>getNumaAwareCoreAssignment()</code> Prefer NUMA-balanced layout if isolated cores <code>getBasicCoreAssignment(num, isolated)</code> Fallback round-robin assignment"},{"location":"reference/api/util/performance/core_assignment/#affinity-pinning","title":"Affinity Pinning","text":"<p>You can pin the current thread to the assigned cores for a given component:</p> <pre><code>bool success = pinCriticalComponent(\"marketData\", assignment);\n</code></pre> <p>To pin all components at once:</p> <pre><code>setupAndPinCriticalComponents(config);\n</code></pre>"},{"location":"reference/api/util/performance/core_assignment/#validation-and-debugging","title":"Validation and Debugging","text":"Method Purpose <code>verifyCriticalCoreIsolation()</code> Ensures all critical cores are truly isolated <code>checkIsolatedCoreRequirements()</code> Checks availability of minimum isolated cores <code>demonstrateIsolatedCoreUsage()</code> Logs current assignment and core layout <p>Example log output:</p> <pre><code>=== CPU Affinity and Isolated Core Usage Demonstration ===\nTotal CPU cores: 12\nIsolated cores: 2 3 4\nRecommended core assignment:\nMarket Data cores: 2\nExecution cores: 3\nStrategy cores: 4\nRisk cores: 5\nGeneral cores: 6 7 8 9 10 11\n</code></pre>"},{"location":"reference/api/util/performance/core_assignment/#internals","title":"Internals","text":"<p>Under the hood, <code>CoreAssignmentManager</code> uses:</p> <ul> <li><code>CpuTopology</code> \u2014 queried for isolated and non-isolated cores</li> <li><code>ThreadAffinity</code> \u2014 pins threads to specified cores using <code>sched_setaffinity()</code></li> <li><code>NumaTopology</code> \u2014 optionally used to balance across NUMA nodes</li> </ul> <pre><code>ThreadAffinity affinity(createSystemInterface());\naffinity.pinCurrentThreadToCores({3});\n</code></pre>"},{"location":"reference/api/util/performance/core_assignment/#notes","title":"Notes","text":"<ul> <li>Default policy uses one core per critical component.</li> <li>Isolated cores are preferred and assigned to higher priority components.</li> <li>General tasks are assigned remaining cores.</li> <li>This module is optional: core pinning will only occur if explicitly enabled.</li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/","title":"CpuAffinity","text":"<p>The <code>CpuAffinity</code> class provides a unified interface for managing thread affinity, real-time scheduling, NUMA policies, and performance-oriented CPU assignment. It serves as a high-level facade over several specialized components.</p>"},{"location":"reference/api/util/performance/cpu_affinity/#purpose","title":"Purpose","text":"<ul> <li>Pin threads and components to specific CPU cores</li> <li>Optimize for latency via isolated cores and NUMA locality</li> <li>Abstract platform details through injected interfaces</li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/#composition","title":"Composition","text":"<p><code>CpuAffinity</code> internally coordinates the following subsystems:</p> Component Responsibility <code>ISystemInterface</code> Platform-specific system operations <code>CpuTopology</code> Logical/physical CPU and NUMA layout <code>ThreadAffinity</code> Pinning and scheduling logic <code>CoreAssignmentManager</code> Allocation of roles to CPU cores"},{"location":"reference/api/util/performance/cpu_affinity/#key-features","title":"Key Features","text":""},{"location":"reference/api/util/performance/cpu_affinity/#thread-affinity","title":"Thread Affinity","text":"<ul> <li><code>pinToCore(int coreId)</code></li> <li><code>pinToCore(std::thread&amp;, int coreId)</code></li> <li><code>getCurrentAffinity()</code></li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/#scheduling","title":"Scheduling","text":"<ul> <li><code>setRealTimePriority(int priority = 80)</code></li> <li><code>setRealTimePriority(std::thread&amp;, int priority = 80)</code></li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/#core-management","title":"Core Management","text":"<ul> <li><code>getNumCores()</code></li> <li><code>getIsolatedCores()</code></li> <li><code>disableCpuFrequencyScaling()</code></li> <li><code>enableCpuFrequencyScaling()</code></li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/#assignment-strategies","title":"Assignment Strategies","text":"<ul> <li><code>getRecommendedCoreAssignment(...)</code></li> <li><code>getBasicCoreAssignment(...)</code></li> <li><code>getNumaAwareCoreAssignment(...)</code></li> <li><code>pinCriticalComponent(...)</code></li> <li><code>verifyCriticalCoreIsolation(...)</code></li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/#numa-awareness","title":"NUMA Awareness","text":"<ul> <li><code>getNumaTopology()</code></li> <li><code>getNumaNodeForCore(int coreId)</code></li> <li><code>pinToNumaNode(int nodeId)</code></li> <li><code>setMemoryPolicy(int nodeId)</code></li> </ul>"},{"location":"reference/api/util/performance/cpu_affinity/#lifecycle","title":"Lifecycle","text":"<p><code>CpuAffinity</code> can be created via its constructor or with the helper:</p> <pre><code>auto cpuAffinity = createCpuAffinity();\n````\n\nAll subsystems will be lazily instantiated with default implementations unless provided explicitly for testing.\n\n## RAII: `NumaAffinityGuard`\n\nWraps the calling thread with a temporary NUMA and affinity setting:\n\n```cpp\n{\n  NumaAffinityGuard guard(cpuAffinity, coreId, numaNodeId);\n  // thread is pinned and memory policy applied\n}\n// automatically restored on destruction\n</code></pre>"},{"location":"reference/api/util/performance/cpu_affinity/#example","title":"Example","text":"<pre><code>auto affinity = createCpuAffinity();\n\nif (affinity-&gt;checkIsolatedCoreRequirements()) {\n  auto layout = affinity-&gt;getRecommendedCoreAssignment();\n  affinity-&gt;pinCriticalComponent(\"execution\", layout);\n  affinity-&gt;setRealTimePriority();\n}\n</code></pre>"},{"location":"reference/api/util/performance/cpu_affinity/#integration","title":"Integration","text":"<p>Used by performance-critical modules such as:</p> <ul> <li>Strategy engine threads</li> <li>Market data collectors</li> <li>Execution pipelines</li> </ul> <p>It ensures low-latency execution and determinism by aligning component-to-core layout with hardware topology.</p>"},{"location":"reference/api/util/performance/cpu_topology/","title":"CpuTopology","text":"<p>The <code>CpuTopology</code> class provides system-level introspection for CPU layout and NUMA topology. It is used to understand the physical and logical arrangement of cores and to optimize thread and memory placement.</p>"},{"location":"reference/api/util/performance/cpu_topology/#purpose","title":"Purpose","text":"<ul> <li>Determine number of physical CPU cores</li> <li>Identify isolated and non-isolated cores</li> <li>Access detailed NUMA topology (if available)</li> <li>Map CPU cores to their NUMA nodes</li> </ul>"},{"location":"reference/api/util/performance/cpu_topology/#key-structures","title":"Key Structures","text":""},{"location":"reference/api/util/performance/cpu_topology/#numanode","title":"<code>NumaNode</code>","text":"<pre><code>struct NumaNode {\n  int nodeId;\n  std::vector&lt;int&gt; cpuCores;\n  size_t totalMemoryMB;\n  size_t freeMemoryMB;\n};\n````\n\n### `NumaTopology`\n\n```cpp\nstruct NumaTopology {\n  std::vector&lt;NumaNode&gt; nodes;\n  int numNodes;\n  bool numaAvailable;\n};\n</code></pre>"},{"location":"reference/api/util/performance/cpu_topology/#responsibilities","title":"Responsibilities","text":"Method Description <code>getNumCores()</code> Returns total number of logical cores <code>getAllCores()</code> Returns list of core indices from 0 to N-1 <code>getIsolatedCores()</code> Returns list of isolated CPUs (from cmdline) <code>getNonIsolatedCores()</code> All cores minus isolated ones <code>isNumaAvailable()</code> Whether NUMA support is available on the system <code>getNumaTopology()</code> Returns detailed info about all NUMA nodes <code>getNumaNodeForCore(coreId)</code> Returns the NUMA node to which a specific core belongs <code>getCoresForNumaNode(nodeId)</code> Lists cores that belong to a given NUMA node"},{"location":"reference/api/util/performance/cpu_topology/#lazy-caching","title":"Lazy Caching","text":"<p><code>CpuTopology</code> caches:</p> <ul> <li>Core count</li> <li>Isolated cores</li> <li>NUMA layout</li> </ul> <p>This minimizes redundant syscalls and file reads.</p>"},{"location":"reference/api/util/performance/cpu_topology/#usage-example","title":"Usage Example","text":"<pre><code>CpuTopology topology(createSystemInterface());\n\nif (topology.isNumaAvailable()) {\n  auto nodes = topology.getNumaTopology().nodes;\n  for (const auto&amp; node : nodes) {\n    std::cout &lt;&lt; \"NUMA Node \" &lt;&lt; node.nodeId &lt;&lt; \": \";\n    for (int core : node.cpuCores)\n      std::cout &lt;&lt; core &lt;&lt; \" \";\n    std::cout &lt;&lt; \"\\n\";\n  }\n}\n</code></pre>"},{"location":"reference/api/util/performance/cpu_topology/#integration","title":"Integration","text":"<p><code>CpuTopology</code> is used by:</p> <ul> <li><code>CpuAffinity</code> for pinning and scheduling</li> <li><code>CoreAssignmentManager</code> for optimized component placement</li> <li><code>NumaAffinityGuard</code> for temporary core+memory locality enforcement</li> </ul> <p>It provides the necessary insights into hardware layout to guide all thread and memory affinity operations.</p>"},{"location":"reference/api/util/performance/force_inline/","title":"FLOX_FORCE_INLINE","text":"<p>Cross-platform macro for forcing function inlining on performance-critical code paths.</p>"},{"location":"reference/api/util/performance/force_inline/#header","title":"Header","text":"<pre><code>#include \"flox/util/performance/force_inline.h\"\n</code></pre>"},{"location":"reference/api/util/performance/force_inline/#definition","title":"Definition","text":"<pre><code>#ifdef _MSC_VER\n#define FLOX_FORCE_INLINE __forceinline\n#else\n#define FLOX_FORCE_INLINE __attribute__((always_inline)) inline\n#endif\n</code></pre>"},{"location":"reference/api/util/performance/force_inline/#usage","title":"Usage","text":"<pre><code>class MyClass {\npublic:\n  FLOX_FORCE_INLINE void hotPathMethod() noexcept {\n    // Performance-critical code\n  }\n};\n</code></pre>"},{"location":"reference/api/util/performance/force_inline/#when-to-use","title":"When to Use","text":"<p>Use <code>FLOX_FORCE_INLINE</code> on: - Hot path functions called millions of times per second - Small functions where call overhead exceeds function body - Template methods that must inline for performance - Functions in tight loops</p>"},{"location":"reference/api/util/performance/force_inline/#when-not-to-use","title":"When NOT to Use","text":"<p>Avoid on: - Large functions (increases code size, cache pressure) - Cold paths (rarely executed code) - Virtual functions (cannot be inlined anyway) - Recursive functions</p>"},{"location":"reference/api/util/performance/force_inline/#platform-behavior","title":"Platform Behavior","text":"Compiler Implementation Notes MSVC <code>__forceinline</code> Strong hint, may still not inline in debug builds GCC <code>__attribute__((always_inline)) inline</code> Forces inline unless impossible Clang <code>__attribute__((always_inline)) inline</code> Same as GCC"},{"location":"reference/api/util/performance/force_inline/#example-multitimeframeaggregator","title":"Example: MultiTimeframeAggregator","text":"<pre><code>template &lt;size_t MaxTimeframes&gt;\nclass MultiTimeframeAggregator {\nprivate:\n  FLOX_FORCE_INLINE void processSlot(size_t slotIdx, const TradeEvent&amp; trade) {\n    // Called for every trade, for every timeframe\n    // ~10ns overhead if not inlined\n  }\n\n  template &lt;typename Policy&gt;\n  FLOX_FORCE_INLINE void processPolicy(Policy&amp; policy, ...) {\n    // Policy dispatch - must inline for zero-cost abstraction\n  }\n};\n</code></pre>"},{"location":"reference/api/util/performance/force_inline/#verification","title":"Verification","text":"<p>Use <code>objdump -d</code> or compiler explorer to verify inlining:</p> <pre><code># Check if function was inlined (should NOT appear as separate symbol)\nnm ./build/benchmarks/bar_aggregator_benchmark | grep processSlot\n</code></pre>"},{"location":"reference/api/util/performance/force_inline/#see-also","title":"See Also","text":"<ul> <li>CPU Affinity - Pin threads to cores</li> <li>Thread Affinity - Thread-to-core binding</li> </ul>"},{"location":"reference/api/util/performance/system_interface/","title":"SystemInterface","text":"<p>The <code>SystemInterface</code> module provides an abstraction over platform-specific system operations related to CPU affinity, thread priority, NUMA configuration, and file I/O. It serves as the foundation for CPU-level performance tuning and is primarily used by <code>CpuAffinity</code> and related components.</p>"},{"location":"reference/api/util/performance/system_interface/#purpose","title":"Purpose","text":"<ul> <li>Isolate system calls from platform-independent logic</li> <li>Enable mocking and testing via <code>NullSystemInterface</code></li> <li>Provide unified access to thread and CPU-level control</li> </ul>"},{"location":"reference/api/util/performance/system_interface/#interface-isysteminterface","title":"Interface: <code>ISystemInterface</code>","text":""},{"location":"reference/api/util/performance/system_interface/#affinity","title":"Affinity","text":"Method Description <code>setThreadAffinity(pthread_t thread, const std::vector&lt;int&gt;&amp; cores)</code> Pins a specific thread to the specified cores <code>setCurrentThreadAffinity(const std::vector&lt;int&gt;&amp; cores)</code> Pins the current thread to the specified cores <code>getCurrentThreadAffinity()</code> Returns the current thread\u2019s CPU affinity"},{"location":"reference/api/util/performance/system_interface/#thread-priority","title":"Thread Priority","text":"Method Description <code>setThreadPriority(pthread_t thread, int priority)</code> Sets real-time priority (SCHED_FIFO) for a specific thread <code>setCurrentThreadPriority(int priority)</code> Sets real-time priority for the current thread"},{"location":"reference/api/util/performance/system_interface/#topology-numa","title":"Topology &amp; NUMA","text":"Method Description <code>getNumCores()</code> Returns the total number of logical CPU cores <code>getIsolatedCores()</code> Returns list of isolated cores from <code>isolcpus=</code> kernel argument <code>getNumaNodes()</code> Returns list of NUMA nodes and associated core IDs <code>getNumaNodeForCore(int coreId)</code> Returns NUMA node ID for the given core <code>setMemoryPolicy(int nodeId)</code> Sets preferred memory allocation policy for the current thread <code>isNumaAvailable()</code> Returns true if NUMA is supported and available"},{"location":"reference/api/util/performance/system_interface/#file-io","title":"File I/O","text":"Method Description <code>readFile(const std::string&amp; path)</code> Reads the content of a file <code>writeFile(const std::string&amp; path, const std::string&amp; content)</code> Writes content to a file"},{"location":"reference/api/util/performance/system_interface/#implementations","title":"Implementations","text":""},{"location":"reference/api/util/performance/system_interface/#linuxsysteminterface","title":"<code>LinuxSystemInterface</code>","text":"<p>Linux-specific implementation based on:</p> <ul> <li><code>sched_setaffinity</code>, <code>pthread_setschedparam</code>, <code>sched_setscheduler</code></li> <li>NUMA support via <code>&lt;numa.h&gt;</code> and <code>/sys/devices/system/node/</code></li> <li>Parses <code>/proc/cmdline</code> for <code>isolcpus=</code></li> <li>Reads and writes files through <code>std::ifstream</code> / <code>std::ofstream</code></li> </ul>"},{"location":"reference/api/util/performance/system_interface/#nullsysteminterface","title":"<code>NullSystemInterface</code>","text":"<p>Dummy fallback used on unsupported platforms or in tests:</p> <ul> <li>All methods return <code>false</code> or empty/default values</li> <li>Safe no-op implementation</li> </ul>"},{"location":"reference/api/util/performance/system_interface/#numa-support","title":"NUMA Support","text":"<p>NUMA is considered available if either:</p> <ol> <li>The system links with <code>libnuma</code> and headers are present (<code>FLOX_NUMA_LIBRARY_LINKED</code>)</li> <li><code>/sys/devices/system/node/</code> contains valid <code>node*</code> directories and <code>cpulist</code> files</li> </ol>"},{"location":"reference/api/util/performance/system_interface/#factory-function","title":"Factory Function","text":"<pre><code>std::unique_ptr&lt;ISystemInterface&gt; createSystemInterface();\n````\n\nCreates a platform-appropriate implementation:\n\n* `LinuxSystemInterface` on Linux\n* `NullSystemInterface` otherwise\n\n## Example\n\n```cpp\nauto system = createSystemInterface();\n\nif (system-&gt;isNumaAvailable()) {\n  auto nodes = system-&gt;getNumaNodes();\n  if (!nodes.empty()) {\n    system-&gt;setCurrentThreadAffinity({nodes[0].second.front()});\n    system-&gt;setMemoryPolicy(nodes[0].first);\n  }\n}\n</code></pre>"},{"location":"reference/api/util/performance/system_interface/#integration","title":"Integration","text":"<p>This interface is consumed by:</p> <ul> <li><code>ThreadAffinity</code></li> <li><code>CpuTopology</code></li> <li><code>CoreAssignmentManager</code></li> <li><code>CpuAffinity</code></li> </ul> <p>It decouples platform-specific logic and enables system-aware optimization in a portable way.</p>"},{"location":"reference/api/util/performance/thread_affinity/","title":"ThreadAffinity","text":"<p>The <code>ThreadAffinity</code> class provides a unified interface for managing thread affinity, real-time priority, and CPU frequency policies in latency-critical systems. It is used to enforce deterministic scheduling behavior and optimal placement on isolated cores.</p>"},{"location":"reference/api/util/performance/thread_affinity/#responsibilities","title":"Responsibilities","text":"Capability Description Pinning Assign threads (or current thread) to specific core(s) Priority Set real-time thread priorities (SCHED_FIFO) NUMA Set memory allocation policy for NUMA locality Governors Switch CPU frequency governors for performance consistency Validation Verify whether selected cores are isolated"},{"location":"reference/api/util/performance/thread_affinity/#public-interface","title":"Public Interface","text":""},{"location":"reference/api/util/performance/thread_affinity/#pinning","title":"Pinning","text":"<pre><code>bool pinCurrentThreadToCore(int coreId);\nbool pinCurrentThreadToCores(const std::vector&lt;int&gt;&amp; coreIds);\nbool pinThreadToCore(std::thread&amp;, int coreId);\nbool pinThreadToCores(std::thread&amp;, const std::vector&lt;int&gt;&amp; coreIds);\n````\n\n### Priority\n\n```cpp\nbool setCurrentThreadPriority(int priority = 80);\nbool setThreadPriority(std::thread&amp;, int priority = 80);\n</code></pre>"},{"location":"reference/api/util/performance/thread_affinity/#affinity-numa","title":"Affinity &amp; NUMA","text":"<pre><code>std::vector&lt;int&gt; getCurrentThreadAffinity();\nbool setCurrentThreadNumaPolicy(int nodeId);\n</code></pre>"},{"location":"reference/api/util/performance/thread_affinity/#cpu-frequency-policy","title":"CPU Frequency Policy","text":"<pre><code>bool disableCpuFrequencyScaling();  // \"performance\"\nbool enableCpuFrequencyScaling();   // \"powersave\"\n</code></pre>"},{"location":"reference/api/util/performance/thread_affinity/#validation","title":"Validation","text":"<pre><code>bool verifyCriticalCoreIsolation(const std::vector&lt;int&gt;&amp; cores);\n</code></pre>"},{"location":"reference/api/util/performance/thread_affinity/#usage-example","title":"Usage Example","text":"<pre><code>ThreadAffinity affinity(createSystemInterface());\n\naffinity.pinCurrentThreadToCore(2);\naffinity.setCurrentThreadPriority(90);\naffinity.disableCpuFrequencyScaling();\n</code></pre>"},{"location":"reference/api/util/performance/thread_affinity/#threadaffinityguard","title":"ThreadAffinityGuard","text":"<p>RAII wrapper that ensures temporary pinning to a specific core or cores.</p> <pre><code>{\n  ThreadAffinityGuard guard(3);  // Pins thread to core 3 temporarily\n  // Do latency-sensitive work here\n}  // Original affinity is restored automatically\n</code></pre>"},{"location":"reference/api/util/performance/thread_affinity/#design-notes","title":"Design Notes","text":"<ul> <li>Uses <code>ISystemInterface</code> for portability and mocking</li> <li>Avoids OS-specific code in high-level components</li> <li>Defaults to <code>performance</code> governor to eliminate CPU frequency variance</li> <li>Isolated cores are detected via <code>/proc/cmdline</code> (<code>isolcpus=...</code>)</li> </ul>"},{"location":"reference/api/util/performance/thread_affinity/#integration","title":"Integration","text":"<p>Used directly or via:</p> <ul> <li><code>CpuAffinity</code> as part of performance toolkit</li> <li><code>NumaAffinityGuard</code> for NUMA-aware scoped locality</li> <li>Benchmark tools and real-time strategy components in FLOX</li> </ul>"},{"location":"reference/api/validation/abstract_order_validator/","title":"IOrderValidator","text":"<p><code>IOrderValidator</code> defines the interface for validating outbound orders before submission. It ensures correctness and compliance with predefined constraints (e.g. price ranges, order size).</p> <pre><code>class IOrderValidator : public ISubsystem {\npublic:\n  virtual ~IOrderValidator() = default;\n  virtual bool validate(const Order&amp; order, std::string&amp; reason) const = 0;\n};\n</code></pre>"},{"location":"reference/api/validation/abstract_order_validator/#purpose","title":"Purpose","text":"<ul> <li>Prevent invalid or unsafe orders from reaching the execution layer by performing sanity checks.</li> </ul>"},{"location":"reference/api/validation/abstract_order_validator/#responsibilities","title":"Responsibilities","text":"Method Description <code>validate</code> Checks if the order is valid. Returns <code>true</code> if valid; else sets <code>reason</code>."},{"location":"reference/api/validation/abstract_order_validator/#notes","title":"Notes","text":"<ul> <li>Must be called prior to invoking <code>IOrderExecutor::submitOrder()</code>.</li> <li>Provides human-readable error messages via the <code>reason</code> output parameter.</li> <li> <p>Implementations can enforce checks such as:</p> </li> <li> <p>Non-zero quantity</p> </li> <li>Price within expected deviation</li> <li>Tick-size alignment</li> <li>Symbol validity</li> <li>Integrated into the engine as an <code>ISubsystem</code> for lifecycle coordination.</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step lessons to get you productive with FLOX.</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 compiler (GCC 13+ or Clang 16+)</li> <li>CMake 3.22+</li> <li>Linux (recommended)</li> </ul>"},{"location":"tutorials/#getting-started","title":"Getting Started","text":"Tutorial What You'll Learn Quickstart Build FLOX and run the demo First Strategy Write a simple trading strategy Multi-Timeframe Strategy Build strategies using multiple bar timeframes Recording Data Capture live market data to disk Backtesting Replay recorded data through your strategy"},{"location":"tutorials/#recommended-order","title":"Recommended Order","text":"<ol> <li>Quickstart \u2014 Verify your environment works</li> <li>First Strategy \u2014 Understand the core programming model</li> <li>Multi-Timeframe Strategy \u2014 Work with multiple bar timeframes</li> <li>Recording Data \u2014 Set up market data capture</li> <li>Backtesting \u2014 Test strategies against historical data</li> </ol> <p>After completing these tutorials, move on to How-To Guides for specific tasks or Explanation for deeper understanding.</p>"},{"location":"tutorials/backtesting/","title":"Backtesting","text":"<p>Run your strategy against recorded market data.</p>"},{"location":"tutorials/backtesting/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Recording Data</li> <li>Recorded <code>.floxlog</code> files</li> <li>Build with <code>-DFLOX_ENABLE_BACKTEST=ON</code></li> </ul>"},{"location":"tutorials/backtesting/#1-backtestrunner-overview","title":"1. BacktestRunner Overview","text":"<p><code>BacktestRunner</code> replays recorded data through your strategy with simulated execution:</p> <pre><code>.floxlog files \u2192 BacktestRunner \u2192 Strategy \u2192 SimulatedExecutor \u2192 BacktestResult\n</code></pre>"},{"location":"tutorials/backtesting/#2-minimal-example","title":"2. Minimal Example","text":"<pre><code>#include \"flox/backtest/backtest_runner.h\"\n#include \"flox/replay/readers/binary_log_reader.h\"\n#include \"flox/engine/symbol_registry.h\"\n#include \"flox/strategy/strategy.h\"\n\nusing namespace flox;\n\nint main()\n{\n  // 1. Load recorded data\n  replay::ReaderFilter filter;\n  filter.symbols = {1};  // Only symbol ID 1\n  auto reader = replay::createMultiSegmentReader(\"/data/market_data\", filter);\n\n  // 2. Configure backtest\n  BacktestConfig config;\n  config.initialCapital = 10000.0;\n  config.feeRate = 0.0004;  // 0.04% taker fee\n\n  BacktestRunner runner(config);\n\n  // 3. Create registry and strategy\n  SymbolRegistry registry;\n  SymbolInfo info;\n  info.exchange = \"BINANCE\";\n  info.symbol = \"BTCUSDT\";\n  info.tickSize = Price::fromDouble(0.01);\n  SymbolId symbolId = registry.registerSymbol(info);\n\n  MyStrategy strategy(symbolId, registry);\n  runner.setStrategy(&amp;strategy);\n\n  // 4. Run\n  BacktestResult result = runner.run(*reader);\n\n  // 5. Get statistics\n  auto stats = result.computeStats();\n  std::cout &lt;&lt; \"Return: \" &lt;&lt; stats.returnPct &lt;&lt; \"%\\n\";\n  std::cout &lt;&lt; \"Sharpe: \" &lt;&lt; stats.sharpeRatio &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; \"Max DD: \" &lt;&lt; stats.maxDrawdownPct &lt;&lt; \"%\\n\";\n  std::cout &lt;&lt; \"Trades: \" &lt;&lt; stats.totalTrades &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"tutorials/backtesting/#3-writing-a-backtest-ready-strategy","title":"3. Writing a Backtest-Ready Strategy","text":"<p>Use <code>Strategy</code> base class with signal emission:</p> <pre><code>class MyStrategy : public Strategy\n{\npublic:\n  MyStrategy(SymbolId sym, const SymbolRegistry&amp; registry)\n    : Strategy(1, sym, registry) {}\n\n  void start() override { _running = true; }\n  void stop() override { _running = false; }\n\nprotected:\n  void onSymbolTrade(SymbolContext&amp; ctx, const TradeEvent&amp; ev) override\n  {\n    if (!_running) return;\n\n    // Your logic here\n    if (shouldBuy(ev.trade.price))\n    {\n      emitMarketBuy(symbol(), Quantity::fromDouble(1.0));\n    }\n  }\n\nprivate:\n  bool _running{false};\n};\n</code></pre> <p>Key points:</p> <ul> <li>Inherit from <code>Strategy</code>, not <code>IStrategy</code></li> <li>Use <code>emitMarketBuy()</code> / <code>emitMarketSell()</code> \u2014 BacktestRunner intercepts these signals</li> <li>Access order book via <code>ctx.book</code>, position via <code>ctx.position</code></li> </ul>"},{"location":"tutorials/backtesting/#4-backtestconfig-options","title":"4. BacktestConfig Options","text":"<pre><code>BacktestConfig config;\nconfig.initialCapital = 10000.0;  // Starting capital\nconfig.feeRate = 0.0004;          // 0.04% per trade\nconfig.slippage = 0.0;            // Price slippage (0 = fill at signal price)\n</code></pre>"},{"location":"tutorials/backtesting/#5-backtestresult-statistics","title":"5. BacktestResult Statistics","text":"<pre><code>auto stats = result.computeStats();\n\nstats.initialCapital;    // Starting capital\nstats.finalCapital;      // Ending capital\nstats.returnPct;         // Total return %\nstats.totalTrades;       // Number of trades\nstats.winRate;           // Win rate (0-1)\nstats.sharpeRatio;       // Annualized Sharpe\nstats.sortinoRatio;      // Sortino ratio\nstats.maxDrawdownPct;    // Maximum drawdown %\nstats.profitFactor;      // Gross profit / gross loss\n</code></pre>"},{"location":"tutorials/backtesting/#6-time-range-filtering","title":"6. Time Range Filtering","text":"<p>Backtest only a portion of your data:</p> <pre><code>replay::ReaderFilter filter;\nfilter.from_ns = 1704067200000000000LL;  // 2024-01-01\nfilter.to_ns = 1704153600000000000LL;    // 2024-01-02\nfilter.symbols = {1};\n\nauto reader = replay::createMultiSegmentReader(\"/data\", filter);\n</code></pre>"},{"location":"tutorials/backtesting/#7-using-bars-instead-of-raw-data","title":"7. Using Bars Instead of Raw Data","text":"<p>For bar-based strategies, aggregate on the fly:</p> <pre><code>class BarStrategy : public Strategy\n{\npublic:\n  BarStrategy(SymbolId sym, const SymbolRegistry&amp; registry)\n    : Strategy(1, sym, registry)\n  {\n    _aggregator = std::make_unique&lt;TimeBarAggregator&gt;(\n      TimeBarPolicy(std::chrono::seconds(60)),\n      this  // Strategy receives BarEvents\n    );\n  }\n\nprotected:\n  void onSymbolTrade(SymbolContext&amp; ctx, const TradeEvent&amp; ev) override\n  {\n    _aggregator-&gt;onTrade(ev);\n  }\n\n  void onBar(const BarEvent&amp; ev) override\n  {\n    // Your bar-based logic\n    if (ev.bar.close &gt; ev.bar.open)\n    {\n      emitMarketBuy(symbol(), Quantity::fromDouble(1.0));\n    }\n  }\n\nprivate:\n  std::unique_ptr&lt;TimeBarAggregator&gt; _aggregator;\n};\n</code></pre>"},{"location":"tutorials/backtesting/#8-inspecting-data-before-backtest","title":"8. Inspecting Data Before Backtest","text":"<pre><code>auto summary = replay::BinaryLogReader::inspect(\"/data/market_data\");\n\nstd::cout &lt;&lt; \"Events: \" &lt;&lt; summary.total_events &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Duration: \" &lt;&lt; summary.durationHours() &lt;&lt; \" hours\\n\";\nstd::cout &lt;&lt; \"Segments: \" &lt;&lt; summary.segment_count &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"tutorials/backtesting/#9-performance-tips","title":"9. Performance Tips","text":"<ol> <li>Build in Release mode: <code>cmake .. -DCMAKE_BUILD_TYPE=Release</code></li> <li>Filter symbols: Only load what you need</li> <li>Disable logging: Comment out <code>FLOX_LOG</code> calls</li> <li>Use indexed data: Enables fast seeking</li> </ol>"},{"location":"tutorials/backtesting/#next-steps","title":"Next Steps","text":"<ul> <li>Running a Backtest \u2014 Complete SMA crossover example</li> <li>Grid Search Optimization \u2014 Find optimal parameters</li> <li>Bar Aggregation \u2014 Pre-aggregate for faster backtests</li> </ul>"},{"location":"tutorials/demo/","title":"Run the Demo","text":"<p>The <code>demo</code> folder provides a minimal working example that wires FLOX components into a functioning system. It demonstrates the architecture, event flow, and subsystem lifecycle in a controlled, simulated environment.</p>"},{"location":"tutorials/demo/#features","title":"Features","text":"Component Description <code>DemoConnector</code> Emits synthetic trades and book updates for testing <code>DemoStrategy</code> Receives market data and generates mock orders <code>SimpleOrderExecutor</code> Processes orders and triggers fills via <code>OrderExecutionBus</code> <code>SimplePnLTracker</code> Tracks profit and loss <code>SimpleKillSwitch</code> Emergency shutdown control <code>SimpleRiskManager</code> Basic risk controls <code>DemoBuilder</code> Constructs and wires all required subsystems and buses"},{"location":"tutorials/demo/#build-the-demo","title":"Build the Demo","text":"<pre><code>cmake .. -DFLOX_ENABLE_DEMO=ON\nmake -j$(nproc)\n</code></pre>"},{"location":"tutorials/demo/#run-the-demo_1","title":"Run the Demo","text":"<pre><code>./demo/flox_demo\n</code></pre> <p>The demo will:</p> <ol> <li>Start two synthetic connectors</li> <li>Publish market data via <code>TradeBus</code> and <code>BookUpdateBus</code></li> <li>Run the strategy and supporting systems for approximately five seconds</li> <li>Stop all components and exit cleanly</li> </ol>"},{"location":"tutorials/demo/#expected-output","title":"Expected Output","text":"<pre><code>[INFO] Starting DemoConnector (exchange1)\n[INFO] Starting DemoConnector (exchange2)\n[INFO] DemoStrategy: received trade BTCUSDT @ 50000.00\n[INFO] DemoStrategy: received book update BTCUSDT (10 levels)\n[INFO] DemoStrategy: placing order BUY 0.1 BTCUSDT @ 49990.00\n[INFO] SimpleOrderExecutor: order filled\n...\n[INFO] Stopping all components\n[INFO] Demo completed\n</code></pre>"},{"location":"tutorials/demo/#code-structure","title":"Code Structure","text":"<pre><code>demo/\n\u251c\u2500\u2500 main.cpp              # Entry point\n\u251c\u2500\u2500 demo_builder.h        # Wires all components\n\u251c\u2500\u2500 demo_connector.h      # Synthetic market data\n\u251c\u2500\u2500 demo_strategy.h       # Example strategy\n\u2514\u2500\u2500 simple_*.h            # Simple implementations of interfaces\n</code></pre>"},{"location":"tutorials/demo/#understanding-the-demo","title":"Understanding the Demo","text":""},{"location":"tutorials/demo/#demobuilder","title":"DemoBuilder","text":"<p>The builder demonstrates how to wire FLOX components:</p> <pre><code>// Create buses\nauto tradeBus = std::make_unique&lt;TradeBus&gt;();\nauto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\nauto execBus = std::make_unique&lt;OrderExecutionBus&gt;();\n\n// Create connectors\nauto connector = std::make_shared&lt;DemoConnector&gt;(registry, tradeBus, bookBus);\n\n// Create strategy\nauto strategy = std::make_unique&lt;DemoStrategy&gt;();\n\n// Subscribe strategy to buses\ntradeBus-&gt;subscribe(strategy.get());\nbookBus-&gt;subscribe(strategy.get());\n\n// Wire execution\nstrategy-&gt;setExecutor(executor.get());\n\n// Start engine\nengine.start();\n</code></pre>"},{"location":"tutorials/demo/#democonnector","title":"DemoConnector","text":"<p>Generates synthetic market data at configurable rates:</p> <pre><code>void DemoConnector::run() {\n    while (_running) {\n        TradeEvent trade;\n        trade.trade.symbol = _symbolId;\n        trade.trade.price = generatePrice();\n        trade.trade.quantity = generateQty();\n\n        _tradeBus.publish(trade);\n\n        std::this_thread::sleep_for(10ms);\n    }\n}\n</code></pre>"},{"location":"tutorials/demo/#demostrategy","title":"DemoStrategy","text":"<p>Shows how to consume events and place orders:</p> <pre><code>void DemoStrategy::onTrade(const TradeEvent&amp; event) {\n    // Process trade\n    if (shouldBuy(event)) {\n        Order order;\n        order.symbol = event.trade.symbol;\n        order.side = OrderSide::BUY;\n        order.price = event.trade.price - _tickSize;\n        order.quantity = _orderSize;\n\n        _executor-&gt;submit(order);\n    }\n}\n</code></pre>"},{"location":"tutorials/demo/#notes","title":"Notes","text":"<ul> <li>This demo is intended for integration testing and illustration only</li> <li>Production deployments should define their own builder and execution harness</li> <li>All demo components are isolated and can be replaced with real implementations</li> </ul>"},{"location":"tutorials/demo/#see-also","title":"See Also","text":"<ul> <li>Quickstart \u2014 Build FLOX from source</li> <li>First Strategy \u2014 Write your own strategy</li> <li>Architecture \u2014 How components fit together</li> </ul>"},{"location":"tutorials/first-strategy/","title":"First Strategy","text":"<p>Write a simple trading strategy that reacts to market data.</p>"},{"location":"tutorials/first-strategy/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Quickstart</li> <li>Basic C++ knowledge</li> </ul>"},{"location":"tutorials/first-strategy/#1-strategy-interface","title":"1. Strategy Interface","text":"<p>All strategies implement <code>IStrategy</code>, which combines:</p> <ul> <li><code>ISubsystem</code> \u2014 lifecycle (<code>start()</code>, <code>stop()</code>)</li> <li><code>IMarketDataSubscriber</code> \u2014 market data callbacks</li> </ul> <pre><code>#include \"flox/strategy/abstract_strategy.h\"\n\nclass MyStrategy : public flox::IStrategy\n{\npublic:\n  // Required: unique identifier for event routing\n  flox::SubscriberId id() const override {\n    return reinterpret_cast&lt;flox::SubscriberId&gt;(this);\n  }\n\n  // Lifecycle\n  void start() override { /* initialization */ }\n  void stop() override { /* cleanup */ }\n\n  // Market data callbacks\n  void onTrade(const flox::TradeEvent&amp; ev) override { /* react to trades */ }\n  void onBookUpdate(const flox::BookUpdateEvent&amp; ev) override { /* react to book changes */ }\n  void onBar(const flox::BarEvent&amp; ev) override { /* react to bars */ }\n  void onMarketDataError(const flox::MarketDataError&amp; error) override { /* handle errors */ }\n};\n</code></pre>"},{"location":"tutorials/first-strategy/#2-simple-example","title":"2. Simple Example","text":"<p>A strategy that prints trades and tracks best bid/ask:</p> <pre><code>#include \"flox/strategy/abstract_strategy.h\"\n#include \"flox/book/events/trade_event.h\"\n#include \"flox/book/events/book_update_event.h\"\n#include \"flox/log/log.h\"\n\nusing namespace flox;\n\nclass PrintingStrategy : public IStrategy\n{\npublic:\n  explicit PrintingStrategy(SymbolId symbol) : _symbol(symbol) {}\n\n  SubscriberId id() const override {\n    return reinterpret_cast&lt;SubscriberId&gt;(this);\n  }\n\n  void start() override {\n    FLOX_LOG(\"[PrintingStrategy] Started for symbol \" &lt;&lt; _symbol);\n  }\n\n  void stop() override {\n    FLOX_LOG(\"[PrintingStrategy] Stopped. Trades seen: \" &lt;&lt; _tradeCount);\n  }\n\n  void onTrade(const TradeEvent&amp; ev) override {\n    // Filter by symbol\n    if (ev.trade.symbol != _symbol) return;\n\n    ++_tradeCount;\n    FLOX_LOG(\"Trade: \" &lt;&lt; ev.trade.price.toDouble()\n             &lt;&lt; \" x \" &lt;&lt; ev.trade.quantity.toDouble()\n             &lt;&lt; \" (\" &lt;&lt; (ev.trade.isBuy ? \"BUY\" : \"SELL\") &lt;&lt; \")\");\n  }\n\n  void onBookUpdate(const BookUpdateEvent&amp; ev) override {\n    if (ev.update.symbol != _symbol) return;\n\n    if (!ev.update.bids.empty()) {\n      _bestBid = ev.update.bids[0].price;\n    }\n    if (!ev.update.asks.empty()) {\n      _bestAsk = ev.update.asks[0].price;\n    }\n\n    FLOX_LOG(\"Book: \" &lt;&lt; _bestBid.toDouble() &lt;&lt; \" / \" &lt;&lt; _bestAsk.toDouble());\n  }\n\nprivate:\n  SymbolId _symbol;\n  uint64_t _tradeCount{0};\n  Price _bestBid{};\n  Price _bestAsk{};\n};\n</code></pre>"},{"location":"tutorials/first-strategy/#3-strategy-with-order-execution","title":"3. Strategy with Order Execution","text":"<p>A strategy that submits orders based on trades:</p> <pre><code>#include \"flox/strategy/abstract_strategy.h\"\n#include \"flox/execution/abstract_executor.h\"\n#include \"flox/execution/order.h\"\n\nusing namespace flox;\n\nclass TradingStrategy : public IStrategy\n{\npublic:\n  TradingStrategy(SymbolId symbol, IOrderExecutor* executor)\n    : _symbol(symbol), _executor(executor) {}\n\n  SubscriberId id() const override {\n    return reinterpret_cast&lt;SubscriberId&gt;(this);\n  }\n\n  void onTrade(const TradeEvent&amp; ev) override {\n    if (ev.trade.symbol != _symbol) return;\n\n    // Simple logic: buy after every 10th trade\n    if (++_tradeCount % 10 != 0) return;\n\n    Order order{};\n    order.id = _nextOrderId++;\n    order.symbol = _symbol;\n    order.side = Side::BUY;\n    order.price = ev.trade.price - Price::fromDouble(0.01);  // 1 cent below\n    order.quantity = Quantity::fromDouble(1.0);\n    order.type = OrderType::LIMIT;\n\n    _executor-&gt;submitOrder(order);\n  }\n\nprivate:\n  SymbolId _symbol;\n  IOrderExecutor* _executor;\n  uint64_t _tradeCount{0};\n  OrderId _nextOrderId{1};\n};\n</code></pre>"},{"location":"tutorials/first-strategy/#4-wiring-the-strategy","title":"4. Wiring the Strategy","text":"<p>Connect your strategy to the engine:</p> <pre><code>#include \"flox/book/bus/trade_bus.h\"\n#include \"flox/book/bus/book_update_bus.h\"\n#include \"flox/engine/engine.h\"\n\n// Create buses\nauto tradeBus = std::make_unique&lt;TradeBus&gt;();\nauto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\n\n// Create strategy\nauto strategy = std::make_unique&lt;PrintingStrategy&gt;(/*symbolId=*/0);\n\n// Subscribe to buses\ntradeBus-&gt;subscribe(strategy.get());\nbookBus-&gt;subscribe(strategy.get());\n\n// Add to subsystems\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\nsubsystems.push_back(std::move(tradeBus));\nsubsystems.push_back(std::move(bookBus));\nsubsystems.push_back(std::move(strategy));\n\n// Create and run engine\nEngineConfig config{};\nEngine engine(config, std::move(subsystems), std::move(connectors));\nengine.start();\n</code></pre>"},{"location":"tutorials/first-strategy/#5-best-practices","title":"5. Best Practices","text":"<p>Do:</p> <ul> <li>Keep callbacks fast and non-blocking</li> <li>Filter events by symbol early (first line of callback)</li> <li>Use <code>Price::fromDouble()</code> and <code>Quantity::fromDouble()</code> for conversions</li> <li>Implement <code>id()</code> to return a unique value</li> </ul> <p>Don't:</p> <ul> <li>Block in callbacks (no I/O, no locks, no allocations)</li> <li>Store pointers to events (they're recycled)</li> <li>Throw exceptions from callbacks</li> </ul>"},{"location":"tutorials/first-strategy/#key-types","title":"Key Types","text":"Type Description <code>SymbolId</code> <code>uint32_t</code> identifier for an instrument <code>Price</code> Fixed-point price (use <code>fromDouble()</code>, <code>toDouble()</code>) <code>Quantity</code> Fixed-point quantity <code>Side</code> <code>BUY</code> or <code>SELL</code> <code>OrderType</code> <code>LIMIT</code>, <code>MARKET</code>, etc."},{"location":"tutorials/first-strategy/#next-steps","title":"Next Steps","text":"<ul> <li>Recording Data \u2014 Capture market data to disk</li> <li>Architecture Overview \u2014 Understand the event flow</li> </ul>"},{"location":"tutorials/multi-timeframe-strategy/","title":"Tutorial: Multi-Timeframe Strategy","text":"<p>This tutorial walks you through building a multi-timeframe momentum strategy from scratch. You'll learn how to:</p> <ul> <li>Set up bar aggregation for multiple timeframes</li> <li>Store bar history in a BarMatrix</li> <li>Access bars from different timeframes in your strategy</li> <li>Generate trading signals based on MTF analysis</li> </ul>"},{"location":"tutorials/multi-timeframe-strategy/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic C++ knowledge</li> <li>Flox Engine installed and building</li> <li>Completed First Strategy tutorial</li> </ul>"},{"location":"tutorials/multi-timeframe-strategy/#what-were-building","title":"What We're Building","text":"<p>A momentum strategy that:</p> <ol> <li>Uses H1 (hourly) bars to determine trend direction</li> <li>Uses M5 (5-minute) bars to identify pullbacks</li> <li>Uses M1 (1-minute) bars for entry timing</li> </ol> <p>Entry logic: Buy when H1 is bullish, M5 shows a pullback, and M1 prints a reversal bar.</p>"},{"location":"tutorials/multi-timeframe-strategy/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a new file <code>my_mtf_strategy.cpp</code>:</p> <pre><code>#include \"flox/aggregator/bar_aggregator.h\"\n#include \"flox/aggregator/bar_matrix.h\"\n#include \"flox/aggregator/bus/bar_bus.h\"\n#include \"flox/aggregator/multi_timeframe_aggregator.h\"\n#include \"flox/aggregator/timeframe.h\"\n#include \"flox/book/events/trade_event.h\"\n#include \"flox/common.h\"\n#include \"flox/engine/abstract_market_data_subscriber.h\"\n\n#include &lt;iostream&gt;\n\nusing namespace flox;\n</code></pre>"},{"location":"tutorials/multi-timeframe-strategy/#step-2-define-the-strategy-class","title":"Step 2: Define the Strategy Class","text":"<pre><code>class MTFMomentumStrategy : public IMarketDataSubscriber\n{\n public:\n  explicit MTFMomentumStrategy(SymbolId symbol, BarMatrix&lt;256, 4, 64&gt;* matrix)\n      : _symbol(symbol), _matrix(matrix)\n  {\n  }\n\n  SubscriberId id() const override\n  {\n    return reinterpret_cast&lt;SubscriberId&gt;(this);\n  }\n\n  void onBar(const BarEvent&amp; ev) override\n  {\n    // We'll implement this next\n  }\n\n private:\n  SymbolId _symbol;\n  BarMatrix&lt;256, 4, 64&gt;* _matrix;\n};\n</code></pre> <p>The strategy: - Takes a symbol ID and pointer to a BarMatrix - Implements <code>IMarketDataSubscriber</code> to receive bar events - Will analyze bars in <code>onBar()</code></p>"},{"location":"tutorials/multi-timeframe-strategy/#step-3-implement-the-trading-logic","title":"Step 3: Implement the Trading Logic","text":"<p>Add the signal generation in <code>onBar()</code>:</p> <pre><code>void onBar(const BarEvent&amp; ev) override\n{\n  // Only process bars for our symbol\n  if (ev.symbol != _symbol)\n  {\n    return;\n  }\n\n  // Only act on M1 bars (fastest timeframe for entries)\n  if (ev.barType != BarType::Time || ev.barTypeParam != 60)\n  {\n    return;\n  }\n\n  // Get bars from different timeframes\n  const Bar* h1 = _matrix-&gt;bar(_symbol, timeframe::H1, 0);      // Latest H1\n  const Bar* h1_prev = _matrix-&gt;bar(_symbol, timeframe::H1, 1); // Previous H1\n  const Bar* m5 = _matrix-&gt;bar(_symbol, timeframe::M5, 0);      // Latest M5\n  const Bar* m1 = _matrix-&gt;bar(_symbol, timeframe::M1, 0);      // Latest M1\n\n  // Need all bars to generate signals\n  if (!h1 || !h1_prev || !m5 || !m1)\n  {\n    return;  // Not enough data yet\n  }\n\n  // 1. Check H1 trend\n  bool h1Bullish = h1-&gt;close &gt; h1_prev-&gt;close;\n\n  // 2. Check M5 pullback (bearish bar in uptrend)\n  bool m5Pullback = m5-&gt;close &lt; m5-&gt;open;\n\n  // 3. Check M1 reversal (bullish bar after pullback)\n  bool m1Reversal = m1-&gt;close &gt; m1-&gt;open;\n\n  // Generate signal\n  if (h1Bullish &amp;&amp; m5Pullback &amp;&amp; m1Reversal)\n  {\n    std::cout &lt;&lt; \"[SIGNAL] BUY @ \" &lt;&lt; m1-&gt;close.toDouble()\n              &lt;&lt; \" | H1 bullish, M5 pullback, M1 reversal\" &lt;&lt; std::endl;\n  }\n}\n</code></pre> <p>Key points:</p> <ul> <li>We filter for M1 bars to trigger entry logic on the fastest timeframe</li> <li><code>bar(symbol, timeframe, index)</code> gives us historical bars (0 = latest, 1 = previous)</li> <li>We check conditions across all three timeframes</li> </ul>"},{"location":"tutorials/multi-timeframe-strategy/#step-4-set-up-the-infrastructure","title":"Step 4: Set Up the Infrastructure","text":"<p>Now create <code>main()</code> to wire everything together:</p> <pre><code>int main()\n{\n  constexpr SymbolId SYMBOL = 1;\n\n  // 1. Create the bar event bus\n  BarBus bus;\n\n  // 2. Create multi-timeframe aggregator\n  MultiTimeframeAggregator&lt;4&gt; aggregator(&amp;bus);\n  aggregator.addTimeInterval(std::chrono::seconds(60));    // M1\n  aggregator.addTimeInterval(std::chrono::seconds(300));   // M5\n  aggregator.addTimeInterval(std::chrono::seconds(3600));  // H1\n\n  // 3. Create bar matrix for history storage\n  BarMatrix&lt;256, 4, 64&gt; matrix;\n  std::array&lt;TimeframeId, 3&gt; timeframes = {\n    timeframe::M1,\n    timeframe::M5,\n    timeframe::H1\n  };\n  matrix.configure(timeframes);\n\n  // 4. Create strategy\n  MTFMomentumStrategy strategy(SYMBOL, &amp;matrix);\n\n  // 5. Subscribe to bar events\n  bus.subscribe(&amp;matrix);    // Matrix stores bars\n  bus.subscribe(&amp;strategy);  // Strategy receives bars\n\n  // 6. Start components\n  bus.start();\n  aggregator.start();\n\n  // 7. Feed trades (in real system, this comes from connector)\n  // aggregator.onTrade(tradeEvent);\n\n  // 8. Cleanup\n  aggregator.stop();\n  bus.stop();\n\n  return 0;\n}\n</code></pre>"},{"location":"tutorials/multi-timeframe-strategy/#step-5-understanding-the-data-flow","title":"Step 5: Understanding the Data Flow","text":"<pre><code>flowchart TB\n    TE[TradeEvent] --&gt; MTA[MultiTimeframeAggregator]\n\n    MTA --&gt; M1[M1 aggregator]\n    MTA --&gt; M5[M5 aggregator]\n    MTA --&gt; H1[H1 aggregator]\n\n    M1 --&gt; BE1[BarEvent M1]\n    M5 --&gt; BE5[BarEvent M5]\n    H1 --&gt; BEH[BarEvent H1]\n\n    BE1 --&gt; BB[BarBus]\n    BE5 --&gt; BB\n    BEH --&gt; BB\n\n    BB --&gt; BM[BarMatrix&lt;br/&gt;stores bar history]\n    BB --&gt; STR[MTFMomentumStrategy&lt;br/&gt;generates signals]</code></pre> <ol> <li>Trades come from your connector</li> <li>MultiTimeframeAggregator builds bars for all timeframes simultaneously</li> <li>BarBus distributes BarEvents to subscribers</li> <li>BarMatrix stores history for lookback</li> <li>Strategy accesses BarMatrix for multi-timeframe analysis</li> </ol>"},{"location":"tutorials/multi-timeframe-strategy/#step-6-adding-more-signal-logic","title":"Step 6: Adding More Signal Logic","text":"<p>Let's enhance the strategy with sell signals and tracking:</p> <pre><code>class MTFMomentumStrategy : public IMarketDataSubscriber\n{\n public:\n  // ... constructor ...\n\n  void onBar(const BarEvent&amp; ev) override\n  {\n    if (ev.symbol != _symbol) return;\n    if (ev.barType != BarType::Time || ev.barTypeParam != 60) return;\n\n    const Bar* h1 = _matrix-&gt;bar(_symbol, timeframe::H1, 0);\n    const Bar* h1_prev = _matrix-&gt;bar(_symbol, timeframe::H1, 1);\n    const Bar* m5 = _matrix-&gt;bar(_symbol, timeframe::M5, 0);\n    const Bar* m1 = _matrix-&gt;bar(_symbol, timeframe::M1, 0);\n\n    if (!h1 || !h1_prev || !m5 || !m1) return;\n\n    // Trend detection\n    bool h1Bullish = h1-&gt;close &gt; h1_prev-&gt;close;\n    bool h1Bearish = h1-&gt;close &lt; h1_prev-&gt;close;\n\n    // Pullback detection\n    bool m5Pullback = m5-&gt;close &lt; m5-&gt;open;   // Bearish M5 in uptrend\n    bool m5Rally = m5-&gt;close &gt; m5-&gt;open;      // Bullish M5 in downtrend\n\n    // Entry bar\n    bool m1BullishReversal = m1-&gt;close &gt; m1-&gt;open;\n    bool m1BearishReversal = m1-&gt;close &lt; m1-&gt;open;\n\n    // BUY signal\n    if (h1Bullish &amp;&amp; m5Pullback &amp;&amp; m1BullishReversal)\n    {\n      std::cout &lt;&lt; \"[BUY] @ \" &lt;&lt; m1-&gt;close.toDouble() &lt;&lt; std::endl;\n      ++_buySignals;\n    }\n    // SELL signal\n    else if (h1Bearish &amp;&amp; m5Rally &amp;&amp; m1BearishReversal)\n    {\n      std::cout &lt;&lt; \"[SELL] @ \" &lt;&lt; m1-&gt;close.toDouble() &lt;&lt; std::endl;\n      ++_sellSignals;\n    }\n  }\n\n  void printStats() const\n  {\n    std::cout &lt;&lt; \"Buy signals:  \" &lt;&lt; _buySignals &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Sell signals: \" &lt;&lt; _sellSignals &lt;&lt; std::endl;\n  }\n\n private:\n  SymbolId _symbol;\n  BarMatrix&lt;256, 4, 64&gt;* _matrix;\n  int _buySignals = 0;\n  int _sellSignals = 0;\n};\n</code></pre>"},{"location":"tutorials/multi-timeframe-strategy/#step-7-adding-delta-confirmation","title":"Step 7: Adding Delta Confirmation","text":"<p>Use buy/sell volume for confirmation:</p> <pre><code>// In onBar(), after getting bars:\n\n// Check delta (buy pressure - sell pressure)\nVolume buyVol = m1-&gt;buyVolume;\nVolume sellVol = Volume::fromRaw(m1-&gt;volume.raw() - m1-&gt;buyVolume.raw());\nbool positiveDelta = buyVol.raw() &gt; sellVol.raw();\n\n// Enhanced BUY signal with delta confirmation\nif (h1Bullish &amp;&amp; m5Pullback &amp;&amp; m1BullishReversal &amp;&amp; positiveDelta)\n{\n  std::cout &lt;&lt; \"[BUY] @ \" &lt;&lt; m1-&gt;close.toDouble()\n            &lt;&lt; \" | Delta: +\" &lt;&lt; (buyVol.raw() - sellVol.raw()) &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"tutorials/multi-timeframe-strategy/#complete-example","title":"Complete Example","text":"<p>See multi_timeframe_demo.cpp for a complete working example.</p>"},{"location":"tutorials/multi-timeframe-strategy/#next-steps","title":"Next Steps","text":"<ul> <li>Add position management and risk controls</li> <li>Implement stop-loss and take-profit logic</li> <li>Add Volume Profile for key level detection</li> <li>Use Footprint for order flow confirmation</li> </ul>"},{"location":"tutorials/quickstart/","title":"Quickstart","text":"<p>Build FLOX and run the demo application in 5 minutes.</p>"},{"location":"tutorials/quickstart/#1-clone-and-build","title":"1. Clone and Build","text":"<pre><code>git clone https://github.com/FLOX-Foundation/flox.git\ncd flox\n\nmkdir build &amp;&amp; cd build\ncmake .. -DFLOX_ENABLE_DEMO=ON\nmake -j$(nproc)\n</code></pre>"},{"location":"tutorials/quickstart/#2-run-the-demo","title":"2. Run the Demo","text":"<pre><code>./demo/flox_demo\n</code></pre> <p>The demo runs for 30 seconds, then prints latency statistics:</p> <pre><code>[demo] price spike starting\n[demo] price spike starting\ndemo finished\n=== Latency Report ===\nBusPublish:       p50=123ns  p99=456ns  max=1.2\u00b5s\nStrategyOnTrade:  p50=89ns   p99=234ns  max=890ns\n</code></pre>"},{"location":"tutorials/quickstart/#3-what-the-demo-does","title":"3. What the Demo Does","text":"<p>The demo creates a complete trading system:</p> <pre><code>flowchart LR\n    subgraph Connector\n        DC[DemoConnector&lt;br/&gt;generates fake data]\n    end\n\n    subgraph Bus[\"Event Bus\"]\n        TB[TradeBus]\n        BB[BookBus]\n    end\n\n    subgraph Strategy\n        DS[DemoStrategy&lt;br/&gt;reacts to trades]\n    end\n\n    subgraph Execution\n        EB[ExecutionBus]\n    end\n\n    DC --&gt; TB\n    DC --&gt; BB\n    TB --&gt; DS\n    BB --&gt; DS\n    DS --&gt; EB</code></pre> <ol> <li>DemoConnector generates fake trades and order book updates</li> <li>Events flow through TradeBus and BookUpdateBus (Disruptor-style ring buffers)</li> <li>DemoStrategy receives events and submits orders</li> <li>Orders flow through OrderExecutionBus to an execution tracker</li> </ol>"},{"location":"tutorials/quickstart/#4-build-options","title":"4. Build Options","text":"Option Default Description <code>FLOX_ENABLE_DEMO</code> OFF Build the demo application <code>FLOX_ENABLE_TESTS</code> OFF Build unit tests <code>FLOX_ENABLE_BENCHMARKS</code> OFF Build performance benchmarks <code>FLOX_ENABLE_BACKTEST</code> OFF Build backtest module (simulated execution) <code>FLOX_ENABLE_LZ4</code> OFF Enable LZ4 compression for replay <code>FLOX_ENABLE_CPU_AFFINITY</code> OFF Enable CPU pinning (requires libnuma) <code>FLOX_ENABLE_TRACY</code> OFF Enable Tracy profiler integration <p>Example with multiple options:</p> <pre><code>cmake .. \\\n  -DFLOX_ENABLE_DEMO=ON \\\n  -DFLOX_ENABLE_TESTS=ON \\\n  -DFLOX_ENABLE_LZ4=ON \\\n  -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"tutorials/quickstart/#5-verify-installation","title":"5. Verify Installation","text":"<p>Run the tests to verify everything works:</p> <pre><code>cmake .. -DFLOX_ENABLE_TESTS=ON\nmake -j$(nproc)\nctest --output-on-failure\n</code></pre>"},{"location":"tutorials/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>First Strategy \u2014 Write your own trading strategy</li> <li>Architecture Overview \u2014 Understand how components fit together</li> </ul>"},{"location":"tutorials/recording-data/","title":"Recording Data","text":"<p>Capture live market data to disk for later replay and backtesting.</p>"},{"location":"tutorials/recording-data/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed First Strategy</li> <li>Optional: LZ4 library for compression (<code>-DFLOX_ENABLE_LZ4=ON</code>)</li> </ul>"},{"location":"tutorials/recording-data/#1-binarylogwriter-overview","title":"1. BinaryLogWriter Overview","text":"<p>FLOX records market data in a custom binary format optimized for:</p> <ul> <li>Sequential writes (no random access during recording)</li> <li>Fast sequential reads during replay</li> <li>Optional LZ4 compression</li> <li>Automatic file rotation</li> </ul> <pre><code>#include \"flox/replay/writers/binary_log_writer.h\"\n\nusing namespace flox::replay;\n</code></pre>"},{"location":"tutorials/recording-data/#2-basic-recording","title":"2. Basic Recording","text":"<pre><code>// Configure the writer\nWriterConfig config;\nconfig.output_dir = \"/data/market_data\";      // Output directory\nconfig.max_segment_bytes = 256 * 1024 * 1024; // 256 MB per segment\nconfig.create_index = true;                    // Enable fast seeking\nconfig.compression = CompressionType::None;    // Or CompressionType::LZ4\n\nBinaryLogWriter writer(config);\n\n// Write a trade\nTradeRecord trade;\ntrade.symbol_id = 42;\ntrade.price = 10050;        // Fixed-point (multiply by 100)\ntrade.quantity = 100;       // Fixed-point\ntrade.side = 1;             // 1=buy, 0=sell\ntrade.exchange_ts_ns = 1234567890123456789;  // Nanoseconds since epoch\n\nwriter.writeTrade(trade);\n\n// Write a book update\nBookRecordHeader header;\nheader.symbol_id = 42;\nheader.update_type = static_cast&lt;uint8_t&gt;(BookUpdateType::SNAPSHOT);\nheader.bid_count = 5;\nheader.ask_count = 5;\nheader.exchange_ts_ns = 1234567890123456789;\n\nstd::vector&lt;BookLevel&gt; bids = { {10049, 100}, {10048, 200}, ... };\nstd::vector&lt;BookLevel&gt; asks = { {10051, 150}, {10052, 250}, ... };\n\nwriter.writeBook(header, bids, asks);\n\n// Ensure data is persisted\nwriter.flush();\nwriter.close();\n</code></pre>"},{"location":"tutorials/recording-data/#3-recording-from-live-connectors","title":"3. Recording from Live Connectors","text":"<p>Subscribe the writer to your market data buses:</p> <pre><code>class MarketDataRecorder : public IMarketDataSubscriber\n{\npublic:\n  MarketDataRecorder(const std::filesystem::path&amp; output_dir)\n    : _writer(createConfig(output_dir)) {}\n\n  SubscriberId id() const override {\n    return reinterpret_cast&lt;SubscriberId&gt;(this);\n  }\n\n  void onTrade(const TradeEvent&amp; ev) override {\n    TradeRecord record;\n    record.symbol_id = ev.trade.symbol;\n    record.price = ev.trade.price.raw();\n    record.quantity = ev.trade.quantity.raw();\n    record.side = ev.trade.isBuy ? 1 : 0;\n    record.exchange_ts_ns = ev.trade.exchangeTsNs;\n\n    _writer.writeTrade(record);\n  }\n\n  void onBookUpdate(const BookUpdateEvent&amp; ev) override {\n    BookRecordHeader header;\n    header.symbol_id = ev.update.symbol;\n    header.update_type = static_cast&lt;uint8_t&gt;(ev.update.type);\n    header.bid_count = ev.update.bids.size();\n    header.ask_count = ev.update.asks.size();\n    header.exchange_ts_ns = ev.update.exchangeTsNs;\n\n    std::vector&lt;BookLevel&gt; bids, asks;\n    for (const auto&amp; b : ev.update.bids) {\n      bids.push_back({b.price.raw(), b.quantity.raw()});\n    }\n    for (const auto&amp; a : ev.update.asks) {\n      asks.push_back({a.price.raw(), a.quantity.raw()});\n    }\n\n    _writer.writeBook(header, bids, asks);\n  }\n\n  void flush() { _writer.flush(); }\n  void close() { _writer.close(); }\n  WriterStats stats() const { return _writer.stats(); }\n\nprivate:\n  static WriterConfig createConfig(const std::filesystem::path&amp; dir) {\n    WriterConfig cfg;\n    cfg.output_dir = dir;\n    cfg.max_segment_bytes = 256 &lt;&lt; 20;\n    cfg.create_index = true;\n    return cfg;\n  }\n\n  BinaryLogWriter _writer;\n};\n\n// Wire it up\nauto recorder = std::make_unique&lt;MarketDataRecorder&gt;(\"/data/live\");\ntradeBus-&gt;subscribe(recorder.get());\nbookBus-&gt;subscribe(recorder.get());\n</code></pre>"},{"location":"tutorials/recording-data/#4-writer-configuration","title":"4. Writer Configuration","text":"Option Default Description <code>output_dir</code> Required Directory for segment files <code>output_filename</code> Auto Override auto-generated filename <code>max_segment_bytes</code> 256 MB Rotate to new file at this size <code>buffer_size</code> 64 KB Write buffer size <code>sync_on_rotate</code> true fsync before starting new segment <code>create_index</code> true Write index for fast seeking <code>index_interval</code> 1000 Events between index entries <code>compression</code> None <code>None</code> or <code>LZ4</code>"},{"location":"tutorials/recording-data/#5-file-format","title":"5. File Format","text":"<p>FLOX creates <code>.floxlog</code> segment files with embedded index:</p> <pre><code>/data/market_data/\n\u251c\u2500\u2500 metadata.json                    # Recording metadata (exchange, symbols, etc.)\n\u251c\u2500\u2500 20250101_120000_000.floxlog      # First segment (index embedded at end)\n\u251c\u2500\u2500 20250101_121500_001.floxlog      # Second segment (after rotation)\n\u2514\u2500\u2500 index.floxidx                    # Optional: global index across all segments\n</code></pre> <p>Segment structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  SegmentHeader   \u2502  Magic, version, compression, timestamps, index_offset\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Event Frames    \u2502  Trade and book update records\n\u2502  ...             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  SegmentIndex    \u2502  Embedded: timestamp \u2192 offset mapping (if create_index=true)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>The global index (<code>index.floxidx</code>) can be built separately using <code>GlobalIndexBuilder</code> to enable fast lookup across multiple segment files.</p>"},{"location":"tutorials/recording-data/#6-recording-metadata","title":"6. Recording Metadata","text":"<p>Each recording includes a <code>metadata.json</code> file with source information:</p> <pre><code>{\n  \"exchange\": \"binance\",\n  \"exchange_type\": \"cex\",\n  \"instrument_type\": \"perpetual\",\n\n  \"symbols\": [\n    {\n      \"symbol_id\": 1,\n      \"name\": \"BTCUSDT\",\n      \"base_asset\": \"BTC\",\n      \"quote_asset\": \"USDT\",\n      \"price_precision\": 2,\n      \"qty_precision\": 3\n    }\n  ],\n\n  \"has_trades\": true,\n  \"has_book_snapshots\": true,\n  \"has_book_deltas\": true,\n  \"book_depth\": 20,\n\n  \"recording_start\": \"2025-01-15T10:30:00.000Z\",\n  \"recording_end\": \"2025-01-15T18:45:00.000Z\",\n\n  \"price_scale\": 100000000,\n  \"qty_scale\": 100000000\n}\n</code></pre>"},{"location":"tutorials/recording-data/#using-marketdatarecorder","title":"Using MarketDataRecorder","text":"<p>The high-level <code>MarketDataRecorder</code> automatically creates metadata:</p> <pre><code>#include \"flox/replay/market_data_recorder.h\"\n\nMarketDataRecorderConfig config;\nconfig.output_dir = \"/data/btcusdt\";\nconfig.exchange_name = \"binance\";\nconfig.exchange_type = \"cex\";\nconfig.instrument_type = \"perpetual\";\nconfig.book_depth = 20;\n\nMarketDataRecorder recorder(config);\n\n// Add symbol mappings\nrecorder.addSymbol(1, \"BTCUSDT\", \"BTC\", \"USDT\", 2, 3);\n\nrecorder.start();\n// ... subscribe to market data buses ...\nrecorder.stop();  // Writes metadata.json automatically\n</code></pre>"},{"location":"tutorials/recording-data/#manual-metadata-with-binarylogwriter","title":"Manual Metadata with BinaryLogWriter","text":"<pre><code>#include \"flox/replay/recording_metadata.h\"\n\nRecordingMetadata meta;\nmeta.exchange = \"bybit\";\nmeta.instrument_type = \"spot\";\nmeta.has_trades = true;\n\nWriterConfig config;\nconfig.output_dir = \"/data/spot\";\nconfig.metadata = meta;\n\nBinaryLogWriter writer(config);\nwriter.addSymbol({.symbol_id = 1, .name = \"ETHUSDT\"});\n// ... write events ...\nwriter.close();  // Saves metadata.json\n</code></pre>"},{"location":"tutorials/recording-data/#7-monitoring-recording","title":"7. Monitoring Recording","text":"<pre><code>// Periodically check stats\nWriterStats stats = writer.stats();\nstd::cout &lt;&lt; \"Events: \" &lt;&lt; stats.events_written\n          &lt;&lt; \", Trades: \" &lt;&lt; stats.trades_written\n          &lt;&lt; \", Books: \" &lt;&lt; stats.book_updates_written\n          &lt;&lt; \", Segments: \" &lt;&lt; stats.segments_created\n          &lt;&lt; \", Bytes: \" &lt;&lt; stats.bytes_written &lt;&lt; std::endl;\n</code></pre>"},{"location":"tutorials/recording-data/#8-compression","title":"8. Compression","text":"<p>Enable LZ4 for 3-5x size reduction:</p> <pre><code>cmake .. -DFLOX_ENABLE_LZ4=ON\n</code></pre> <pre><code>WriterConfig config;\nconfig.compression = CompressionType::LZ4;\n// Everything else works the same\n</code></pre>"},{"location":"tutorials/recording-data/#next-steps","title":"Next Steps","text":"<ul> <li>Backtesting \u2014 Replay recorded data through your strategy</li> <li>Binary Format \u2014 Recording format specification</li> </ul>"},{"location":"usage/config/","title":"Configuration","text":"<p>FLOX is configured via the <code>EngineConfig</code> structure, typically loaded from a JSON file or embedded configuration source.</p>"},{"location":"usage/config/#example","title":"Example","text":"<pre><code>{\n  \"logLevel\": \"debug\",\n  \"exchanges\": [\n    {\n      \"name\": \"bybit\",\n      \"type\": \"mock\",\n      \"symbols\": [\n        { \"symbol\": \"DOTUSDT\", \"tickSize\": 0.001, \"expectedDeviation\": 0.5 }\n      ]\n    }\n  ],\n  \"killSwitchConfig\": {\n    \"maxOrderQty\": 10000,\n    \"maxLoss\": -5000,\n    \"maxOrdersPerSecond\": 100\n  }\n}\n</code></pre>"},{"location":"usage/config/#fields","title":"Fields","text":""},{"location":"usage/config/#loglevel","title":"<code>logLevel</code>","text":"<p>Controls runtime logging verbosity (<code>debug</code>, <code>info</code>, <code>warn</code>, etc.)</p>"},{"location":"usage/config/#exchanges","title":"<code>exchanges[]</code>","text":"<p>Defines which exchange connectors to start and which symbols to subscribe to.</p> <ul> <li><code>name</code>: display label or unique ID for internal routing</li> <li><code>type</code>: used by <code>ConnectorFactory</code> to instantiate the appropriate connector</li> <li><code>symbols[]</code>: list of symbol configs with tick size and allowed deviation</li> </ul>"},{"location":"usage/config/#killswitchconfig","title":"<code>killSwitchConfig</code>","text":"<p>Defines runtime shutdown thresholds:</p> <ul> <li><code>maxOrderQty</code>: maximum order size allowed per submission</li> <li><code>maxLoss</code>: hard limit on realized/unrealized loss</li> <li><code>maxOrdersPerSecond</code>: rate limit for outbound orders (<code>-1</code> disables)</li> </ul>"},{"location":"usage/config/#notes","title":"Notes","text":"<ul> <li><code>SymbolId</code> is derived automatically from <code>(exchange, symbol)</code> during engine startup</li> <li>Tick size and deviation are used by validators and order book alignment</li> <li>All configuration is immutable after startup for safety and determinism</li> </ul>"},{"location":"usage/connectors/","title":"Connectors","text":""},{"location":"usage/connectors/#connectors","title":"Connectors","text":"<p>FLOX provides a modular architecture that allows connectors to centralized and decentralized exchanges to be developed independently and plugged into the engine.</p> <p>The open-source community implementations of connectors built on top of FLOX are maintained in the following repository:</p> <p>https://github.com/FLOX-Foundation/flox-connectors</p> <p>This repository includes exchange connectors that:</p> <ul> <li>Connect to public and private WebSocket endpoints</li> <li>Publish market data into FLOX event buses</li> <li>Route order requests via authenticated REST APIs</li> <li>Integrate with the core engine using low-latency infrastructure</li> </ul> <p>Contributions are welcome. See the repository for implementation guidelines and examples.</p>"},{"location":"usage/demo/","title":"Demo Application","text":"<p>The <code>demo</code> folder provides a minimal working example that wires FLOX components into a functioning system. It demonstrates the architecture, event flow, and subsystem lifecycle in a controlled, simulated environment.</p>"},{"location":"usage/demo/#features","title":"Features","text":"<ul> <li><code>DemoConnector</code>: emits synthetic trades and book updates for testing</li> <li><code>DemoStrategy</code>: receives market data and generates mock orders</li> <li><code>SimpleOrderExecutor</code>: processes orders and triggers fills via <code>OrderExecutionBus</code></li> <li><code>SimplePnLTracker</code>, <code>SimpleKillSwitch</code>, <code>SimpleRiskManager</code>: lightweight control modules</li> <li><code>DemoBuilder</code>: constructs and wires all required subsystems and buses</li> </ul>"},{"location":"usage/demo/#running-the-demo","title":"Running the Demo","text":"<p>After building the project with CMake:</p> <pre><code>./demo/flox_demo\n</code></pre> <p>The demo will:</p> <ul> <li>Start two synthetic connectors</li> <li>Publish market data via <code>MarketDataBus</code></li> <li>Run the strategy and supporting systems for approximately five seconds</li> <li>Stop all components and exit cleanly</li> </ul>"},{"location":"usage/demo/#notes","title":"Notes","text":"<ul> <li>This demo is intended for integration testing and illustration only</li> <li>Production deployments should define their own builder and execution harness</li> <li>All demo components are isolated and can be replaced with real implementations</li> </ul>"},{"location":"usage/getting_started/","title":"Getting Started","text":"<p>This guide will help you build, test, and install FLOX on your machine.</p>"},{"location":"usage/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 or later (e.g. GCC 13 or Clang 16+)</li> <li>CMake 3.22+</li> <li>Git</li> <li>Linux (recommended), Windows and macOS supported</li> <li>GoogleTest and Google Benchmark</li> <li>LZ4 (optional, for compression)</li> <li><code>clang-format</code> 18.1.8 (for development)</li> </ul>"},{"location":"usage/getting_started/#clone-and-build","title":"Clone and Build","text":"<pre><code>git clone https://github.com/eeiaao/flox.git\ncd flox\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n</code></pre>"},{"location":"usage/getting_started/#install-dependencies","title":"Install Dependencies","text":"<p>If GoogleTest and Google Benchmark are not installed system-wide:</p> <pre><code># GoogleTest\ngit clone --depth=1 https://github.com/google/googletest.git\ncmake -B gtest-build -S googletest\ncmake --build gtest-build --target gtest gtest_main gmock gmock_main\nsudo cmake --install gtest-build\n\n# Google Benchmark\ngit clone --depth=1 https://github.com/google/benchmark.git\ncmake -B benchmark-build -S benchmark -DCMAKE_BUILD_TYPE=Release -DBENCHMARK_DOWNLOAD_DEPENDENCIES=ON\ncmake --build benchmark-build -j$(nproc)\nsudo cmake --install benchmark-build\n\n# LZ4 (for compression support)\nsudo apt install -y liblz4-dev\n</code></pre>"},{"location":"usage/getting_started/#clang-format-setup","title":"clang-format Setup","text":"<p>We use <code>clang-format</code> 18.x to enforce consistent style. Install it with:</p> <pre><code>sudo apt install -y wget gnupg lsb-release software-properties-common\nwget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt install -y clang-format-18\nsudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-18 100\n</code></pre>"},{"location":"usage/getting_started/#build-options","title":"Build Options","text":"<p>FLOX supports optional components controlled via CMake flags:</p> Option Default Description <code>FLOX_ENABLE_TESTS</code> <code>OFF</code> Build unit tests <code>FLOX_ENABLE_BENCHMARKS</code> <code>OFF</code> Build benchmark binaries <code>FLOX_ENABLE_DEMO</code> <code>OFF</code> Build the demo application <code>FLOX_ENABLE_BACKTEST</code> <code>OFF</code> Build backtest module (simulated execution) <code>FLOX_ENABLE_LZ4</code> <code>OFF</code> Enable LZ4 compression for replay <code>FLOX_ENABLE_CPU_AFFINITY</code> <code>OFF</code> Enable CPU affinity (isolated systems only) <p>To enable them:</p> <pre><code>cmake .. -DFLOX_ENABLE_TESTS=ON -DFLOX_ENABLE_BENCHMARKS=ON -DFLOX_ENABLE_DEMO=ON -DFLOX_ENABLE_LZ4=ON\n</code></pre>"},{"location":"usage/getting_started/#run-tests","title":"Run Tests","text":"<p>From the <code>build</code> directory:</p> <pre><code>ctest --output-on-failure\n</code></pre>"},{"location":"usage/getting_started/#run-benchmarks","title":"Run Benchmarks","text":"<pre><code>./benchmarks/nlevel_order_book_benchmark\n</code></pre> <p>Or any other binary in <code>benchmarks/</code>.</p>"},{"location":"usage/getting_started/#install-system-wide","title":"Install System-Wide","text":"<pre><code>sudo make install\n</code></pre>"},{"location":"usage/getting_started/#code-style-and-contribution","title":"Code Style and Contribution","text":"<ul> <li>All contributions go through pull requests</li> <li>Use existing naming and directory conventions</li> <li>Add tests, benchmarks, and documentation where appropriate</li> </ul> <p>A <code>.clang-format</code> file is provided. A <code>pre-commit</code> hook is installed automatically during CMake configuration. It formats all changed <code>.cpp</code> and <code>.h</code> files.</p> <p>To install it manually:</p> <pre><code>cp scripts/pre-commit .git/hooks/pre-commit\nchmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"usage/getting_started/#using-flox-in-your-project","title":"Using FLOX in Your Project","text":"<p>FLOX is a low-latency infrastructure library. It is suitable for building:</p> <ul> <li>HFT engines</li> <li>Backtesters and simulators</li> <li>Custom execution pipelines</li> <li>Signal routers and adapters</li> </ul> <p>All components are modular, testable, and can be used independently.</p>"},{"location":"usage/integration_flow/","title":"Integration flow","text":""},{"location":"usage/integration_flow/#flox-system-integration-flow-overview","title":"FLOX System Integration Flow (Overview)","text":""},{"location":"usage/integration_flow/#1-register-symbols","title":"1. Register Symbols","text":"<p>Before anything else, the system must define which trading instruments it will operate on. Each symbol is registered with an internal registry, which assigns it a unique identifier and stores metadata (such as exchange name, symbol string, and instrument type).</p>"},{"location":"usage/integration_flow/#2-instantiate-core-components","title":"2. Instantiate Core Components","text":"<p>Several core components must be created and wired together:</p> <ul> <li>A symbol registry to resolve and map symbols across the system.</li> <li>An order tracker to monitor local orders and maintain their current state.</li> <li>Event buses for market data and order events (e.g., for book updates, trades, and execution events).</li> </ul> <p>These components typically live for the entire lifetime of the system.</p>"},{"location":"usage/integration_flow/#3-create-executors-and-connectors","title":"3. Create Executors and Connectors","text":"<ul> <li>An order executor is responsible for sending orders to the exchange and reporting their status.</li> <li>An exchange connector connects to the market (e.g., via WebSocket or REST), receives real-time data, and publishes it to the system.</li> </ul> <p>Both components should be provided with access to the registry, tracker, and transport layer.</p>"},{"location":"usage/integration_flow/#4-set-up-event-delivery","title":"4. Set Up Event Delivery","text":"<p>Event buses are configured to distribute market data (book updates, trades) and internal events (such as order execution updates) to multiple subscribers.</p> <p>Subscribers may include:</p> <ul> <li>Trading strategies</li> <li>Data aggregators</li> <li>Metric collectors</li> <li>Risk modules</li> </ul> <p>Each subscriber declares its interest and is registered with the corresponding bus.</p>"},{"location":"usage/integration_flow/#5-launch-components","title":"5. Launch Components","text":"<p>Once everything is wired:</p> <ul> <li>Event buses are started to begin handling data.</li> <li>Exchange connectors establish connections and begin streaming data.</li> <li>Strategies are started and begin processing events and generating signals.</li> <li>Executors handle outgoing order flow and interact with the tracker and listener components.</li> </ul>"},{"location":"usage/integration_flow/#6-handle-execution-feedback","title":"6. Handle Execution Feedback","text":"<p>When orders are submitted, filled, rejected, or canceled, the system updates the order tracker and may notify listeners or emit events on an execution bus.</p> <p>This ensures consistency of order state and provides visibility into execution outcomes.</p>"},{"location":"usage/integration_flow/#7-shutdown-procedure","title":"7. Shutdown Procedure","text":"<p>When shutting down:</p> <ul> <li>Event buses are stopped to cease fan-out.</li> <li>Strategies and connectors are stopped gracefully.</li> <li>Executors complete any in-flight work and clean up.</li> </ul>"},{"location":"usage/integration_flow/#notes-for-implementers","title":"Notes for Implementers","text":"<ul> <li>The registry and tracker must be passed to any component that deals with symbols or order state.</li> <li>Thread safety and latency guarantees are core to the design \u2014 use lock-free or atomic constructs where applicable.</li> <li>No dynamic allocation in critical paths (e.g., during fan-out or order submission).</li> <li>Buses can operate in sync or async mode depending on requirements (e.g., determinism vs performance).</li> <li>The architecture is modular and decoupled \u2014 new strategies, connectors, or execution backends can be plugged in easily.</li> </ul>"},{"location":"usage/replay/","title":"Replay System","text":"<p>The replay system enables recording live market data and replaying it for backtesting, analysis, and strategy development.</p>"},{"location":"usage/replay/#overview","title":"Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Live Feed \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 BinaryLogWriter \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 .floxlog files    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                     \u2502\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n                   \u2502 ReplayConnector \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502    Strategy     \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/replay/#recording-market-data","title":"Recording Market Data","text":"<p>Use <code>BinaryLogWriter</code> to record live data to segments:</p> <pre><code>#include \"flox/replay/writers/binary_log_writer.h\"\n\nreplay::WriterConfig config{\n    .output_dir = \"/data/market\",\n    .max_segment_bytes = 256ull &lt;&lt; 20,  // 256 MB segments\n    .create_index = true,\n    .compression = CompressionType::LZ4\n};\n\nreplay::BinaryLogWriter writer(config);\n\n// In your connector callback:\nconnector-&gt;setCallbacks(\n    [&amp;writer](const BookUpdateEvent&amp; ev) {\n        writer.writeBook(ev);\n    },\n    [&amp;writer](const TradeEvent&amp; ev) {\n        writer.writeTrade(ev);\n    }\n);\n</code></pre>"},{"location":"usage/replay/#writerconfig-options","title":"WriterConfig Options","text":"Field Type Default Description <code>output_dir</code> <code>path</code> required Directory for output segments <code>output_filename</code> <code>string</code> auto Override auto-generated filename <code>max_segment_bytes</code> <code>uint64_t</code> 256 MB Maximum segment file size <code>buffer_size</code> <code>uint64_t</code> 64 KB Write buffer size <code>exchange_id</code> <code>uint8_t</code> 0 Exchange identifier in header <code>sync_on_rotate</code> <code>bool</code> true fsync before rotating segments <code>create_index</code> <code>bool</code> true Create seek index <code>index_interval</code> <code>uint16_t</code> 1000 Events between index entries <code>compression</code> <code>CompressionType</code> None LZ4 or None"},{"location":"usage/replay/#replaying-data","title":"Replaying Data","text":""},{"location":"usage/replay/#basic-replay","title":"Basic Replay","text":"<pre><code>#include \"flox/replay/replay_connector.h\"\n\nReplayConnectorConfig config{\n    .data_dir = \"/data/market\",\n    .speed = ReplaySpeed::max()  // As fast as possible\n};\n\nauto replay = std::make_shared&lt;ReplayConnector&gt;(config);\n\nreplay-&gt;setCallbacks(\n    [](const BookUpdateEvent&amp; ev) { /* handle book */ },\n    [](const TradeEvent&amp; ev) { /* handle trade */ }\n);\n\nreplay-&gt;start();\n\nwhile (!replay-&gt;isFinished()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n}\n</code></pre>"},{"location":"usage/replay/#with-engine","title":"With Engine","text":"<pre><code>auto registry = std::make_unique&lt;SymbolRegistry&gt;();\nauto mdb = std::make_unique&lt;MarketDataBus&gt;();\n\nReplayConnectorConfig replay_config{\n    .data_dir = \"/data/market\",\n    .speed = ReplaySpeed::max()\n};\n\nauto replay = std::make_shared&lt;ReplayConnector&gt;(replay_config);\nreplay-&gt;setCallbacks(\n    [&amp;mdb](const BookUpdateEvent&amp; ev) { mdb-&gt;publish(ev); },\n    [&amp;mdb](const TradeEvent&amp; ev) { mdb-&gt;publish(ev); }\n);\n\nauto strategy = std::make_shared&lt;MyStrategy&gt;();\nmdb-&gt;subscribe(strategy);\n\nstd::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors{replay};\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\nsubsystems.push_back(std::move(mdb));\n\nEngine engine(config, std::move(subsystems), std::move(connectors));\nengine.start();\n</code></pre>"},{"location":"usage/replay/#playback-speed","title":"Playback Speed","text":"<pre><code>// Maximum speed (no delays) - use for backtesting\nReplaySpeed::max()\n\n// Real-time playback\nReplaySpeed::realtime()\n\n// 10x faster than realtime\nReplaySpeed::fast(10.0)\n\n// Change speed during replay\nreplay-&gt;setSpeed(ReplaySpeed::fast(5.0));\n</code></pre>"},{"location":"usage/replay/#time-filtering","title":"Time Filtering","text":"<pre><code>ReplayConnectorConfig config{\n    .data_dir = \"/data/market\",\n    .from_ns = start_timestamp,  // Start from this time\n    .to_ns = end_timestamp       // End at this time\n};\n</code></pre>"},{"location":"usage/replay/#symbol-filtering","title":"Symbol Filtering","text":"<pre><code>ReplayConnectorConfig config{\n    .data_dir = \"/data/market\",\n    .symbols = {1, 2, 3}  // Only replay these symbol IDs\n};\n</code></pre>"},{"location":"usage/replay/#reading-without-connector","title":"Reading Without Connector","text":"<p>For analysis without the connector interface:</p>"},{"location":"usage/replay/#sequential-read","title":"Sequential Read","text":"<pre><code>#include \"flox/replay/readers/binary_log_reader.h\"\n\nreplay::ReaderConfig config{\n    .data_dir = \"/data/market\",\n    .from_ns = start_time,\n    .to_ns = end_time\n};\n\nreplay::BinaryLogReader reader(config);\n\nreader.forEach([](const replay::ReplayEvent&amp; event) {\n    if (event.type == replay::EventType::Trade) {\n        // Process trade\n    } else {\n        // Process book update\n    }\n    return true;  // Continue\n});\n</code></pre>"},{"location":"usage/replay/#memory-mapped-read","title":"Memory-Mapped Read","text":"<pre><code>#include \"flox/replay/readers/mmap_reader.h\"\n\nreplay::MmapReader::Config config{\n    .data_dir = \"/data/market\",\n    .preload_index = true\n};\n\nreplay::MmapReader reader(config);\n\n// Zero-copy access to trade records\nreader.forEachRawTrade([](const replay::TradeRecord* trade) {\n    // Direct pointer to mapped memory\n    return true;\n});\n</code></pre>"},{"location":"usage/replay/#parallel-read","title":"Parallel Read","text":"<pre><code>#include \"flox/replay/readers/parallel_reader.h\"\n\nreplay::ParallelReaderConfig config{\n    .data_dir = \"/data/market\",\n    .num_threads = 4\n};\n\nreplay::ParallelReader reader(config);\n\n// Events arrive in timestamp order across threads\nreader.forEach([](const replay::ReplayEvent&amp; event) {\n    return true;\n});\n\nauto stats = reader.stats();\nstd::cout &lt;&lt; stats.eventsPerSecond() &lt;&lt; \" events/sec\\n\";\n</code></pre>"},{"location":"usage/replay/#dataset-inspection","title":"Dataset Inspection","text":"<pre><code>auto summary = replay::BinaryLogReader::inspect(\"/data/market\");\n\nstd::cout &lt;&lt; \"Segments: \" &lt;&lt; summary.segment_count &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Events: \" &lt;&lt; summary.total_events &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Duration: \" &lt;&lt; summary.durationHours() &lt;&lt; \" hours\\n\";\nstd::cout &lt;&lt; \"Size: \" &lt;&lt; summary.total_bytes / (1024*1024) &lt;&lt; \" MB\\n\";\n</code></pre>"},{"location":"usage/replay/#segment-operations","title":"Segment Operations","text":""},{"location":"usage/replay/#merge-segments","title":"Merge Segments","text":"<pre><code>#include \"flox/replay/ops/segment_ops.h\"\n\nreplay::MergeConfig config{\n    .output_dir = \"/data/merged\",\n    .output_name = \"combined\",\n    .compression = CompressionType::LZ4\n};\n\nauto result = replay::SegmentOps::mergeDirectory(\"/data/segments\", config);\n</code></pre>"},{"location":"usage/replay/#split-by-time","title":"Split by Time","text":"<pre><code>replay::SplitConfig config{\n    .output_dir = \"/data/hourly\",\n    .mode = replay::SplitMode::ByTime,\n    .time_interval_ns = 3600LL * 1000000000LL  // 1 hour\n};\n\nauto result = replay::SegmentOps::split(\"/data/day.floxlog\", config);\n</code></pre>"},{"location":"usage/replay/#export-to-csv","title":"Export to CSV","text":"<pre><code>replay::ExportConfig config{\n    .output_path = \"/data/trades.csv\",\n    .format = replay::ExportFormat::CSV,\n    .trades_only = true\n};\n\nauto result = replay::SegmentOps::exportData(\"/data/market.floxlog\", config);\n</code></pre>"},{"location":"usage/replay/#data-validation","title":"Data Validation","text":"<pre><code>#include \"flox/replay/ops/validator.h\"\n\nreplay::ValidatorConfig val_config{\n    .verify_crc = true,\n    .verify_timestamps = true,\n    .verify_index = true,\n    .scan_all_events = true\n};\n\nreplay::DatasetValidator validator(val_config);\nauto result = validator.validate(\"/data/market\");\n\nif (!result.valid) {\n    std::cerr &lt;&lt; \"Corrupted: \" &lt;&lt; result.corrupted_segments &lt;&lt; \" segments\\n\";\n    std::cerr &lt;&lt; \"Errors: \" &lt;&lt; result.total_errors &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"usage/replay/#best-practices","title":"Best Practices","text":""},{"location":"usage/replay/#recording","title":"Recording","text":"<ol> <li>Use LZ4 compression for 2-3x size reduction with minimal CPU overhead</li> <li>Create indexes for fast timestamp-based seeking</li> <li>Use reasonable segment sizes (256 MB default is good for most cases)</li> <li>Store symbol registry alongside data for ID resolution</li> </ol>"},{"location":"usage/replay/#backtesting","title":"Backtesting","text":"<ol> <li>Use <code>ReplaySpeed::max()</code> for fastest execution</li> <li>Filter by time range to focus on specific periods</li> <li>Filter by symbols to reduce memory usage</li> <li>Validate data before critical backtests</li> </ol>"},{"location":"usage/replay/#performance","title":"Performance","text":"Reader Use Case BinaryLogReader General purpose, compressed data MmapReader Zero-copy, uncompressed data ParallelReader High throughput, multiple threads ReplayConnector Engine integration, speed control"},{"location":"usage/replay/#file-format","title":"File Format","text":"<p>Segments use the <code>.floxlog</code> extension with a compact binary format:</p> <ul> <li>64-byte aligned structures for direct memory mapping</li> <li>CRC32 checksums on all frames</li> <li>Optional LZ4 compression</li> <li>Optional seek indexes for fast timestamp lookups</li> </ul> <p>See Binary Format for specification.</p>"},{"location":"usage/running_engine/","title":"Running the FLOX Engine","text":"<p>This guide explains how to initialize and run the FLOX engine by wiring together subsystems, strategies, and connectors.</p>"},{"location":"usage/running_engine/#structure","title":"Structure","text":"<p>To launch the engine:</p> <ol> <li>Construct the required core subsystems (<code>BookUpdateBus</code>, <code>OrderExecutionBus</code>, etc.)</li> <li>Register symbols using <code>SymbolRegistry</code></li> <li>Instantiate and configure exchange connectors</li> <li>Subscribe strategies and wire their dependencies</li> <li>Pass everything into the <code>Engine</code> constructor and call <code>start()</code></li> </ol>"},{"location":"usage/running_engine/#example","title":"Example","text":"<pre><code>EngineConfig config = loadConfig();  // Load from JSON or other source\n\nauto registry = std::make_unique&lt;SymbolRegistry&gt;();\nauto bookBus = std::make_unique&lt;BookUpdateBus&gt;();\nauto tradeBus = std::make_unique&lt;TradeBus&gt;();\nauto orderBus = std::make_unique&lt;OrderExecutionBus&gt;();\n\nConnectorFactory::instance().registerConnector(\"bybit\",\n    [bookBus = bookBus.get(), tradeBus = tradeBus.get(), registry = registry.get()]\n    (const std::string&amp; symbolStr) {\n      auto symbolId = registry-&gt;getSymbolId(\"bybit\", symbolStr);\n      auto conn = std::make_shared&lt;BybitExchangeConnector&gt;(symbolStr, *symbolId);\n      conn-&gt;setCallbacks(\n          [bookBus](const BookUpdateEvent&amp; b) { bookBus-&gt;publish(b); },\n          [tradeBus](const TradeEvent&amp; t) { tradeBus-&gt;publish(t); });\n      return conn;\n    });\n\nstd::vector&lt;std::shared_ptr&lt;IExchangeConnector&gt;&gt; connectors;\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\n\n// Register symbols and create connectors\nfor (const auto&amp; ex : config.exchanges) {\n  for (const auto&amp; sym : ex.symbols) {\n    registry-&gt;registerSymbol(ex.name, sym.symbol);\n    auto conn = ConnectorFactory::instance().createConnector(ex.name, sym.symbol);\n    if (conn) connectors.push_back(conn);\n  }\n}\n\n// Load and wire strategies\nstd::vector&lt;std::shared_ptr&lt;IStrategy&gt;&gt; strategies = loadStrategiesFromConfig(registry.get());\nfor (const auto&amp; strat : strategies) {\n  bookBus-&gt;subscribe(strat.get());\n  tradeBus-&gt;subscribe(strat.get());\n}\n\n// Final wiring\nsubsystems.push_back(std::move(bookBus));\nsubsystems.push_back(std::move(tradeBus));\nsubsystems.push_back(std::move(orderBus));\nsubsystems.push_back(std::move(registry));\n\nEngine engine(config, std::move(subsystems), std::move(connectors));\nengine.start();\n</code></pre>"},{"location":"usage/running_engine/#notes","title":"Notes","text":"<ul> <li>Strategies must implement <code>IMarketDataSubscriber</code> and provide <code>id()</code> method</li> <li>Subsystems must inherit from <code>ISubsystem</code></li> <li>Connectors must inherit from <code>IExchangeConnector</code></li> <li>Connectors are responsible for publishing <code>BookUpdateEvent</code> and <code>TradeEvent</code> into their respective buses</li> <li>All components must be constructed and wired manually before engine startup</li> </ul>"},{"location":"usage/running_engine/#lifecycle","title":"Lifecycle","text":"<p>The engine will:</p> <ol> <li>Start all subsystems (including buses)</li> <li>Start all exchange connectors</li> <li>Begin dispatching events to strategies via <code>EventBus</code></li> <li>Continue running until stopped or externally terminated</li> </ol> <p>Use this pattern to construct simulation environments, test harnesses, or live trading nodes.</p>"},{"location":"usage/strategies/","title":"Writing Strategies","text":"<p>Strategies in FLOX are implemented by subclassing <code>IStrategy</code>, which defines a uniform interface for receiving market data and managing lifecycle. Strategies are market data subscribers with execution capability and injected dependencies.</p>"},{"location":"usage/strategies/#purpose","title":"Purpose","text":"<p>Encapsulate trading logic that reacts to market data and interacts with execution and control systems.</p>"},{"location":"usage/strategies/#interface-overview","title":"Interface Overview","text":"<pre><code>class IStrategy : public ISubsystem, public IMarketDataSubscriber\n{\npublic:\n  virtual ~IStrategy() = default;\n};\n</code></pre> <p><code>IStrategy</code> inherits from:</p> <ul> <li><code>ISubsystem</code> \u2014 provides <code>start()</code> and <code>stop()</code> lifecycle hooks</li> <li><code>IMarketDataSubscriber</code> \u2014 provides market data callbacks and <code>id()</code> for routing</li> </ul>"},{"location":"usage/strategies/#market-data-callbacks","title":"Market Data Callbacks","text":"<p>From <code>IMarketDataSubscriber</code>:</p> <pre><code>virtual void onBookUpdate(const BookUpdateEvent&amp; ev) {}\nvirtual void onTrade(const TradeEvent&amp; ev) {}\nvirtual void onBar(const BarEvent&amp; ev) {}\n</code></pre>"},{"location":"usage/strategies/#lifecycle","title":"Lifecycle","text":"<p>From <code>ISubsystem</code>:</p> <pre><code>virtual void start() {}\nvirtual void stop() {}\n</code></pre>"},{"location":"usage/strategies/#example-strategy","title":"Example Strategy","text":"<pre><code>class MyStrategy : public IStrategy\n{\npublic:\n  MyStrategy(IOrderExecutor* executor, IRiskManager* risk, IOrderValidator* validator)\n      : _executor(executor), _risk(risk), _validator(validator)\n  {\n  }\n\n  SubscriberId id() const override { return reinterpret_cast&lt;SubscriberId&gt;(this); }\n\n  void onBookUpdate(const BookUpdateEvent&amp; update) override\n  {\n    if (!shouldEnter(update)) return;\n\n    Order order = buildOrder(update);\n\n    std::string reason;\n    if (_validator &amp;&amp; !_validator-&gt;validate(order, reason)) return;\n    if (_risk &amp;&amp; !_risk-&gt;allow(order)) return;\n\n    _executor-&gt;submitOrder(order);\n  }\n\nprivate:\n  IOrderExecutor* _executor;\n  IRiskManager* _risk;\n  IOrderValidator* _validator;\n\n  bool shouldEnter(const BookUpdateEvent&amp; update) const\n  {\n    // Example: enter when spread is wide enough\n    return true;\n  }\n\n  Order buildOrder(const BookUpdateEvent&amp; update) const\n  {\n    return Order{\n        .symbol = update.symbol,\n        .side = Side::BUY,\n        .price = Price{100},\n        .quantity = Quantity{10},\n        .type = OrderType::LIMIT};\n  }\n};\n</code></pre>"},{"location":"usage/strategies/#best-practices","title":"Best Practices","text":"<ul> <li>Keep callbacks non-blocking</li> <li>Never retain raw event pointers</li> <li>Avoid unnecessary dependencies</li> <li>Own or store all dependencies explicitly in the strategy</li> <li>Implement <code>id()</code> to return a unique identifier (typically <code>reinterpret_cast&lt;SubscriberId&gt;(this)</code>)</li> </ul>"},{"location":"usage/strategies/#integration","title":"Integration","text":"<p>Strategies are wired with their dependencies in the engine builder or main application, and subscribed to the relevant buses:</p> <pre><code>auto strategy = std::make_shared&lt;MyStrategy&gt;(executor, risk, validator);\n\nbookUpdateBus-&gt;subscribe(strategy.get());\ntradeBus-&gt;subscribe(strategy.get());\n\nbookUpdateBus-&gt;start();\ntradeBus-&gt;start();\n</code></pre>"}]}